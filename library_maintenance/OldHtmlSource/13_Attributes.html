<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<head>
<title>Chapter 8: HDF5 Attributes</title>

<!--(Meta)==========================================================-->


<!--(Links)=========================================================-->

<link href="ed_styles/NewUGelect.css" rel="stylesheet" type="text/css">

<!--( Begin styles definition )=====================================-->
<!--     Replaced with external stylesheet 'styles_NewUG.css'.      -->
<!--( End styles definition )=======================================-->

</head>

<body>

<!-- #BeginLibraryItem "/ed_libs/Copyright.lbi" -->
<!--
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  * Copyright by The HDF Group.                                               *
  * Copyright by the Board of Trustees of the University of Illinois.         *
  * All rights reserved.                                                      *
  *                                                                           *
  * This file is part of HDF5.  The full HDF5 copyright notice, including     *
  * terms governing use, modification, and redistribution, is contained in    *
  * the files COPYING and Copyright.html.  COPYING can be found at the root   *
  * of the source code distribution tree; Copyright.html can be found at the  *
  * root level of an installed copy of the electronic HDF5 document set and   *
  * is linked from the top-level documents page.  It can also be found at     *
  * http://www.hdfgroup.org/HDF5/doc/Copyright.html.  If you do not have      *
  * access to either file, you may request a copy from help@hdfgroup.org.     *
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 -->
<!-- #EndLibraryItem --><!-- HEADER LEFT "HDF5 User's Guide" -->
<!-- HEADER RIGHT "HDF5 Attributes" -->

<!--( TOC )=========================================================-->
<SCRIPT language="JavaScript">
<!--
document.writeln ('\
<table x-use-null-cells\
                align="right"\
		width=240\
		cellspacing=0\
		class="tocTable">\
  <tr valign="top"> \
    <td class="tocTableHeaderCell" colspan="2"> \
        <span class="TableHead">Chapter Contents</span></td>\
  </tr>\
-->
<!-- Table Version 3 -->\
<!--
  <tr valign="top"> \
    <td class="tocTableContentCell2"> \
      <a href="#Intro">1.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#Intro">Introduction</a></td> \
  </tr>\
  <tr valign="top"> \
    <td class="tocTableContentCell2"> \
      <a href="#Model">2.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#Model">Programming Model</a></td>\
  </tr>\
  <tr valign="top"> \
    <td class="tocTableContentCell2"> \
      <a href="#Functions">3.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#Functions">Attribute (H5A) Function Summaries</a></td> \
  </tr>\
  <tr valign="top"> \
    <td class="tocTableContentCell2"> \
      <a href="#Working1">4.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#Working1">Working with Attributes</a><br />\
	    Attribute structure<br /> \
		Create, write, read<br /> \
		Access by name or index<br /> \
		Obtain information<br /> \
		Iterate, delete, close \
	  </td>\
  </tr>\
\
  <tr valign="top"> \
    <td class="tocTableContentCell"> \
-->
<!-- editingComment -- "tocTableContentCell" and "tocTableContentCell4" \
-->\
<!-- are the table-closing cell class.\
    <td class="tocTableContentCell2"> \
-->\
<!--
      <a href="#SpecIssues">5.</a></td>\
    <td class="tocTableContentCell4">\
	  <a href="#SpecIssues">Special Issues</a><br />\
	    Large attributes<br />\
		Attribute names<br />\
		No partial I/O\
  </td></tr>\
</table>\
')
-->
</SCRIPT>
<!--(End TOC)=======================================================-->


<!-- editingComment
  <span class="editingComment">[ [ [
  ] ] ]</span>
-->

<!-- editingComment
-->

<div align="center">
<a name="TOP">
<h2>Chapter 8<br /><font size="7">HDF5 Attributes</font></h2>
</a>
</div>


<a name="Intro">
<h3>8.1. Introduction</h3>
</a>

<p>An HDF5 <span class="termdefinition">attribute</span> is 
 a small metadata object describing the nature and/or 
 intended usage of a 
 <span class="termdefinition">primary data object</span>.
 A primary data object may be a dataset, group, or committed datatype.
</p>
 
<p>Attributes are assumed to be very small as data objects go, so 
 storing them as standard HDF5 datasets would be quite inefficient.
 HDF5 attributes are therefore managed through a special 
 attributes interface, H5A, which is designed to easily 
 attach attributes to primary data objects as 
 small datasets containing metadata information and 
 to minimize storage requirements.</p>

<p>Consider, as examples of the simplest case, a set of 
 laboratory readings taken under known temperature and 
 pressure conditions of 18.0 degrees celsius and 
 0.5 atmospheres, respectively.  
 The temperature and pressure stored as attributes of the 
 dataset could be described as the following name/value pairs:</p>
<pre>
   temp=18.0
   pressure=0.5</pre>

<p>While HDF5 attributes are not standard HDF5 datasets, 
 they have much in common:</p>
<ul>
    <li>An attribute has a user-defined dataspace and 
        the included metadata has a user-assigned datatype</li>
    <li>Metadata can be of any valid HDF5 datatype</li>
    <li>Attributes are addressed by name</li>
</ul>

<p>But there are some very important differences:</p>
 <ul>
    <li>There is no provision for special storage such as 
    compression or chunking</li>
    <li>There is no partial I/O or sub-setting capability for attribute 
    data</li>
    <li>Attributes cannot be shared</li>
    <li>Attributes cannot have attributes</li>
    <li>Being small, an attribute is stored in the object header 
        of the object it describes and is thus attached directly to 
        that object</li>
 </ul>

<p>The &ldquo;<a href="#SpecIssues">Special Issues</a>&rdquo; section below
 describes how to handle attributes that are large in size and how to handle
 large numbers of attributes.</p>

<!-- NEW PAGE -->
<p>This chapter discusses or lists the following:</p>

<ul>
	<li>The HDF5 attributes programming model</li>
	<li>H5A function summaries</li>
	<li>Working with HDF5 attributes</li>
        <ul>
	<li>The structure of an attribute</li>
	<li>Creating, writing, and reading attributes</li>
	<li>Accessing attributes by name or index</li>
	<li>Obtaining information regarding 
	    an object&rsquo;s attributes </li>
	<li>Iterating across an object&rsquo;s attributes </li>
	<li>Deleting an attribute </li>
	<li>Closing attributes </li>
        </ul>
	<li>Special issues regarding attributes</li>
</ul>


<p>In the following discussions, attributes are generally 
 attached to datasets.  Attributes attached to other 
 primary data objects, i.e., groups or committed datatypes, 
 are handled in exactly the same manner.</p>




<a name="Model">
<h3 class="pagebefore">8.2. Programming Model</h3>
</a>
<p>The figure below shows the UML model for an HDF5 attribute 
    and its associated dataspace and datatype.</p>

<!--( UML Model Box )===============================================-->

<table width="350" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/UML_Attribute.jpg" 
        alt="Image of UML model for an HDF5 attribute and its 
        associated dataspace and datatype"></td></tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 1. The UML model for an HDF5 attribute</b>
        <!-- formerly Figure 2:-->
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<!--( End UML Model )===============================================-->

<p>Creating an attribute is similar to creating a dataset. 
 To create an attribute, the application must specify the object 
 to which the attribute is attached, the datatype and dataspace 
 of the attribute data, and the attribute creation property list. 
</p>

<!-- NEW PAGE -->
<p>The following steps are required to create and write 
 an HDF5 attribute:</p>
<ol>
     <li>Obtain the object identifier for the attribute&rsquo;s primary 
         data object</li>
     <li>Define the characteristics of the attribute and specify the 
         attribute creation property list</li>
         <ul>
         <li>Define the datatype</li>
         <li>Define the dataspace</li>
         <li>Specify the attribute creation property list</li>
         </ul>
     <li>Create the attribute</li>
     <li>Write the attribute data (optional)</li>
     <li>Close the attribute (and datatype, dataspace, and 
         attribute creation property list, if necessary)</li>
     <li>Close the primary data object (if appropriate)</li>
</ol>


<h4>8.2.2. To Open and Read or Write an Existing Attribute</h4>

<p>The following steps are required to open and read/write
 an existing attribute.  Since HDF5 attributes allow no partial I/O,
 you need specify only the attribute and the attribute&rsquo;s memory datatype 
 to read it:</p>
<ol>
     <li>Obtain the object identifier for the attribute&rsquo;s primary 
         data object</li>
     <li>Obtain the attribute&rsquo;s name or index</li>
     <li>Open the attribute</li>
         <ul>
         <li>Get attribute dataspace and datatype (optional)</li>
         </ul>
     <li>Specify the attribute&rsquo;s memory type</li>
     <li>Read and/or write the attribute data</li>
     <li>Close the attribute</li>
     <li>Close the primary data object (if appropriate)</li>
</ol>


<!--
<p>The programming model for element 1 
 can be summarized as follows:</p>

<ul>
	<li class=BulletCompact>Step 1 (optional).
	<li class=BulletCompact>Step 2.
	<li class=BulletCompact>Step 3.
</ul>

<p>
 First consider the simple case, text text, 
 followed by program line:

<dir><pre>
return_var = H5Xfunction (param1, 
&nbsp;&nbsp;&nbsp;&nbsp;param2, param3,
&nbsp;&nbsp;&nbsp;&nbsp;param4)
</dir></pre>

 Text text text.  

<p>Now consider the more generalized case, text text text.

<dir><pre>
return_var = H5Xfunction (param1, param2, param3)
   &lt;...<em>text text text</em>...&gt;
return_var = H5Xfunction (param1, param2, param3)
   &lt;...<em>text text text</em>...&gt;
return_var = H5Xfunction (param1, param2, param3)
</pre></dir>

<p>Notes: 
 Text, text text.

<div class=pagenever>

<h4>2.2 Programming model element 2</h4>

-->


<!--
<a name="h5dump">
<p>&nbsp;</p>
<h3 class="pagebefore">3 Using <code>h5dump</code></h3>
</a>
<dir>

</dir>
-->

<a name="Functions">
<p>&nbsp;</p><!-- NEW PAGE -->
<h3 class="pagebefore">8.3. Attribute (H5A) Function Summaries</h3>
</a>
<p>Functions that can be used with attributes (H5A functions) and functions 
that can be used with property lists (H5P functions) are listed below.</p>


<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Function Listing 1. Attribute functions (H5A)
        </b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td>
        <b>C Function<br />Fortran Function</b>
        </td><td>&nbsp;</td>
        <td>
        <b>Purpose</b>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Acreate</code>
        <br />
        <code>h5acreate_f</code></td><td>&nbsp;</td>
        <td>
        Creates a dataset as an attribute of another group, dataset, 
        or committed datatype. 
        The C function is a macro: see <a href="../RM/APICompatMacros.html">
        &ldquo;API Compatibility Macros in HDF5.&rdquo;</a>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Acreate_by_name</code>
        <br />
        <code>h5acreate_by_name_f</code></td><td>&nbsp;</td>
        <td>
        Creates an attribute attached to a specified object. 
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Aexists</code>
        <br />
        <code>h5aexists_f</code></td><td>&nbsp;</td>
        <td>
        Determines whether an attribute with a given name exists on an object. 
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Aexists_by_name</code>
        <br />
        <code>h5aexists_by_name_f</code></td><td>&nbsp;</td>
        <td>
        Determines whether an attribute with a given name exists on an object. 
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Aclose</code>
        <br />
        <code>h5aclose_f</code></td><td>&nbsp;</td>
        <td>
        Closes the specified attribute.
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Adelete</code>
        <br />
        <code>h5adelete_f</code></td><td>&nbsp;</td>
        <td>
        Deletes an attribute.
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Adelete_by_idx</code>
        <br />
        <code>h5adelete_by_idx_f</code></td><td>&nbsp;</td>
        <td>
        Deletes an attribute from an object according to index order. 
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Adelete_by_name</code>
        <br />
        <code>h5adelete_by_name_f</code></td><td>&nbsp;</td>
        <td>
        Removes an attribute from a specified location. 
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Aget_create_plist</code>
        <br />
        <code>h5aget_create_plist_f</code></td><td>&nbsp;</td>
        <td>
        Gets an attribute creation property list identifier. 
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Aget_info</code>
        <br />
        <code>h5aget_info_f</code></td><td>&nbsp;</td>
        <td>
        Retrieves attribute information by attribute identifier. 
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Aget_info_by_idx</code>
        <br />
        <code>h5aget_info_by_idx_f</code></td><td>&nbsp;</td>
        <td>
        Retrieves attribute information by attribute index position. 
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Aget_info_by_name</code>
        <br />
        <code>h5aget_info_by_name_f</code></td><td>&nbsp;</td>
        <td>
        Retrieves attribute information by attribute name. 
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Aget_name</code>
        <br />
        <code>h5aget_name_f</code></td><td>&nbsp;</td>
        <td>
        Gets an attribute name.
        </td></tr>
    <!-- NEW PAGE -->
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Aget_name_by_idx</code>
        <br />
        <code>h5aget_name_by_idx_f</code></td><td>&nbsp;</td>
        <td>
        Gets an attribute name by attribute index position.
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Aget_space</code>
        <br />
        <code>h5aget_space_f</code></td><td>&nbsp;</td>
        <td>
        Gets a copy of the dataspace for an attribute.
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Aget_storage_size</code>
        <br />
        <code>h5aget_storage_size_f</code></td><td>&nbsp;</td>
        <td>
        Returns the amount of storage required for an attribute. 
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Aget_type</code>
        <br />
        <code>h5aget_type_f</code></td><td>&nbsp;</td>
        <td>
        Gets an attribute datatype.
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Aiterate</code>
        <br />
        <code>(none)</code></td><td>&nbsp;</td>
        <td>
        Calls a user&rsquo;s function for each attribute 
        attached to a data object.
        The C function is a macro: see <a href="../RM/APICompatMacros.html">
        &ldquo;API Compatibility Macros in HDF5.&rdquo;</a>
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Aiterate_by_name</code>
        <br />
        <code>(none)</code></td><td>&nbsp;</td>
        <td>
        Calls user-defined function for each attribute on an object. 
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Aopen</code>
        <br />
        <code>h5aopen_f</code></td><td>&nbsp;</td>
        <td>
        Opens an attribute for an object specified by object identifier and 
        attribute name. 
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Aopen_by_idx</code>
        <br />
        <code>h5aopen_by_idx_f</code></td><td>&nbsp;</td>
        <td>
        Opens an existing attribute that is attached to an object specified by 
        location and name.
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Aopen_by_name</code>
        <br />
        <code>h5aopen_by_name_f</code></td><td>&nbsp;</td>
        <td>
        Opens an attribute for an object by object name and attribute name. 
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Aread</code>
        <br />
        <code>h5aread_f</code></td><td>&nbsp;</td>
        <td>
        Reads an attribute.
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Arename</code>
        <br />
        <code>h5arename_f</code></td><td>&nbsp;</td>
        <td>
        Renames an attribute. 
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Arename_by_name</code>
        <br />
        <code>h5arename_by_name_f</code></td><td>&nbsp;</td>
        <td>
        Renames an attribute. 
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>
        <code>H5Awrite</code>
        <br />
        <code>H5awrite_f</code></td><td>&nbsp;</td>
        <td>
        Writes an attribute.
        </td></tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />





<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Function Listing 2. Attribute creation property list 
        functions (H5P) </b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign=top> 
        <td>
        <b>C Function<br />Fortran Function</b>
        </td><td>&nbsp;</td>
        <td>
        <b>Purpose</b>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign=top> 
        <td>
        <code>H5Pset_char_encoding<br />h5pset_char_encoding_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the character encoding used to encode a string. 
        Use to set ASCII or UTF-8 character encoding for object names.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign=top> 
        <td>
        <code>H5Pget_char_encoding<br />h5pget_char_encoding_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the character encoding used to create a string. 
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign=top> 
        <td>
        <code>H5Pget_attr_creation_order<br />h5pget_attr_creation_order_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves tracking and indexing settings for attribute creation order. 
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign=top> 
        <td>
        <code>H5Pget_attr_phase_change<br />h5pget_attr_phase_change_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves attribute storage phase change thresholds. 
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign=top> 
        <td>
        <code>H5Pset_attr_creation_order<br />h5pget_attr_creation_order_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets tracking and indexing of attribute creation order. 
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign=top> 
        <td>
        <code>H5Pset_attr_phase_change<br />h5pset_attr_phase_change_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets attribute storage phase change thresholds. 
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />



<a name="Working1">
<p>&nbsp;</p><!-- NEW PAGE -->
<h3 class="pagebefore">8.4. Working with Attributes</h3>
</a>


<h4>8.4.1. The Structure of an Attribute</h4>

<p>An attribute has two parts: name and value(s)</p>
<p>HDF5 attributes are sometimes discussed as name/value pairs 
 in the form <code>name=value</code>.</p>

<p>An attribute&rsquo;s name is a null-terminated ASCII or UTF-8 
character string. Each attribute attached to an object has a unique name.
</p>

<p>The value portion of the attribute contains 
 one or more data elements of the same datatype. 
</p>

<p>HDF5 attributes have all the characteristics of HDF5 datasets
 except that there is no partial I/O capability. In other words,
 attributes can be written and read only in full with no sub-setting.
</p>


<h4>8.4.2. Creating, Writing, and Reading Attributes</h4>

<p>If attributes are used in an HDF5 file, 
 these functions will be employed: <code>H5Acreate</code>, 
 <code>H5Awrite</code>, and <code>H5Aread</code>.
 <code>H5Acreate</code> and <code>H5Awrite</code> are used together
 to place the attribute in the file.
 If an attribute is to be used and is not currently in memory,
 <code>H5Aread</code> generally comes into play 
 usually in concert with one each of the 
 <code>H5Aget_*</code> and <code>H5Aopen_*</code> functions.
</p>

<dl>
 <dt><span class="RunningHead">To create an attribute</span>, 
     call <code>H5Acreate</code>:

 <dd>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <code>hid_t H5Acreate (hid_t <em>loc_id</em>, 
          const char *<em>name</em>, 
          <br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          hid_t <em>type_id</em>, 
          hid_t <em>space_id</em>, 
          hid_t <em>create_plist</em>,
          <br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          hid_t <em>access_plist</em>)</code>
</dl>
 
<p><code>loc_id</code> identifies the object (dataset, group, or committed 
datatype) to which the attribute is to be attached. 
 
 <code>name</code>, 
 <code>type_id</code>,
 <code>space_id</code>, and 
 <code>create_plist</code>
 convey, respectively, the attribute&rsquo;s name, datatype, dataspace, 
 and attribute creation property list.
 The attribute&rsquo;s name must be locally unique: 
 it must be unique within the context of the object 
 to which it is attached.</p>

<p><code>H5Acreate</code> creates the attribute in memory. 
 The attribute does not exist in the file until <code>H5Awrite</code> 
 writes it there.
</p>

<dl>
 <dt><span class="RunningHead">To write or read an attribute</span>, 
     call <code>H5Awrite</code> or <code>H5Aread</code>, respectively:

 <dd>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <code>herr_t H5Awrite (hid_t <em>attr_id</em>, 
          hid_t <em>mem_type_id</em>, 
          <br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          const void *<em>buf</em>)</code>

 <dd>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <code>herr_t H5Aread (hid_t <em>attr_id</em>, 
          hid_t <em>mem_type_id</em>, 
          <br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          void *<em>buf</em>)</code>
</dl>

<p><code>attr_id</code> identifies the attribute while
 <code>mem_type_id</code> identifies the in-memory datatype 
 of the attribute data.
</p>

<p><code>H5Awrite</code> writes the attribute data 
 from the buffer <code>buf</code> to the file. 
 <code>H5Aread</code> reads attribute data from the file into
 <code>buf</code>.
</p>

<p>The HDF5 Library converts the metadata between the 
 in-memory datatype, <code>mem_type_id</code>, and 
 the in-file datatype, defined when the attribute was created,
 without user intervention.</p>

 

<h4>8.4.3. Accessing Attributes by Name or Index</h4>

<p>Attributes can be accessed by name or index value. 
 The use of an index value makes it possible to iterate 
 through all of the attributes associated with a given object. </p>

<p><span class="RunningHead">To access an attribute by its name</span>, 
use the <code>H5Aopen_by_name</code> function. <code>H5Aopen_by_name</code> 
returns an attribute identifier that can then be used by any function that 
must access an attribute such as <code>H5Aread</code>.
Use the function <code>H5Aget_name</code> to determine an attribute&rsquo;s name.
</p>

<p><span class="RunningHead">To access an attribute by its index value
</span>, use the <code>H5Aopen_by_idx</code> function. To determine an 
attribute index value when it is not already known, 
use the <code>H5Oget_info</code>function. <code>H5Aopen_by_idx</code> is 
generally used in the course of opening several attributes for later access. 
Use <code>H5Aiterate</code> if the intent is to 
perform the same operation on every attribute attached to an object.
</p>


<h4>8.4.4. Obtaining Information Regarding an Object&rsquo;s Attributes</h4>

<p>In the course of working with HDF5 attributes, one may need to 
 obtain any of several pieces of information:</p>
<ul>
	<li>An attribute name</li>
	<li>The dataspace of an attribute </li>
	<li>The datatype of an attribute </li>
	<li>The number of attributes attached to an object</li>
</ul>

<span class="RunningHead">To obtain an attribute&rsquo;s name</span>, 
     call <code>H5Aget_name</code> with an attribute identifier, 
     <code>attr_id</code>:

 <pre>
        <code>ssize_t H5Aget_name (hid_t attr_id, size_t buf_size, 
            char *buf)</code>
</pre>

<p>As with other attribute functions, <code>attr_id</code> 
 identifies the attribute; <code>buf_size</code> defines the size of the 
 buffer; and <code>buf</code> is the buffer to which the attribute&rsquo;s name 
 will be read. 
</p>

<p>If the length of the attribute name, and hence the value required for 
 <code>buf_size</code>, is unknown, a first call to 
 <code>H5Aget_name</code> will return that size.  If the value of
 <code>buf_size</code> used in that first call is too small,
 the name will simply be truncated in <code>buf</code>.
 A second <code>H5Aget_name</code> call can then be used to retrieve the 
 name in an appropriately-sized buffer.
</p>



<span class="RunningHead">To determine the dataspace or datatype 
     of an attribute</span>, call <code>H5Aget_space</code> or 
     <code>H5Aget_type</code>, respectively:

<pre>
        <code>hid_t H5Aget_space (hid_t <em>attr_id</em>)</code>

        <code>hid_t H5Aget_type (hid_t <em>attr_id</em>)</code>

</pre>
<p><code>H5Aget_space</code> returns the dataspace identifier
 for the attribute <code>attr_id</code>.
</p>

<p><code>H5Aget_type</code> returns the datatype identifier
 for the attribute <code>attr_id</code>.
</p>


<span class="RunningHead">To determine the number of attributes 
     attached to an object</span>, use the <code>H5Oget_info</code> function.
     The function signature is below. 

<pre>
        herr_t H5Oget_info( hid_t object_id, H5O_info_t *object_info  ) 
</pre>

<p>The number of attributes will be returned in the <code>object_info</code> 
buffer. This is generally the preferred first step in determining attribute 
index values. If the call returns <code>N</code>, the 
attributes attached to the object <code>object_id</code> 
have index values of <code>0</code> through <code>N</code>
<code>-1</code>.
</p>


<h4>8.4.5. Iterating across an Object&rsquo;s Attributes</h4>

<p>It is sometimes useful to be able to perform the identical operation
 across all of the attributes attached to an object.  
 At the simplest level, you might just want to open each attribute.
 At a higher level, you might wish to perform a rather complex operation 
 on each attribute as you iterate across the set.
</p>

<dl>
 <dt><span class="RunningHead">To iterate an operation across the 
     attributes attached to an object</span>, 
     one must make a series of calls to <code>H5Aiterate</code>:

 <dd>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <code>herr_t H5Aiterate (hid_t <em>obj_id</em>, 
          H5_index_t <em>index_type</em>, 
          <br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          H5_iter_order_t <em>order</em>, 
          hsize_t *<em>n</em>,
          H5A_operator2_t <em>op</em>, 
          <br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          void *<em>op_data</em>)</code>

</dl>

<p><code>H5Aiterate</code> successively marches across all of the 
 attributes attached to the object specified in 
 <code>loc_id</code>, performing the operation(s) 
 specified in <code>op_func</code> with the data
 specified in <code>op_data</code> on each attribute.
</p>

<p>When <code>H5Aiterate</code> is called, 
<code>index</code> contains the index of the attribute 
to be accessed in this call. 
When <code>H5Aiterate</code> returns, <code>index</code> 
will contain the index of the next attribute. 
If the returned <code>index</code> is the null pointer, 
then all attributes have been processed, and the iterative process 
is complete. 
</p>

<p><code>op_func</code> is a user-defined operation 
 that adheres to the <code>H5A_operator_t</code> prototype.
 This prototype and certain requirements imposed on the operator&rsquo;s 
 behavior are  described in the <code>H5Aiterate</code> entry
 in the <a href="../RM/RM_H5Front.html">
 <cite>HDF5 Reference Manual</cite></a>.
</p>

<p><code>op_data</code> is also user-defined to meet
 the requirements of <code>op_func</code>.
 Beyond providing a parameter with which to pass this data, 
 HDF5 provides no tools for its management and imposes no restrictions.
</p>


<!-- editingComment
  <p class=editingcommentlt>[ [ [ Need example? ] ] ]</p>
-->


<h4>8.4.6. Deleting an Attribute</h4>

<p>Once an attribute has outlived its usefulness or 
 is no longer appropriate, it may become necessary to delete it.
</p>

<dl>
 <dt><span class="RunningHead">To delete an attribute</span>, 
     call <code>H5Adelete</code>:

 <dd>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <code>herr_t H5Adelete (hid_t <em>loc_id</em>, 
          const char *<em>name</em>)</code>
</dl>

<p><code>H5Adelete</code> removes the attribute 
 <code>name</code> from the group, dataset, or 
 committed datatype specified in <code>loc_id</code>.
</p>

<p><code>H5Adelete</code> must not be called if there are 
 any open attribute identifiers on the object 
 <code>loc_id</code>.  Such a call can cause 
 the internal attribute indexes to change; future writes to 
 an open attribute would then produce unintended results.
</p>


<!-- NEW PAGE -->
<h4>8.4.7. Closing an Attribute</h4>

<p>As is the case with all HDF5 objects, once access to an attribute 
 it is no longer needed, that attribute must be closed.
 It is best practice to close it as soon as practicable;
 it is mandatory that it be closed prior to the <code>H5close</code> 
 call closing the HDF5 Library.
</p>

<dl>
 <dt><span class="RunningHead">To close an attribute</span>, 
     call <code>H5Aclose</code>:

 <dd>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <code>herr_t H5Aclose (hid_t <em>attr_id</em>)</code>
</dl>

<p><code>H5Aclose</code> closes the specified attribute by terminating 
 access to its identifier, <code>attr_id</code>.
</p>

<a name="SpecIssues">
<h3 class="pagebefore">8.5. Special Issues</h3>
</a>
<p>Some special issues for attributes are discussed below.</p>



<h4>Large Numbers of Attributes Stored in Dense Attribute Storage</h4>
<p>The dense attribute storage scheme was added in version 1.8 so that
datasets, groups, and committed datatypes that have large numbers of 
attributes could be processed more quickly.</p> 

<p>Attributes start out being stored in an object's header. This is 
known as compact storage. See the <a href="UG_frame10Datasets.html">
&ldquo;Datasets&rdquo;</a> chapter for more information on compact, 
contiguous, and chunked storage.</p>

<p>As the number of attributes grows, attribute-related performance 
slows. To improve performance, dense attribute storage can be initiated 
with the <code>H5Pset_attr_phase_change</code> function. See the 
<a href=http://www.hdfgroup.org/HDF5/doc/RM/RM_H5Front.html>
<cite>HDF5 Reference Manual</cite></a> for more information. </p>

<p>When dense attribute storage is enabled, a threshold is defined for
the number of attributes kept in compact storage. When the number
is exceeded, the library moves all of the attributes into dense 
storage at another location. The library handles the movement of
attributes and the pointers between the locations automatically. 
If some of the attributes are deleted so that the number falls below
the threshold, then the attributes are moved back to compact storage
by the library.</p> 

<p>The improvements in performance from using dense attribute storage 
are the result of holding attributes in a heap and indexing the heap
with a B-tree.</p>

<p>Note that there are some disadvantages to using dense attribute 
storage. One is that this is a new feature. Datasets, groups, and 
committed datatypes that use dense storage cannot be read by 
applications built with earlier versions of the library. Another 
disadvantage is that attributes in dense storage cannot be compressed.</p>

<h4>Large Attributes Stored in Dense Attribute Storage</h4>

<p>We generally consider the maximum size of an attribute to be 64K 
bytes. The library has two ways of storing attributes larger than 64K 
bytes: in dense attribute storage or in a separate dataset. Using dense
attribute storage is described in this section, and storing in a 
separate dataset is described in the next section.</p>

<p>To use dense attribute storage to store large attributes, set the 
number of attributes that will be stored in compact storage to 0 with 
the <code>H5Pset_attr_phase_change</code> function. This will force 
all attributes to be put into dense attribute storage and will avoid 
the 64KB size limitation for a single attribute in compact attribute 
storage.</p>

<p>The example code below illustrates how to create a large attribute 
that will be kept in dense storage.</p>

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
/*
Test use of dense attribute

*/
#define N 82000000
#include "hdf5.h"
#include <stdio.h>
#include <stdlib.h>

int main(){

hid_t fid, gid, sid, aid, gpid, fpid;
hsize_t dims[] = {N};
double *buf;
int i;
herr_t status;

buf = (double *) malloc(sizeof(double) * N);
for (i=0; i &#60;N; i++) { buf[i] = -100.0; }
fpid = H5Pcreate (H5P_FILE_ACCESS);
status = H5Pset_libver_bounds (fpid, H5F_LIBVER_LATEST, H5F_LIBVER_LATEST);
fid = H5Fcreate("adense.h5", H5F_ACC_TRUNC, H5P_DEFAULT, fpid);
gpid = H5Pcreate (H5P_GROUP_CREATE);
status = H5Pset_attr_phase_change (gpid, 0, 0);

gid = H5Gcreate(fid, "testgrp", H5P_DEFAULT, gpid, H5P_DEFAULT);
sid = H5Screate_simple(1, dims, NULL);

aid = H5Acreate(gid, "bar", H5T_NATIVE_DOUBLE, sid, H5P_DEFAULT, H5P_DEFAULT);
status = H5Awrite(aid, H5T_NATIVE_DOUBLE, buf);

/* If you remove these two lines, it doesn't crash */
status = H5Aclose(aid);
status = H5Pclose (gpid);
status = H5Pclose (fpid);
status = H5Gclose(gid);
status = H5Fclose (fid);

return 0;
}

</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>

    <tr valign="top">
        <td align="left">
        <b>Example 1. Create a large attribute in dense storage</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



<h4>Large Attributes Stored in a Separate Dataset</h4>

<p>In addition to dense attribute storage (see above), a large attribute 
can be stored in a separate dataset. In the figure below, DatasetA holds 
an attribute that is too large for the object header in Dataset1. By putting 
a pointer to DatasetA as an attribute in Dataset1, the attribute becomes 
available to those working with Dataset1.</p>
<!-- formerly Figure 3 -->

<p>This way of handling large attributes can be used in situations where
backward compatibility is important and where compression is important. 
Applications built with versions before 1.8.x can read large 
attributes stored in separate datasets. Datasets can be compressed 
while attributes cannot. </p>


<table width="400" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Shared_Attribute.jpg"></td></tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 2. A large or shared HDF5 attribute 
        and its associated dataset(s)</b>
        <!-- formerly Figure 3: -->
        <br /><code>DatasetA</code> is an attribute of 
        <code>Dataset1</code> that is too large 
        to store in <code>Dataset1's</code> header.  
        <code>DatasetA</code> is associated with <code>Dataset1</code> 
        by means of an object reference pointer attached as an 
        attribute to <code>Dataset1</code>. The attribute in 
        <code>DatasetA</code> can be shared among multiple datasets by 
        means of additional object reference pointers attached
        to additional datasets.
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />


<h4>Shared Attributes</h4>
<p>Attributes written and managed through the H5A interface cannot 
be shared. If shared attributes are required, they must be handled 
in the manner described above for large attributes and illustrated 
in the figure above<!-- formerly Figure 3 -->.</p>

<h4>Attribute Names</h4>
<p>While any ASCII or UTF-8 character may be used in the name given 
to an attribute, it is usually wise to avoid the following kinds of 
characters:</p>
<ul>
    <li>Commonly used separators or delimiters such as slash, backslash, 
    colon, and semi-colon (\, /, :, ;)</li>
    <li>Escape characters</li>
    <li>Wild cards such as asterisk and question mark (*, ?)</li>
</ul>
<p>NULL can be used within a name, but HDF5 names are terminated with 
a NULL: whatever comes after the NULL will be ignored by HDF5.</p>

<p>The use of ASCII or UTF-8 characters is determined by the character 
encoding property. See <code>H5Pset_char_encoding</code> in the 
<a href="http://www.hdfgroup.org/HDF5/doc/RM/RM_H5Front.html">
<cite>HDF5 Reference Manual</cite></a>.</p>

<h4>No Special I/O or Storage</h4>
<p>HDF5 attributes have all the characteristics of HDF5 datasets 
     except the following:</p>
     <ul>
     <li>Attributes are written and read only in full: 
       there is no provision for partial I/O or sub-setting</li>
     <li>No special storage capability is provided for attributes: 
       there is no compression or chunking, and 
       attributes are not extendable</li>
    </ul>
        

<!--
<a name="Examples">
<p>&nbsp;</p>
<h3 class="pagebefore">13.00 Code Examples for Text Text Text</h3>
</a>
<dir>


<p class=editingcomment>[ [ [ Comprehensive example set yet to be prepared. ] ] ]</p>


<h4>13.00.1 Example using text text text</h4>


<p>The following example ....:
 </p>

<dir><pre>
code
code
code
</pre></dir>

<h4>13.00.2 Example using text text text</h4>

<p>This example shows how ....:
 </p>

<dir><pre>
code
code
code
</pre></dir>

</dir>
-->
 

</body>
</html>
