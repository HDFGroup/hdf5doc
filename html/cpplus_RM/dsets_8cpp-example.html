<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 10">
<meta name=Originator content="Microsoft Word 10">
<link rel=File-List href="header_files/filelist.xml">
<link rel=Edit-Time-Data href="header_files/editdata.mso">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Main Page</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Randy Ribler</o:Author>
  <o:Template>Normal</o:Template>
  <o:LastAuthor>Randy Ribler</o:LastAuthor>
  <o:Revision>6</o:Revision>
  <o:TotalTime>16</o:TotalTime>
  <o:Created>2004-07-23T05:34:00Z</o:Created>
  <o:LastSaved>2004-07-23T06:03:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>5</o:Words>
  <o:Characters>32</o:Characters>
  <o:Company>LC</o:Company>
  <o:Lines>1</o:Lines>
  <o:Paragraphs>1</o:Paragraphs>
  <o:CharactersWithSpaces>36</o:CharactersWithSpaces>
  <o:Version>10.2625</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:SpellingState>Clean</w:SpellingState>
  <w:GrammarState>Clean</w:GrammarState>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]-->
<link rel=Stylesheet type="text/css" media=all href=doxygen.css>
<style>
<!--
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-believe-normal-left:yes;}
h1
	{mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	text-align:center;
	mso-pagination:widow-orphan;
	mso-outline-level:1;
	font-size:24.0pt;
	font-family:"Times New Roman";
	font-weight:bold;}
h2
	{mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	mso-outline-level:2;
	font-size:18.0pt;
	font-family:"Times New Roman";
	font-weight:bold;}
a:link, span.MsoHyperlink
	{color:#252E78;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:#3D2185;
	text-decoration:underline;
	text-underline:single;}
p
	{mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
address
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	font-style:italic;}
pre
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";}
p.formuladsp, li.formuladsp, div.formuladsp
	{mso-style-name:formuladsp;
	mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	text-align:center;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.mdtable, li.mdtable, div.mdtable
	{mso-style-name:mdtable;
	mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	background:#F4F4FB;
	border:none;
	mso-border-alt:solid #868686 .75pt;
	padding:0in;
	mso-padding-alt:0in 0in 0in 0in;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.mdrow, li.mdrow, div.mdrow
	{mso-style-name:mdrow;
	mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.mdescleft, li.mdescleft, div.mdescleft
	{mso-style-name:mdescleft;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	background:#FAFAFA;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-style:italic;}
p.mdescright, li.mdescright, div.mdescright
	{mso-style-name:mdescright;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	background:#FAFAFA;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-style:italic;}
p.memitemleft, li.memitemleft, div.memitemleft
	{mso-style-name:memitemleft;
	margin:3.0pt;
	mso-pagination:widow-orphan;
	background:#FAFAFA;
	border:none;
	mso-border-top-alt:solid #E0E0E0 .75pt;
	padding:0in;
	mso-padding-alt:1.0pt 0in 0in 0in;
	font-size:9.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.memitemright, li.memitemright, div.memitemright
	{mso-style-name:memitemright;
	margin:3.0pt;
	mso-pagination:widow-orphan;
	background:#FAFAFA;
	border:none;
	mso-border-top-alt:solid #E0E0E0 .75pt;
	padding:0in;
	mso-padding-alt:1.0pt 0in 0in 0in;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.search, li.search, div.search
	{mso-style-name:search;
	mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Table Normal";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0in 5.4pt 0in 5.4pt;
	mso-para-margin:0in;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";}
table.MsoTableGrid
	{mso-style-name:"Table Grid";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	border:solid windowtext 1.0pt;
	mso-border-alt:solid windowtext .5pt;
	mso-padding-alt:0in 5.4pt 0in 5.4pt;
	mso-border-insideh:.5pt solid windowtext;
	mso-border-insidev:.5pt solid windowtext;
	mso-para-margin:0in;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";}
</style>
<![endif]--><![if mso 9]>
<style>
p.MsoNormal
	{margin-left:15.0pt;}
</style>
<![endif]><!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext="edit" spidmax="4098">
  <o:colormru v:ext="edit" colors="#060"/>
  <o:colormenu v:ext="edit" strokecolor="#060"/>
 </o:shapedefaults></xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
</head>

<body bgcolor=white lang=EN-US link="#252E78" vlink="#3D2185" style='tab-interval:
.5in;margin-left:15.0pt;margin-right:15.0pt'>

<div class=Section1>

<p class=MsoNormal style='margin-top:0in;margin-right:15.0pt;margin-bottom:
0in;margin-left:15.0pt;margin-bottom:.0001pt'><!--[if gte vml 1]><v:shapetype
 id="_x0000_t75" coordsize="21600,21600" o:spt="75" o:preferrelative="t"
 path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="_x0000_s1026" type="#_x0000_t75" style='position:absolute;
 left:0;text-align:left;margin-left:30pt;margin-top:9pt;width:72.75pt;height:57.75pt;
 z-index:1'>
 <v:imagedata src="header_files/image001.jpg" o:title="NCSAlogo"/>
</v:shape><![endif]--><![if !vml]><span style='mso-ignore:vglayout;position:
absolute;z-index:1;left:0px;margin-left:40px;margin-top:12px;width:97px;
height:77px'><img width=97 height=77 src="header_files/image002.jpg" v:shapes="_x0000_s1026"></span><![endif]><span
style='mso-spacerun:yes'> </span><b style='mso-bidi-font-weight:normal'><span
style='font-size:22.0pt'><o:p></o:p></span></b></p>

<div align=center>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='margin-left:103.45pt;border-collapse:collapse;border:none;mso-border-bottom-alt:
 solid #006600 2.25pt;mso-yfti-tbllook:480;mso-padding-alt:0in 5.4pt 0in 5.4pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-lastrow:yes;height:29.25pt'>
  <td width=443 valign=top style='width:332.6pt;border:none;border-bottom:solid #006600 2.25pt;
  padding:0in 5.4pt 0in 5.4pt;height:29.25pt'>
  <p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span
  style='font-size:22.0pt'>HDF5 C++ API Reference Manual</span></b></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

</div>

</body>

</html>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>dsets.cpp</h1><dl compact><dt><b>Dataset example:</b></dt><dd>This is an example of how to create, write, and read datasets. <pre><div class="fragment"><span class="comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>
<span class="comment">  * Copyright by the Board of Trustees of the University of Illinois.         *</span>
<span class="comment">  * All rights reserved.                                                      *</span>
<span class="comment">  *                                                                           *</span>
<span class="comment">  * This file is part of HDF5.  The full HDF5 copyright notice, including     *</span>
<span class="comment">  * terms governing use, modification, and redistribution, is contained in    *</span>
<span class="comment">  * the files COPYING and Copyright.html.  COPYING can be found at the root   *</span>
<span class="comment">  * of the source code distribution tree; Copyright.html can be found at the  *</span>
<span class="comment">  * root level of an installed copy of the electronic HDF5 document set and   *</span>
<span class="comment">  * is linked from the top-level documents page.  It can also be found at     *</span>
<span class="comment">  * http://hdf.ncsa.uiuc.edu/HDF5/doc/Copyright.html.  If you do not have     *</span>
<span class="comment">  * access to either file, you may request a copy from hdfhelp@ncsa.uiuc.edu. *</span>
<span class="comment">  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="comment">/*****************************************************************************</span>
<span class="comment">   FILE</span>
<span class="comment">   dsets.cpp - HDF5 C++ testing the functionalities associated with the</span>
<span class="comment">        C dataset interface (H5D)</span>
<span class="comment"></span>
<span class="comment">   EXTERNAL ROUTINES/VARIABLES:</span>
<span class="comment">     These routines are in the test directory of the C library:</span>
<span class="comment">        h5_reset() -- in h5test.c, resets the library by closing it</span>
<span class="comment">        h5_fileaccess() -- in h5test.c, returns a file access template</span>
<span class="comment">        h5_fixname() -- in h5test.c, create a file name from a file base name</span>
<span class="comment">        h5_cleanup() -- in h5test.c, cleanup temporary test files</span>
<span class="comment"></span>
<span class="comment"> ***************************************************************************/</span>

<span class="preprocessor">#ifdef OLD_HEADER_FILENAME</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;iostream.h&gt;</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include "<a class="code" href="H5Cpp_8h.html">H5Cpp.h</a>"</span>
<span class="preprocessor">#include "h5test.h"</span>
<span class="preprocessor">#include "testhdf5.h"</span>

<span class="preprocessor">#ifndef H5_NO_NAMESPACE</span>
<span class="preprocessor"></span><span class="keyword">using</span> <span class="keyword">namespace </span>H5;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include "h5cpputil.h"</span>

<span class="keyword">const</span> <span class="keywordtype">char</span> *FILENAME[] = {
    <span class="stringliteral">"dataset"</span>,
    NULL
};

<span class="preprocessor">#define DSET_DEFAULT_NAME       "default"</span>
<span class="preprocessor"></span><span class="preprocessor">#define DSET_CHUNKED_NAME       "chunked"</span>
<span class="preprocessor"></span><span class="preprocessor">#define DSET_SIMPLE_IO_NAME     "simple_io"</span>
<span class="preprocessor"></span><span class="preprocessor">#define DSET_TCONV_NAME         "tconv"</span>
<span class="preprocessor"></span><span class="preprocessor">#define DSET_COMPRESS_NAME      "compressed"</span>
<span class="preprocessor"></span><span class="preprocessor">#define DSET_BOGUS_NAME         "bogus"</span>
<span class="preprocessor"></span>
<span class="preprocessor">#define H5Z_FILTER_BOGUS                305</span>
<span class="preprocessor"></span>
<span class="comment">/* Local prototypes for filter functions */</span>
<span class="keyword">static</span> size_t bogus(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags, size_t cd_nelmts, 
    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *cd_values, size_t nbytes, size_t *buf_size, <span class="keywordtype">void</span> **buf);


<span class="comment">/*-------------------------------------------------------------------------</span>
<span class="comment"> * Function:    test_create</span>
<span class="comment"> *</span>
<span class="comment"> * Purpose:     Attempts to create a dataset.</span>
<span class="comment"> *</span>
<span class="comment"> * Return:      Success:        0</span>
<span class="comment"> *</span>
<span class="comment"> *              Failure:        -1</span>
<span class="comment"> *</span>
<span class="comment"> * Programmer:  Binh-Minh Ribler (using C version)</span>
<span class="comment"> *              Friday, January 5, 2001</span>
<span class="comment"> *</span>
<span class="comment"> * Modifications:</span>
<span class="comment"> *</span>
<span class="comment"> *-------------------------------------------------------------------------</span>
<span class="comment"> */</span>
<span class="keyword">static</span> herr_t
test_create( H5File&amp; file)
{
   TESTING(<span class="stringliteral">"create, open, close"</span>);

    <span class="keywordflow">try</span> {
        <span class="comment">/* Create the data space */</span>
        hsize_t     dims[2];
        dims[0] = 256;
        dims[1] = 512;
        DataSpace space (2, dims, NULL);

        <span class="comment">/*</span>
<span class="comment">        * Create a dataset using the default dataset creation properties.       </span>
<span class="comment">        * We're not sure what they are, so we won't check.</span>
<span class="comment">        */</span>
        DataSet *dataset = <span class="keyword">new</span> DataSet (file.createDataSet 
                (DSET_DEFAULT_NAME, PredType::NATIVE_DOUBLE, space));

        <span class="comment">/* Close the dataset */</span>
        <span class="keyword">delete</span> dataset;

        <span class="comment">/* Add a comment to the dataset */</span>
        file.setComment (DSET_DEFAULT_NAME, <span class="stringliteral">"This is a dataset"</span>);

        <span class="comment">/*</span>
<span class="comment">        * Try creating a dataset that already exists.  This should fail since a</span>
<span class="comment">        * dataset can only be created once.  If an exception is not thrown</span>
<span class="comment">        * for this action by createDataSet, then display failure information</span>
<span class="comment">        * and jump to label error: to return.</span>
<span class="comment">        */</span>
        <span class="keywordflow">try</span> {
            dataset = <span class="keyword">new</span> DataSet (file.createDataSet 
                        (DSET_DEFAULT_NAME, PredType::NATIVE_DOUBLE, space));
            <span class="comment">// continuation here, that means no exception has been thrown</span>
            H5_FAILED();
            cout &lt;&lt; <span class="stringliteral">"    Library allowed overwrite of existing dataset."</span> &lt;&lt; endl;
            <span class="keywordflow">goto</span> error;
        }
        <span class="keywordflow">catch</span> (FileIException E ) <span class="comment">// catching invalid creating dataset</span>
        {
            <span class="comment">// Exception is expected.  Do nothing here.</span>
        }
        <span class="comment">/*</span>
<span class="comment">        * Open the dataset we created above and then close it.  This is how</span>
<span class="comment">        * existing datasets are accessed.</span>
<span class="comment">        */</span>
        dataset = <span class="keyword">new</span> DataSet (file.openDataSet (DSET_DEFAULT_NAME));
        <span class="keyword">delete</span> dataset;
    
        <span class="comment">/*</span>
<span class="comment">        * Try opening a non-existent dataset.  This should fail so if an</span>
<span class="comment">        * exception is not thrown for this action by openDataSet, then </span>
<span class="comment">        * display failure information and jump to label error: to return.</span>
<span class="comment">        */</span>
        <span class="keywordflow">try</span> {
            dataset = <span class="keyword">new</span> DataSet (file.openDataSet( <span class="stringliteral">"does_not_exist"</span> ));
            <span class="comment">// continuation here, that means no exception has been thrown</span>
            H5_FAILED();
            cout &lt;&lt; <span class="stringliteral">"    Opened a non-existent dataset."</span> &lt;&lt; endl;
            <span class="keywordflow">goto</span> error;
        }
        <span class="keywordflow">catch</span> (FileIException E ) <span class="comment">// catching creating non-existent dataset</span>
        {
            <span class="comment">// Exception is expected.  Do nothing here.</span>
        }

        <span class="comment">/*</span>
<span class="comment">        * Create a new dataset that uses chunked storage instead of the default</span>
<span class="comment">        * layout.</span>
<span class="comment">        */</span>
        DSetCreatPropList create_parms;
        hsize_t     csize[2];
        csize[0] = 5;
        csize[1] = 100;
        create_parms.setChunk( 2, csize );

        dataset = <span class="keyword">new</span> DataSet (file.createDataSet 
                (DSET_CHUNKED_NAME, PredType::NATIVE_DOUBLE, space, create_parms));
        <span class="comment">// Note: this one has no error message in C when failure occurs?</span>

        <span class="comment">/*</span>
<span class="comment">        * Close the chunked dataset.</span>
<span class="comment">        */</span>
        <span class="keyword">delete</span> dataset;

        PASSED();
        <span class="keywordflow">return</span> 0;
   }    <span class="comment">// outer most try block</span>

   <span class="comment">// catch all dataset, file, space, plist exceptions</span>
   <span class="keywordflow">catch</span> (Exception E) { <span class="keywordflow">goto</span> error; }
   
 error:
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/*-------------------------------------------------------------------------</span>
<span class="comment"> * Function:    check_values</span>
<span class="comment"> *</span>
<span class="comment"> * Purpose:     Checks a read value against the written value.  If they are </span>
<span class="comment"> *              different, the function will</span>
<span class="comment"> *              print out a message and the different values.  This function</span>
<span class="comment"> *              is made to reuse the code segment that is used in various</span>
<span class="comment"> *              places throughout test_compression and in test_simple_io.  </span>
<span class="comment"> *              Where the C version</span>
<span class="comment"> *              of this code segment "goto error," this function will</span>
<span class="comment"> *              return -1, so that the caller can "goto error."</span>
<span class="comment"> *</span>
<span class="comment"> * Return:      Success:        0</span>
<span class="comment"> *</span>
<span class="comment"> *              Failure:        -1</span>
<span class="comment"> *</span>
<span class="comment"> * Programmer:  Binh-Minh Ribler (using C code segment for checking values)</span>
<span class="comment"> *              Friday, February 6, 2001</span>
<span class="comment"> *</span>
<span class="comment"> * Modifications:</span>
<span class="comment"> *</span>
<span class="comment"> *-------------------------------------------------------------------------</span>
<span class="comment"> */</span>
<span class="keyword">static</span> <span class="keywordtype">int</span> 
check_values (hsize_t i, hsize_t j, <span class="keywordtype">int</span> apoint, <span class="keywordtype">int</span> acheck)
{
    <span class="keywordflow">if</span> (apoint != acheck)
    {
        H5_FAILED();
        cout &lt;&lt; <span class="stringliteral">"    Read different values than written.\n"</span> &lt;&lt; endl;
        cout &lt;&lt; <span class="stringliteral">"    At index "</span> &lt;&lt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)i &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; 
        (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)j &lt;&lt; endl;
        <span class="keywordflow">return</span> -1;
    }
    <span class="keywordflow">return</span> 0;
} <span class="comment">// check_values</span>

<span class="comment">/*-------------------------------------------------------------------------</span>
<span class="comment"> * Function:    test_simple_io</span>
<span class="comment"> *</span>
<span class="comment"> * Purpose:     Tests simple I/O.  That is, reading and writing a complete</span>
<span class="comment"> *              multi-dimensional array without data type or data space</span>
<span class="comment"> *              conversions, without compression, and stored contiguously.</span>
<span class="comment"> *</span>
<span class="comment"> * Return:      Success:        0</span>
<span class="comment"> *</span>
<span class="comment"> *              Failure:        -1</span>
<span class="comment"> *</span>
<span class="comment"> * Programmer:  Binh-Minh Ribler (using C version)</span>
<span class="comment"> *              Friday, January 5, 2001</span>
<span class="comment"> *</span>
<span class="comment"> * Modifications:</span>
<span class="comment"> *</span>
<span class="comment"> *-------------------------------------------------------------------------</span>
<span class="comment"> */</span>
<span class="keyword">static</span> herr_t
test_simple_io( H5File&amp; file)
{

    TESTING(<span class="stringliteral">"simple I/O"</span>);

    <span class="keywordtype">int</span> points[100][200];
    <span class="keywordtype">int</span> check[100][200];
    <span class="keywordtype">int</span>         i, j, n;

    <span class="comment">/* Initialize the dataset */</span>
    <span class="keywordflow">for</span> (i = n = 0; i &lt; 100; i++)
    {
        <span class="keywordflow">for</span> (j = 0; j &lt; 200; j++) {
            points[i][j] = n++;
        }
    }

    <span class="keywordtype">char</span>* tconv_buf = <span class="keyword">new</span> <span class="keywordtype">char</span> [1000];
    <span class="keywordflow">try</span> 
    {
        <span class="comment">/* Create the data space */</span>
        hsize_t dims[2];
        dims[0] = 100;
        dims[1] = 200;
        DataSpace space (2, dims, NULL);

        <span class="comment">/* Create a small conversion buffer to test strip mining */</span>
        DSetMemXferPropList xfer;

        xfer.setBuffer (1000, tconv_buf, NULL);

        <span class="comment">/* Create the dataset */</span>
        DataSet dataset (file.createDataSet (DSET_SIMPLE_IO_NAME, PredType::NATIVE_INT, space));

        <span class="comment">/* Write the data to the dataset */</span>
        dataset.write ((<span class="keywordtype">void</span>*) points, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);

        <span class="comment">/* Read the dataset back */</span>
        dataset.read ((<span class="keywordtype">void</span>*) check, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);

        <span class="comment">/* Check that the values read are the same as the values written */</span>
        <span class="keywordflow">for</span> (i = 0; i &lt; 100; i++)
            <span class="keywordflow">for</span> (j = 0; j &lt; 200; j++)
            {
                <span class="keywordtype">int</span> status = check_values (i, j, points[i][j], check[i][j]);
                <span class="keywordflow">if</span> (status == -1) <span class="keywordflow">goto</span> error;
            }

        <span class="keyword">delete</span> [] tconv_buf;
        PASSED();
        <span class="keywordflow">return</span> 0;
    }  <span class="comment">// end try</span>

    <span class="comment">// catch all dataset, space, plist exceptions</span>
    <span class="keywordflow">catch</span> (Exception E) { <span class="keywordflow">goto</span> error; }
   
  error:
    <span class="comment">// cleaning up</span>
    <span class="keywordflow">if</span> (tconv_buf)
        <span class="keyword">delete</span> [] tconv_buf;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/*-------------------------------------------------------------------------</span>
<span class="comment"> * Function:    test_tconv</span>
<span class="comment"> *</span>
<span class="comment"> * Purpose:     Test some simple data type conversion stuff.</span>
<span class="comment"> *</span>
<span class="comment"> * Return:      Success:        0</span>
<span class="comment"> *</span>
<span class="comment"> *              Failure:        -1</span>
<span class="comment"> *</span>
<span class="comment"> * Programmer:  Binh-Minh Ribler (using C version)</span>
<span class="comment"> *              Friday, January 5, 2001</span>
<span class="comment"> *</span>
<span class="comment"> * Modifications:</span>
<span class="comment"> *</span>
<span class="comment"> *-------------------------------------------------------------------------</span>
<span class="comment"> */</span>
<span class="keyword">static</span> herr_t
test_tconv( H5File&amp; file)
{
    <span class="comment">// Prepare buffers for input/output</span>
    <span class="keywordtype">char</span>        *out=NULL, *in=NULL;
    out = <span class="keyword">new</span> <span class="keywordtype">char</span> [4*1000000];
    <span class="comment">// assert (out); - should use exception handler for new - BMR</span>
    in = <span class="keyword">new</span> <span class="keywordtype">char</span> [4*1000000];
    <span class="comment">//assert (in);</span>

    TESTING(<span class="stringliteral">"data type conversion"</span>);
    
    <span class="comment">/* Initialize the dataset */</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000000; i++) {
        out[i*4+0] = 0x11;
        out[i*4+1] = 0x22;
        out[i*4+2] = 0x33;
        out[i*4+3] = 0x44;
    }

    <span class="keywordflow">try</span>
    {
        <span class="comment">/* Create the data space */</span>
        hsize_t dims[1];
        dims[0] = 1000000;
        DataSpace space (1, dims, NULL);

        <span class="comment">/* Create the data set */</span>
        DataSet dataset (file.createDataSet (DSET_TCONV_NAME, PredType::STD_I32LE, space));

        <span class="comment">/* Write the data to the dataset */</span>
        dataset.write ((<span class="keywordtype">void</span>*) out, PredType::STD_I32LE);

        <span class="comment">/* Read data with byte order conversion */</span>
        dataset.read ((<span class="keywordtype">void</span>*) in, PredType::STD_I32BE);

        <span class="comment">/* Check */</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000000; i++) {
            <span class="keywordflow">if</span> (in[4*i+0]!=out[4*i+3] ||
                in[4*i+1]!=out[4*i+2] ||
                in[4*i+2]!=out[4*i+1] ||
                in[4*i+3]!=out[4*i+0]) 
            {
                H5_FAILED();
                cout &lt;&lt; <span class="stringliteral">"    Read with byte order conversion failed."</span> &lt;&lt; endl;
                <span class="keywordflow">goto</span> error;
            }
        }

        <span class="keyword">delete</span> [] out;
        <span class="keyword">delete</span> [] in;
        cout &lt;&lt; <span class="stringliteral">" PASSED"</span> &lt;&lt; endl;
        <span class="keywordflow">return</span> 0;
    }  <span class="comment">// end try</span>

    <span class="comment">// catch all dataset and space exceptions</span>
    <span class="keywordflow">catch</span> (Exception E) { <span class="keywordflow">goto</span> error; }
   
  error:
        <span class="keyword">delete</span> [] out;
        <span class="keyword">delete</span> [] in;
        <span class="keywordflow">return</span> -1;
}

<span class="comment">/* This message derives from H5Z */</span>
<span class="keyword">const</span> H5Z_class_t H5Z_BOGUS[1] = {{
    H5Z_FILTER_BOGUS,           <span class="comment">/* Filter id number             */</span>
    <span class="stringliteral">"bogus"</span>,                    <span class="comment">/* Filter name for debugging    */</span>
    NULL,                       <span class="comment">/* The "can apply" callback     */</span>
    NULL,                       <span class="comment">/* The "set local" callback     */</span>
    bogus,                      <span class="comment">/* The actual filter function   */</span>
}};

<span class="comment">/*-------------------------------------------------------------------------</span>
<span class="comment"> * Function:    bogus</span>
<span class="comment"> *</span>
<span class="comment"> * Purpose:     A bogus compression method that doesn't do anything.</span>
<span class="comment"> *</span>
<span class="comment"> * Return:      Success:        Data chunk size</span>
<span class="comment"> *</span>
<span class="comment"> *              Failure:        0</span>
<span class="comment"> *</span>
<span class="comment"> * Programmer:  Robb Matzke</span>
<span class="comment"> *              Tuesday, April 21, 1998</span>
<span class="comment"> *</span>
<span class="comment"> * Modifications:</span>
<span class="comment"> *</span>
<span class="comment"> *-------------------------------------------------------------------------</span>
<span class="comment"> */</span>
<span class="keyword">static</span> size_t
<span class="comment">/*bogus(unsigned int UNUSED flags, size_t UNUSED cd_nelmts,</span>
<span class="comment">      const unsigned int UNUSED cd_values[], size_t nbytes,</span>
<span class="comment">      size_t UNUSED *buf_size, void UNUSED **buf)</span>
<span class="comment">BMR: removed UNUSED for now until asking Q. or R. to pass compilation*/</span>
bogus(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags, size_t cd_nelmts,
      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cd_values[], size_t nbytes,
      size_t *buf_size, <span class="keywordtype">void</span> **buf)
{
    <span class="keywordflow">return</span> nbytes;
}


<span class="comment">/*-------------------------------------------------------------------------</span>
<span class="comment"> * Function:    test_compression</span>
<span class="comment"> *</span>
<span class="comment"> * Purpose:     Tests dataset compression. If compression is requested when</span>
<span class="comment"> *              it hasn't been compiled into the library (such as when</span>
<span class="comment"> *              updating an existing compressed dataset) then data is sent to</span>
<span class="comment"> *              the file uncompressed but no errors are returned.</span>
<span class="comment"> *</span>
<span class="comment"> * Return:      Success:        0</span>
<span class="comment"> *</span>
<span class="comment"> *              Failure:        -1</span>
<span class="comment"> *</span>
<span class="comment"> * Programmer:  Binh-Minh Ribler (using C version)</span>
<span class="comment"> *              Friday, January 5, 2001</span>
<span class="comment"> *</span>
<span class="comment"> * Modifications:</span>
<span class="comment"> *</span>
<span class="comment"> *-------------------------------------------------------------------------</span>
<span class="comment"> */</span>

<span class="keyword">static</span> herr_t
test_compression(H5File&amp; file)
{
    <span class="keyword">const</span> <span class="keywordtype">char</span>          *not_supported;
    not_supported = <span class="stringliteral">"    Deflate compression is not enabled."</span>;
    <span class="keywordtype">int</span>         points[100][200];
    <span class="keywordtype">int</span>         check[100][200];
    hsize_t     i, j, n;

    <span class="comment">/* Initialize the dataset */</span>
    <span class="keywordflow">for</span> (i = n = 0; i &lt; 100; i++)
    {
        <span class="keywordflow">for</span> (j = 0; j &lt; 200; j++) {
            points[i][j] = n++;
        }
    }
    <span class="keywordtype">char</span>* tconv_buf = <span class="keyword">new</span> <span class="keywordtype">char</span> [1000];

    <span class="keywordflow">try</span> 
    {
        <span class="keyword">const</span> hsize_t   size[2] = {100, 200};
        <span class="comment">/* Create the data space */</span>
        DataSpace space1(2, size, NULL);

        <span class="comment">/*</span>
<span class="comment">        * Create a small conversion buffer to test strip mining. We</span>
<span class="comment">        * might as well test all we can!</span>
<span class="comment">        */</span>
        DSetMemXferPropList xfer;

        xfer.setBuffer (1000, tconv_buf, NULL);
  
        <span class="comment">/* Use chunked storage with compression */</span>
        DSetCreatPropList dscreatplist;

        <span class="keyword">const</span> hsize_t   chunk_size[2] = {2, 25};
        dscreatplist.setChunk (2, chunk_size);
        dscreatplist.setDeflate (6);
  
        DataSet* dataset;

<span class="preprocessor">#ifdef H5_HAVE_FILTER_DEFLATE</span>
<span class="preprocessor"></span>    TESTING(<span class="stringliteral">"compression (setup)"</span>);
    
        <span class="comment">/* Create the dataset */</span>
        dataset = <span class="keyword">new</span> DataSet (file.createDataSet 
            (DSET_COMPRESS_NAME, PredType::NATIVE_INT, space1, dscreatplist));
  
    PASSED();

        <span class="comment">/*----------------------------------------------------------------------</span>
<span class="comment">        * STEP 1: Read uninitialized data.  It should be zero.</span>
<span class="comment">        *---------------------------------------------------------------------- </span>
<span class="comment">        */</span>
        TESTING(<span class="stringliteral">"compression (uninitialized read)"</span>);
  
        dataset-&gt;read ((<span class="keywordtype">void</span>*) check, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);
    
        <span class="keywordflow">for</span> (i=0; i&lt;size[0]; i++) {
            <span class="keywordflow">for</span> (j=0; j&lt;size[1]; j++) {
                <span class="keywordflow">if</span> (0!=check[i][j]) {
                    H5_FAILED();
                    cout &lt;&lt; <span class="stringliteral">"    Read a non-zero value."</span> &lt;&lt; endl;
                    cout &lt;&lt; <span class="stringliteral">"    At index "</span> &lt;&lt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)i &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; 
                   (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)j &lt;&lt; endl;
                    <span class="keywordflow">goto</span> error;
                }
            }
        }
    PASSED();

        <span class="comment">/*----------------------------------------------------------------------</span>
<span class="comment">        * STEP 2: Test compression by setting up a chunked dataset and writing</span>
<span class="comment">        * to it.</span>
<span class="comment">        *---------------------------------------------------------------------- </span>
<span class="comment">        */</span>
        TESTING(<span class="stringliteral">"compression (write)"</span>);
    
        <span class="keywordflow">for</span> (i=n=0; i&lt;size[0]; i++)
        {
            <span class="keywordflow">for</span> (j=0; j&lt;size[1]; j++) 
            {
                points[i][j] = n++;
            }
        }

        dataset-&gt;write ((<span class="keywordtype">void</span>*) points, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);

    PASSED();

        <span class="comment">/*----------------------------------------------------------------------</span>
<span class="comment">        * STEP 3: Try to read the data we just wrote.</span>
<span class="comment">        *---------------------------------------------------------------------- </span>
<span class="comment">        */</span>
        TESTING(<span class="stringliteral">"compression (read)"</span>);

        <span class="comment">/* Read the dataset back */</span>
        dataset-&gt;read ((<span class="keywordtype">void</span>*)check, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);

        <span class="comment">/* Check that the values read are the same as the values written */</span>
        <span class="keywordflow">for</span> (i = 0; i &lt; size[0]; i++)
            <span class="keywordflow">for</span> (j = 0; j &lt; size[1]; j++)
            {
                <span class="keywordtype">int</span> status = check_values (i, j, points[i][j], check[i][j]);
                <span class="keywordflow">if</span> (status == -1) <span class="keywordflow">goto</span> error;
            }

    PASSED();

        <span class="comment">/*----------------------------------------------------------------------</span>
<span class="comment">        * STEP 4: Write new data over the top of the old data.  The new data is</span>
<span class="comment">        * random thus not very compressible, and will cause the chunks to move</span>
<span class="comment">        * around as they grow.  We only change values for the left half of the</span>
<span class="comment">        * dataset although we rewrite the whole thing.</span>
<span class="comment">        *---------------------------------------------------------------------- </span>
<span class="comment">        */</span>
        TESTING(<span class="stringliteral">"compression (modify)"</span>);
    
        <span class="keywordflow">for</span> (i=0; i&lt;size[0]; i++)
        {
            <span class="keywordflow">for</span> (j=0; j&lt;size[1]/2; j++) 
            {
                points[i][j] = rand ();
            }
        }
        dataset-&gt;write ((<span class="keywordtype">void</span>*)points, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);

        <span class="comment">/* Read the dataset back and check it */</span>
        dataset-&gt;read ((<span class="keywordtype">void</span>*)check, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);

        <span class="comment">/* Check that the values read are the same as the values written */</span>
        <span class="keywordflow">for</span> (i = 0; i &lt; size[0]; i++)
            <span class="keywordflow">for</span> (j = 0; j &lt; size[1]; j++)
            {
                <span class="keywordtype">int</span> status = check_values (i, j, points[i][j], check[i][j]);
                <span class="keywordflow">if</span> (status == -1) <span class="keywordflow">goto</span> error;
            }

    PASSED();

        <span class="comment">/*----------------------------------------------------------------------</span>
<span class="comment">        * STEP 5: Close the dataset and then open it and read it again.  This</span>
<span class="comment">        * insures that the compression message is picked up properly from the</span>
<span class="comment">        * object header.</span>
<span class="comment">        *---------------------------------------------------------------------- </span>
<span class="comment">        */</span>
        TESTING(<span class="stringliteral">"compression (re-open)"</span>);
    
        <span class="keyword">delete</span> dataset;
    
        dataset = <span class="keyword">new</span> DataSet (file.openDataSet (DSET_COMPRESS_NAME));
        dataset-&gt;read ((<span class="keywordtype">void</span>*)check, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);

        <span class="comment">/* Check that the values read are the same as the values written */</span>
        <span class="keywordflow">for</span> (i = 0; i &lt; size[0]; i++)
            <span class="keywordflow">for</span> (j = 0; j &lt; size[1]; j++)
            {
                <span class="keywordtype">int</span> status = check_values (i, j, points[i][j], check[i][j]);
                <span class="keywordflow">if</span> (status == -1) <span class="keywordflow">goto</span> error;
            }

    PASSED();
    

        <span class="comment">/*----------------------------------------------------------------------</span>
<span class="comment">        * STEP 6: Test partial I/O by writing to and then reading from a</span>
<span class="comment">        * hyperslab of the dataset.  The hyperslab does not line up on chunk</span>
<span class="comment">        * boundaries (we know that case already works from above tests).</span>
<span class="comment">        *---------------------------------------------------------------------- </span>
<span class="comment">        */</span>
        TESTING(<span class="stringliteral">"compression (partial I/O)"</span>);

        <span class="keyword">const</span> hsize_t   hs_size[2] = {4, 50};
        <span class="keyword">const</span> hssize_t  hs_offset[2] = {7, 30};
        <span class="keywordflow">for</span> (i = 0; i &lt; hs_size[0]; i++) {
            <span class="keywordflow">for</span> (j = 0; j &lt; hs_size[1]; j++) {
                points[hs_offset[0]+i][hs_offset[1]+j] = rand ();
            }
        }
        space1.selectHyperslab( H5S_SELECT_SET, hs_size, hs_offset );
        dataset-&gt;write ((<span class="keywordtype">void</span>*)points, PredType::NATIVE_INT, space1, space1, xfer);
        dataset-&gt;read ((<span class="keywordtype">void</span>*)check, PredType::NATIVE_INT, space1, space1, xfer);
    
        <span class="comment">/* Check that the values read are the same as the values written */</span>
        <span class="keywordflow">for</span> (i=0; i&lt;hs_size[0]; i++) {
        <span class="keywordflow">for</span> (j=0; j&lt;hs_size[1]; j++) {
            <span class="keywordflow">if</span> (points[hs_offset[0]+i][hs_offset[1]+j] !=
                check[hs_offset[0]+i][hs_offset[1]+j]) {
                H5_FAILED();
                cout &lt;&lt; <span class="stringliteral">"    Read different values than written.\n"</span> &lt;&lt; endl;
                cout &lt;&lt; <span class="stringliteral">"    At index "</span> &lt;&lt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(hs_offset[0]+i) &lt;&lt; 
                   <span class="stringliteral">","</span> &lt;&lt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(hs_offset[1]+j) &lt;&lt; endl;
                
                cout &lt;&lt; <span class="stringliteral">"    At original: "</span> &lt;&lt; (<span class="keywordtype">int</span>)points[hs_offset[0]+i][hs_offset[1]+j] &lt;&lt; endl;
                cout &lt;&lt; <span class="stringliteral">"    At returned: "</span> &lt;&lt; (<span class="keywordtype">int</span>)check[hs_offset[0]+i][hs_offset[1]+j] &lt;&lt; endl;
                <span class="keywordflow">goto</span> error;
            }
        }
        }

        <span class="keyword">delete</span> dataset;

    PASSED();

<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    TESTING(<span class="stringliteral">"deflate filter"</span>);
    SKIPPED();
    cout &lt;&lt; not_supported &lt;&lt; endl;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
        <span class="comment">/*----------------------------------------------------------------------</span>
<span class="comment">        * STEP 7: Register an application-defined compression method and use it</span>
<span class="comment">        * to write and then read the dataset.</span>
<span class="comment">        *---------------------------------------------------------------------- </span>
<span class="comment">        */</span>
        TESTING(<span class="stringliteral">"compression (app-defined method)"</span>);

<span class="preprocessor">#ifdef H5_WANT_H5_V1_4_COMPAT</span>
<span class="preprocessor"></span>        <span class="keywordflow">if</span> (H5Zregister (H5Z_FILTER_BOGUS, <span class="stringliteral">"bogus"</span>, bogus)&lt;0) <span class="keywordflow">goto</span> error;
<span class="preprocessor">#else </span><span class="comment">/* H5_WANT_H5_V1_4_COMPAT */</span>
        <span class="keywordflow">if</span> (H5Zregister (H5Z_BOGUS)&lt;0) <span class="keywordflow">goto</span> error;
<span class="preprocessor">#endif </span><span class="comment">/* H5_WANT_H5_V1_4_COMPAT */</span>
        <span class="keywordflow">if</span> (H5Pset_filter (dscreatplist.getId(), H5Z_FILTER_BOGUS, 0, 0, NULL)&lt;0) <span class="keywordflow">goto</span> error;
        dscreatplist.setFilter (H5Z_FILTER_BOGUS, 0, 0, NULL);

        DataSpace space2 (2, size, NULL);
        dataset = <span class="keyword">new</span> DataSet (file.createDataSet (DSET_BOGUS_NAME, PredType::NATIVE_INT, space2, dscreatplist));

        dataset-&gt;write ((<span class="keywordtype">void</span>*)points, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);
        dataset-&gt;read ((<span class="keywordtype">void</span>*)check, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);
    
        <span class="comment">/* Check that the values read are the same as the values written */</span>
        <span class="keywordflow">for</span> (i = 0; i &lt; size[0]; i++)
            <span class="keywordflow">for</span> (j = 0; j &lt; size[1]; j++)
            {
                <span class="keywordtype">int</span> status = check_values (i, j, points[i][j], check[i][j]);
                <span class="keywordflow">if</span> (status == -1) 
                    <span class="keywordflow">goto</span> error;
            }

        PASSED();
  
        <span class="comment">/*----------------------------------------------------------------------</span>
<span class="comment">        * Cleanup</span>
<span class="comment">        *---------------------------------------------------------------------- </span>
<span class="comment">        */</span>
        <span class="keyword">delete</span> dataset;
        <span class="keyword">delete</span> [] tconv_buf;
        <span class="keywordflow">return</span> 0;
    } <span class="comment">// end try</span>

    <span class="comment">// catch all dataset, file, space, and plist exceptions</span>
    <span class="keywordflow">catch</span> (Exception E) { <span class="keywordflow">goto</span> error; }
   
  error:
    <span class="comment">// cleaning up</span>
    <span class="keywordflow">if</span> (tconv_buf)
        <span class="keyword">delete</span> [] tconv_buf;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/*-------------------------------------------------------------------------</span>
<span class="comment"> * Function:    test_multiopen</span>
<span class="comment"> *</span>
<span class="comment"> * Purpose:     Tests that a bug no longer exists.  If a dataset is opened</span>
<span class="comment"> *              twice and one of the handles is used to extend the dataset,</span>
<span class="comment"> *              then the other handle should return the new size when</span>
<span class="comment"> *              queried.</span>
<span class="comment"> *</span>
<span class="comment"> * Return:      Success:        0</span>
<span class="comment"> *</span>
<span class="comment"> *              Failure:        -1</span>
<span class="comment"> *</span>
<span class="comment"> * Programmer:  Binh-Minh Ribler (using C version)</span>
<span class="comment"> *              Saturday, February 17, 2001</span>
<span class="comment"> *</span>
<span class="comment"> * Modifications:</span>
<span class="comment"> *</span>
<span class="comment"> *-------------------------------------------------------------------------</span>
<span class="comment"> */</span>
<span class="keyword">static</span> herr_t
test_multiopen (H5File&amp; file)
{

    TESTING(<span class="stringliteral">"multi-open with extending"</span>);
    <span class="keywordflow">try</span> {

        <span class="comment">// Create a dataset creation property list</span>
        DSetCreatPropList dcpl;

        <span class="comment">// Set chunk size to given size</span>
        hsize_t         cur_size[1] = {10};
        dcpl.setChunk (1, cur_size);

        <span class="comment">// Create a simple data space with unlimited size</span>
        <span class="keyword">static</span> hsize_t  max_size[1] = {H5S_UNLIMITED};
        DataSpace* space = <span class="keyword">new</span> DataSpace (1, cur_size, max_size);

        <span class="comment">// Create first dataset</span>
        DataSet dset1 = file.createDataSet (<span class="stringliteral">"multiopen"</span>, PredType::NATIVE_INT, *space, dcpl);
    
        <span class="comment">// Open again the first dataset from the file to another DataSet object.</span>
        DataSet dset2 = file.openDataSet (<span class="stringliteral">"multiopen"</span>);

        <span class="comment">// Relieve the dataspace</span>
        <span class="keyword">delete</span> space;

        <span class="comment">// Extend the dimensionality of the first dataset</span>
        cur_size[0] = 20;
        dset1.extend (cur_size);

        <span class="comment">/* Get the size from the second handle */</span>
        space = <span class="keyword">new</span> DataSpace (dset2.getSpace());

        hsize_t         tmp_size[1];
        space-&gt;getSimpleExtentDims (tmp_size);
        <span class="keywordflow">if</span> (cur_size[0]!=tmp_size[0]) 
        {
            H5_FAILED();
            cout &lt;&lt; <span class="stringliteral">"    Got "</span> &lt;&lt; (<span class="keywordtype">int</span>)tmp_size[0] &lt;&lt; <span class="stringliteral">" instead of "</span> 
                    &lt;&lt; (<span class="keywordtype">int</span>)cur_size[0] &lt;&lt; <span class="stringliteral">"!"</span> &lt;&lt; endl;
            <span class="keyword">delete</span> space;
            <span class="keywordflow">goto</span> error;
        }
    
        <span class="keyword">delete</span> space;
        PASSED();
        <span class="keywordflow">return</span> 0;
    } <span class="comment">// end try block</span>

    <span class="comment">// catch all dataset, file, space, and plist exceptions</span>
    <span class="keywordflow">catch</span> (Exception E)
    { <span class="keywordflow">goto</span> error; }

 error:
    <span class="keywordflow">return</span> -1;
}


<span class="comment">/*-------------------------------------------------------------------------</span>
<span class="comment"> * Function:    test_types</span>
<span class="comment"> *</span>
<span class="comment"> * Purpose:     Test various types - should be moved to dtypes.cpp</span>
<span class="comment"> *</span>
<span class="comment"> * Return:      Success:        0</span>
<span class="comment"> *</span>
<span class="comment"> *              Failure:        -1</span>
<span class="comment"> *</span>
<span class="comment"> * Programmer:  Binh-Minh Ribler (using C version)</span>
<span class="comment"> *              February 17, 2001</span>
<span class="comment"> *</span>
<span class="comment"> * Modifications:</span>
<span class="comment"> *</span>
<span class="comment"> *-------------------------------------------------------------------------</span>
<span class="comment"> */</span>
<span class="keyword">static</span> herr_t
test_types(H5File&amp; file)
{
    size_t              i;

    TESTING(<span class="stringliteral">"various datatypes"</span>);
    <span class="keywordflow">try</span> {

        <span class="comment">// Create a group in the file that was passed in from the caller</span>
        Group grp = file.createGroup (<span class="stringliteral">"typetests"</span>);

        <span class="comment">/* bitfield_1 */</span>
        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>   buf[32];
        hsize_t nelmts = <span class="keyword">sizeof</span>(buf);
        DataType type;
        <span class="keywordflow">try</span> { <span class="comment">// block of bitfield_1</span>
            <span class="comment">// test copying a predefined type</span>
            type.copy (PredType::STD_B8LE);

            <span class="comment">// Test copying a user-defined type using DataType::copy</span>
            DataType copied_type;
            copied_type.copy(type);
            <span class="comment">// Test copying a user-defined type using DataType::operator=</span>
            DataType another_copied_type;
            another_copied_type = type;

            <span class="comment">// Test copying a user-defined int type using DataType::operator=</span>
            IntType orig_int(PredType::STD_B8LE);
            DataType generic_type;
            generic_type = orig_int;

            <span class="comment">// Test copying an integer predefined type</span>
            IntType new_int_type(PredType::STD_B8LE);

            <span class="comment">// Test copying an int predefined type using DataType::operator=</span>
            IntType another_int_type;
            another_int_type = new_int_type;

            DataSpace space (1, &amp;nelmts);
            DataSet* dset = <span class="keyword">new</span> DataSet(grp.createDataSet(<span class="stringliteral">"bitfield_1"</span>, type, space));

            <span class="comment">// Fill buffer</span>
            <span class="keywordflow">for</span> (i=0; i&lt;<span class="keyword">sizeof</span> buf; i++) 
                buf[i] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)0xff ^ (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)i;

            <span class="comment">// Write data from buf using all default dataspaces and property </span>
            <span class="comment">// list; if writing fails, deallocate dset and return.</span>
            <span class="keywordflow">try</span> { dset-&gt;write (buf, type); }
            <span class="keywordflow">catch</span>(DataSetIException E) 
            {
                <span class="keyword">delete</span> dset;
                <span class="keywordflow">goto</span> error;
            }
            <span class="keyword">delete</span> dset;

        } <span class="comment">// end try block of bitfield_1</span>

        <span class="comment">// catch exceptions thrown in try block of bitfield_1</span>
        <span class="keywordflow">catch</span> (Exception E) { 
            cout &lt;&lt; <span class="stringliteral">"Failure in "</span> &lt;&lt; E.getFuncName() &lt;&lt; <span class="stringliteral">" - "</span> 
                 &lt;&lt; E.getDetailMsg() &lt;&lt; endl;
            <span class="keywordflow">goto</span> error;
        }

        <span class="comment">/* bitfield_2 */</span>
        nelmts = <span class="keyword">sizeof</span>(buf)/2;
        <span class="keywordflow">try</span> { <span class="comment">// bitfield_2 block</span>
            type.copy (PredType::STD_B16LE);
            DataSpace space (1, &amp;nelmts);
            DataSet* dset = <span class="keyword">new</span> DataSet(grp.createDataSet(<span class="stringliteral">"bitfield_2"</span>, type, space));

            <span class="comment">// Fill buffer</span>
            <span class="keywordflow">for</span> (i=0; i&lt;<span class="keyword">sizeof</span>(buf); i++) 
                buf[i] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)0xff ^ (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)i;

            <span class="comment">// Write data from buf using all default dataspaces and property </span>
            <span class="comment">// list; if writing fails, deallocate dset and return.</span>
            <span class="keywordflow">try</span> { dset-&gt;write (buf, type); }
            <span class="keywordflow">catch</span>(DataSetIException E) 
            {
                cout &lt;&lt; <span class="stringliteral">"Failure in "</span> &lt;&lt; E.getFuncName() &lt;&lt; <span class="stringliteral">" - "</span> 
                 &lt;&lt; E.getDetailMsg() &lt;&lt; endl;
                <span class="keyword">delete</span> dset;
                <span class="keywordflow">goto</span> error;
            }
            <span class="keyword">delete</span> dset;
        } <span class="comment">// end try block of bitfield_2</span>

        <span class="comment">// catch exceptions thrown in try block of bitfield_2</span>
        <span class="keywordflow">catch</span> (Exception E) {
            cout &lt;&lt; <span class="stringliteral">"Failure in "</span> &lt;&lt; E.getFuncName() &lt;&lt; <span class="stringliteral">" - "</span> 
                 &lt;&lt; E.getDetailMsg() &lt;&lt; endl;
            <span class="keywordflow">goto</span> error;
        }

        <span class="comment">/* opaque_1 */</span>
        DataType* optype = <span class="keyword">new</span> DataType(H5T_OPAQUE, 1);
        <span class="keywordflow">try</span> { <span class="comment">// opaque_1 block</span>
            nelmts = <span class="keyword">sizeof</span>(buf);
            DataSpace space (1, &amp;nelmts);
            optype-&gt;setTag (<span class="stringliteral">"testing 1-byte opaque type"</span>);
            DataSet* dset = <span class="keyword">new</span> DataSet(grp.createDataSet(<span class="stringliteral">"opaque_1"</span>, *optype, space));

            <span class="comment">// Fill buffer</span>
            <span class="keywordflow">for</span> (i=0; i&lt;<span class="keyword">sizeof</span> buf; i++) 
                buf[i] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)0xff ^ (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)i;

            <span class="comment">// Write data from buf using all default dataspaces and property </span>
            <span class="comment">// list; if writing fails, deallocate dset and return.</span>
            <span class="keywordflow">try</span> { dset-&gt;write (buf, *optype); }
            <span class="keywordflow">catch</span>(DataSetIException E) 
            {
                <span class="keyword">delete</span> dset;
                <span class="keywordflow">goto</span> error;
            }
            <span class="keyword">delete</span> dset;
            <span class="keyword">delete</span> optype;
        } <span class="comment">// end try block of opaque_1</span>

        <span class="comment">// catch exceptions thrown in try block of opaque_1</span>
        <span class="keywordflow">catch</span> (DataSetIException E) { 
            <span class="keyword">delete</span> optype;
            cout &lt;&lt; <span class="stringliteral">"Failure in "</span> &lt;&lt; E.getFuncName() &lt;&lt; <span class="stringliteral">" - "</span> 
                 &lt;&lt; E.getDetailMsg() &lt;&lt; endl;
            <span class="keywordflow">goto</span> error;
        }
        <span class="keywordflow">catch</span> (Exception E) {
            cout &lt;&lt; <span class="stringliteral">"Failure in "</span> &lt;&lt; E.getFuncName() &lt;&lt; <span class="stringliteral">" - "</span> 
                 &lt;&lt; E.getDetailMsg() &lt;&lt; endl;
            <span class="keywordflow">goto</span> error;
        }
    
        <span class="comment">/* opaque_2 */</span>
        <span class="keywordflow">try</span> { <span class="comment">// block opaque_2</span>
            nelmts = <span class="keyword">sizeof</span>(buf)/4;
            DataSpace space (1, &amp;nelmts);
            optype = <span class="keyword">new</span> DataType(H5T_OPAQUE, 4);
            optype-&gt;setTag (<span class="stringliteral">"testing 4-byte opaque type"</span>);
            DataSet* dset = <span class="keyword">new</span> DataSet(grp.createDataSet(<span class="stringliteral">"opaque_2"</span>, *optype, space));

            <span class="comment">// Fill buffer</span>
            <span class="keywordflow">for</span> (i=0; i&lt;<span class="keyword">sizeof</span>(buf); i++) 
                buf[i] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)0xff ^ (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)i;

            <span class="comment">// Write data from buf using all default dataspaces and property </span>
            <span class="comment">// list; if writing fails, deallocate dset and return.</span>
            <span class="keywordflow">try</span> { dset-&gt;write (buf, *optype); }
            <span class="keywordflow">catch</span>(DataSetIException E) 
            {
                <span class="keyword">delete</span> dset;
                <span class="keywordflow">goto</span> error;
            }
            <span class="keyword">delete</span> dset;
            <span class="keyword">delete</span> optype;
        } <span class="comment">//end try block of opaque_2</span>
        <span class="keywordflow">catch</span> (DataSetIException E) { 
            <span class="keyword">delete</span> optype;
            cout &lt;&lt; <span class="stringliteral">"Failure in "</span> &lt;&lt; E.getFuncName() &lt;&lt; <span class="stringliteral">" - "</span> 
                 &lt;&lt; E.getDetailMsg() &lt;&lt; endl;
            <span class="keywordflow">goto</span> error;
        }
        <span class="keywordflow">catch</span> (Exception E) {
            cout &lt;&lt; <span class="stringliteral">"Failure in "</span> &lt;&lt; E.getFuncName() &lt;&lt; <span class="stringliteral">" - "</span> 
                 &lt;&lt; E.getDetailMsg() &lt;&lt; endl;
            <span class="keywordflow">goto</span> error;
        }
    
    PASSED();
    <span class="keywordflow">return</span> 0;
    } <span class="comment">// end top try block</span>

    <span class="keywordflow">catch</span> (Exception E) { <span class="comment">// Group and DataType exceptions</span>
            cout &lt;&lt; <span class="stringliteral">"Failure in "</span> &lt;&lt; E.getFuncName() &lt;&lt; <span class="stringliteral">" - "</span> 
                 &lt;&lt; E.getDetailMsg() &lt;&lt; endl;
            <span class="keywordflow">goto</span> error;
    }

 error:
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/*-------------------------------------------------------------------------</span>
<span class="comment"> * Function:    main</span>
<span class="comment"> *</span>
<span class="comment"> * Purpose:     Tests the dataset interface (H5D)</span>
<span class="comment"> *</span>
<span class="comment"> * Return:      Success:        exit(0)</span>
<span class="comment"> *</span>
<span class="comment"> *              Failure:        exit(1)</span>
<span class="comment"> *</span>
<span class="comment"> * Programmer:  Binh-Minh Ribler (using C version)</span>
<span class="comment"> *              Friday, January 5, 2001</span>
<span class="comment"> *</span>
<span class="comment"> * Modifications:</span>
<span class="comment"> *      Nov 12, 01:</span>
<span class="comment"> *              - moved h5_cleanup to outside of try block because</span>
<span class="comment"> *                dataset.h5 cannot be removed until "file" is out of</span>
<span class="comment"> *                scope and dataset.h5 is closed. </span>
<span class="comment"> *</span>
<span class="comment"> *-------------------------------------------------------------------------</span>
<span class="comment"> */</span>
<span class="keywordtype">int</span>
main(<span class="keywordtype">void</span>)
{
    h5_reset(); <span class="comment">// in h5test.c, resets the library by closing it</span>

    hid_t       fapl_id;
    fapl_id = h5_fileaccess(); <span class="comment">// in h5test.c, returns a file access template</span>
    
    <span class="keywordtype">char</span>        filename[1024];
    h5_fixname(FILENAME[0], fapl_id, filename, <span class="keyword">sizeof</span> filename);

    <span class="keywordtype">int</span>         nerrors=0;      <span class="comment">// keep track of number of failures occurr</span>
    <span class="keywordflow">try</span> 
    {
        <span class="comment">// Turn of the auto-printing when failure occurs so that we can </span>
        <span class="comment">// handle the errors appropriately since sometime failures are</span>
        <span class="comment">// caused deliberately and expected.</span>
        Exception::dontPrint();

        <span class="comment">// Use the file access template id to create a file access prop.</span>
        <span class="comment">// list object to pass in H5File::H5File</span>
        FileAccPropList fapl(fapl_id);

        H5File file( filename, H5F_ACC_TRUNC, FileCreatPropList::DEFAULT, fapl);
       
        <span class="comment">/* Cause the library to emit initial messages */</span>
        Group grp = file.createGroup( <span class="stringliteral">"emit diagnostics"</span>, 0);
        grp.setComment( <span class="stringliteral">"."</span>, <span class="stringliteral">"Causes diagnostic messages to be emitted"</span>);

        nerrors += test_create(file)&lt;0  ?1:0;
        nerrors += test_simple_io(file)&lt;0       ?1:0;
        nerrors += test_tconv(file)&lt;0   ?1:0;
        nerrors += test_compression(file)&lt;0     ?1:0;
        nerrors += test_multiopen (file)&lt;0      ?1:0;
        nerrors += test_types(file)&lt;0       ?1:0;

        <span class="comment">// increment the ref count of this property list so that the </span>
        <span class="comment">// property list id won't be closed when fapl goes out of scope.</span>
        <span class="comment">// This is a bad hack, but I want to use existing routine h5_cleanup!</span>
        fapl.incRefCount();
    }
    <span class="keywordflow">catch</span> (Exception E) 
    {
        <span class="keywordflow">return</span>(test_report(nerrors, string(<span class="stringliteral">" Dataset"</span>)));
    }
    <span class="comment">/* use C test utility routine to clean up data files */</span>
    h5_cleanup(FILENAME, fapl_id);

    <span class="comment">/* print out dsets test results */</span>
    cerr &lt;&lt; endl &lt;&lt; endl;
    <span class="keywordflow">return</span>(test_report(nerrors, string(<span class="stringliteral">" Dataset"</span>)));
}
</div></pre><pre><div class="fragment">00001 <span class="comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *</span>
00002 <span class="comment">  * Copyright by the Board of Trustees of the University of Illinois.         *</span>
00003 <span class="comment">  * All rights reserved.                                                      *</span>
00004 <span class="comment">  *                                                                           *</span>
00005 <span class="comment">  * This file is part of HDF5.  The full HDF5 copyright notice, including     *</span>
00006 <span class="comment">  * terms governing use, modification, and redistribution, is contained in    *</span>
00007 <span class="comment">  * the files COPYING and Copyright.html.  COPYING can be found at the root   *</span>
00008 <span class="comment">  * of the source code distribution tree; Copyright.html can be found at the  *</span>
00009 <span class="comment">  * root level of an installed copy of the electronic HDF5 document set and   *</span>
00010 <span class="comment">  * is linked from the top-level documents page.  It can also be found at     *</span>
00011 <span class="comment">  * http://hdf.ncsa.uiuc.edu/HDF5/doc/Copyright.html.  If you do not have     *</span>
00012 <span class="comment">  * access to either file, you may request a copy from hdfhelp@ncsa.uiuc.edu. *</span>
00013 <span class="comment">  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>
00014 
00015 <span class="comment">/*****************************************************************************</span>
00016 <span class="comment">   FILE</span>
00017 <span class="comment">   dsets.cpp - HDF5 C++ testing the functionalities associated with the</span>
00018 <span class="comment">        C dataset interface (H5D)</span>
00019 <span class="comment"></span>
00020 <span class="comment">   EXTERNAL ROUTINES/VARIABLES:</span>
00021 <span class="comment">     These routines are in the test directory of the C library:</span>
00022 <span class="comment">        h5_reset() -- in h5test.c, resets the library by closing it</span>
00023 <span class="comment">        h5_fileaccess() -- in h5test.c, returns a file access template</span>
00024 <span class="comment">        h5_fixname() -- in h5test.c, create a file name from a file base name</span>
00025 <span class="comment">        h5_cleanup() -- in h5test.c, cleanup temporary test files</span>
00026 <span class="comment"></span>
00027 <span class="comment"> ***************************************************************************/</span>
00028 
00029 <span class="preprocessor">#ifdef OLD_HEADER_FILENAME</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#include &lt;iostream.h&gt;</span>
00031 <span class="preprocessor">#else</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#include &lt;iostream&gt;</span>
00033 <span class="preprocessor">#endif</span>
00034 <span class="preprocessor"></span>
00035 <span class="preprocessor">#include "<a class="code" href="H5Cpp_8h.html">H5Cpp.h</a>"</span>
00036 <span class="preprocessor">#include "h5test.h"</span>
00037 <span class="preprocessor">#include "testhdf5.h"</span>
00038 
00039 <span class="preprocessor">#ifndef H5_NO_NAMESPACE</span>
00040 <span class="preprocessor"></span><span class="keyword">using</span> <span class="keyword">namespace </span>H5;
00041 <span class="preprocessor">#endif</span>
00042 <span class="preprocessor"></span>
00043 <span class="preprocessor">#include "h5cpputil.h"</span>
00044 
00045 <span class="keyword">const</span> <span class="keywordtype">char</span> *FILENAME[] = {
00046     <span class="stringliteral">"dataset"</span>,
00047     NULL
00048 };
00049 
00050 <span class="preprocessor">#define DSET_DEFAULT_NAME       "default"</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#define DSET_CHUNKED_NAME       "chunked"</span>
00052 <span class="preprocessor"></span><span class="preprocessor">#define DSET_SIMPLE_IO_NAME     "simple_io"</span>
00053 <span class="preprocessor"></span><span class="preprocessor">#define DSET_TCONV_NAME         "tconv"</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#define DSET_COMPRESS_NAME      "compressed"</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#define DSET_BOGUS_NAME         "bogus"</span>
00056 <span class="preprocessor"></span>
00057 <span class="preprocessor">#define H5Z_FILTER_BOGUS                305</span>
00058 <span class="preprocessor"></span>
00059 <span class="comment">/* Local prototypes for filter functions */</span>
00060 <span class="keyword">static</span> size_t bogus(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags, size_t cd_nelmts, 
00061     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *cd_values, size_t nbytes, size_t *buf_size, <span class="keywordtype">void</span> **buf);
00062 
00063 
00064 <span class="comment">/*-------------------------------------------------------------------------</span>
00065 <span class="comment"> * Function:    test_create</span>
00066 <span class="comment"> *</span>
00067 <span class="comment"> * Purpose:     Attempts to create a dataset.</span>
00068 <span class="comment"> *</span>
00069 <span class="comment"> * Return:      Success:        0</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> *              Failure:        -1</span>
00072 <span class="comment"> *</span>
00073 <span class="comment"> * Programmer:  Binh-Minh Ribler (using C version)</span>
00074 <span class="comment"> *              Friday, January 5, 2001</span>
00075 <span class="comment"> *</span>
00076 <span class="comment"> * Modifications:</span>
00077 <span class="comment"> *</span>
00078 <span class="comment"> *-------------------------------------------------------------------------</span>
00079 <span class="comment"> */</span>
00080 <span class="keyword">static</span> herr_t
00081 test_create( H5File&amp; file)
00082 {
00083    TESTING(<span class="stringliteral">"create, open, close"</span>);
00084 
00085     <span class="keywordflow">try</span> {
00086         <span class="comment">/* Create the data space */</span>
00087         hsize_t     dims[2];
00088         dims[0] = 256;
00089         dims[1] = 512;
00090         DataSpace space (2, dims, NULL);
00091 
00092         <span class="comment">/*</span>
00093 <span class="comment">        * Create a dataset using the default dataset creation properties.       </span>
00094 <span class="comment">        * We're not sure what they are, so we won't check.</span>
00095 <span class="comment">        */</span>
00096         DataSet *dataset = <span class="keyword">new</span> DataSet (file.createDataSet 
00097                 (DSET_DEFAULT_NAME, PredType::NATIVE_DOUBLE, space));
00098 
00099         <span class="comment">/* Close the dataset */</span>
00100         <span class="keyword">delete</span> dataset;
00101 
00102         <span class="comment">/* Add a comment to the dataset */</span>
00103         file.setComment (DSET_DEFAULT_NAME, <span class="stringliteral">"This is a dataset"</span>);
00104 
00105         <span class="comment">/*</span>
00106 <span class="comment">        * Try creating a dataset that already exists.  This should fail since a</span>
00107 <span class="comment">        * dataset can only be created once.  If an exception is not thrown</span>
00108 <span class="comment">        * for this action by createDataSet, then display failure information</span>
00109 <span class="comment">        * and jump to label error: to return.</span>
00110 <span class="comment">        */</span>
00111         <span class="keywordflow">try</span> {
00112             dataset = <span class="keyword">new</span> DataSet (file.createDataSet 
00113                         (DSET_DEFAULT_NAME, PredType::NATIVE_DOUBLE, space));
00114             <span class="comment">// continuation here, that means no exception has been thrown</span>
00115             H5_FAILED();
00116             cout &lt;&lt; <span class="stringliteral">"    Library allowed overwrite of existing dataset."</span> &lt;&lt; endl;
00117             <span class="keywordflow">goto</span> error;
00118         }
00119         <span class="keywordflow">catch</span> (FileIException E ) <span class="comment">// catching invalid creating dataset</span>
00120         {
00121             <span class="comment">// Exception is expected.  Do nothing here.</span>
00122         }
00123         <span class="comment">/*</span>
00124 <span class="comment">        * Open the dataset we created above and then close it.  This is how</span>
00125 <span class="comment">        * existing datasets are accessed.</span>
00126 <span class="comment">        */</span>
00127         dataset = <span class="keyword">new</span> DataSet (file.openDataSet (DSET_DEFAULT_NAME));
00128         <span class="keyword">delete</span> dataset;
00129     
00130         <span class="comment">/*</span>
00131 <span class="comment">        * Try opening a non-existent dataset.  This should fail so if an</span>
00132 <span class="comment">        * exception is not thrown for this action by openDataSet, then </span>
00133 <span class="comment">        * display failure information and jump to label error: to return.</span>
00134 <span class="comment">        */</span>
00135         <span class="keywordflow">try</span> {
00136             dataset = <span class="keyword">new</span> DataSet (file.openDataSet( <span class="stringliteral">"does_not_exist"</span> ));
00137             <span class="comment">// continuation here, that means no exception has been thrown</span>
00138             H5_FAILED();
00139             cout &lt;&lt; <span class="stringliteral">"    Opened a non-existent dataset."</span> &lt;&lt; endl;
00140             <span class="keywordflow">goto</span> error;
00141         }
00142         <span class="keywordflow">catch</span> (FileIException E ) <span class="comment">// catching creating non-existent dataset</span>
00143         {
00144             <span class="comment">// Exception is expected.  Do nothing here.</span>
00145         }
00146 
00147         <span class="comment">/*</span>
00148 <span class="comment">        * Create a new dataset that uses chunked storage instead of the default</span>
00149 <span class="comment">        * layout.</span>
00150 <span class="comment">        */</span>
00151         DSetCreatPropList create_parms;
00152         hsize_t     csize[2];
00153         csize[0] = 5;
00154         csize[1] = 100;
00155         create_parms.setChunk( 2, csize );
00156 
00157         dataset = <span class="keyword">new</span> DataSet (file.createDataSet 
00158                 (DSET_CHUNKED_NAME, PredType::NATIVE_DOUBLE, space, create_parms));
00159         <span class="comment">// Note: this one has no error message in C when failure occurs?</span>
00160 
00161         <span class="comment">/*</span>
00162 <span class="comment">        * Close the chunked dataset.</span>
00163 <span class="comment">        */</span>
00164         <span class="keyword">delete</span> dataset;
00165 
00166         PASSED();
00167         <span class="keywordflow">return</span> 0;
00168    }    <span class="comment">// outer most try block</span>
00169 
00170    <span class="comment">// catch all dataset, file, space, plist exceptions</span>
00171    <span class="keywordflow">catch</span> (Exception E) { <span class="keywordflow">goto</span> error; }
00172    
00173  error:
00174     <span class="keywordflow">return</span> -1;
00175 }
00176 
00177 <span class="comment">/*-------------------------------------------------------------------------</span>
00178 <span class="comment"> * Function:    check_values</span>
00179 <span class="comment"> *</span>
00180 <span class="comment"> * Purpose:     Checks a read value against the written value.  If they are </span>
00181 <span class="comment"> *              different, the function will</span>
00182 <span class="comment"> *              print out a message and the different values.  This function</span>
00183 <span class="comment"> *              is made to reuse the code segment that is used in various</span>
00184 <span class="comment"> *              places throughout test_compression and in test_simple_io.  </span>
00185 <span class="comment"> *              Where the C version</span>
00186 <span class="comment"> *              of this code segment "goto error," this function will</span>
00187 <span class="comment"> *              return -1, so that the caller can "goto error."</span>
00188 <span class="comment"> *</span>
00189 <span class="comment"> * Return:      Success:        0</span>
00190 <span class="comment"> *</span>
00191 <span class="comment"> *              Failure:        -1</span>
00192 <span class="comment"> *</span>
00193 <span class="comment"> * Programmer:  Binh-Minh Ribler (using C code segment for checking values)</span>
00194 <span class="comment"> *              Friday, February 6, 2001</span>
00195 <span class="comment"> *</span>
00196 <span class="comment"> * Modifications:</span>
00197 <span class="comment"> *</span>
00198 <span class="comment"> *-------------------------------------------------------------------------</span>
00199 <span class="comment"> */</span>
00200 <span class="keyword">static</span> <span class="keywordtype">int</span> 
00201 check_values (hsize_t i, hsize_t j, <span class="keywordtype">int</span> apoint, <span class="keywordtype">int</span> acheck)
00202 {
00203     <span class="keywordflow">if</span> (apoint != acheck)
00204     {
00205         H5_FAILED();
00206         cout &lt;&lt; <span class="stringliteral">"    Read different values than written.\n"</span> &lt;&lt; endl;
00207         cout &lt;&lt; <span class="stringliteral">"    At index "</span> &lt;&lt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)i &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; 
00208         (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)j &lt;&lt; endl;
00209         <span class="keywordflow">return</span> -1;
00210     }
00211     <span class="keywordflow">return</span> 0;
00212 } <span class="comment">// check_values</span>
00213 
00214 <span class="comment">/*-------------------------------------------------------------------------</span>
00215 <span class="comment"> * Function:    test_simple_io</span>
00216 <span class="comment"> *</span>
00217 <span class="comment"> * Purpose:     Tests simple I/O.  That is, reading and writing a complete</span>
00218 <span class="comment"> *              multi-dimensional array without data type or data space</span>
00219 <span class="comment"> *              conversions, without compression, and stored contiguously.</span>
00220 <span class="comment"> *</span>
00221 <span class="comment"> * Return:      Success:        0</span>
00222 <span class="comment"> *</span>
00223 <span class="comment"> *              Failure:        -1</span>
00224 <span class="comment"> *</span>
00225 <span class="comment"> * Programmer:  Binh-Minh Ribler (using C version)</span>
00226 <span class="comment"> *              Friday, January 5, 2001</span>
00227 <span class="comment"> *</span>
00228 <span class="comment"> * Modifications:</span>
00229 <span class="comment"> *</span>
00230 <span class="comment"> *-------------------------------------------------------------------------</span>
00231 <span class="comment"> */</span>
00232 <span class="keyword">static</span> herr_t
00233 test_simple_io( H5File&amp; file)
00234 {
00235 
00236     TESTING(<span class="stringliteral">"simple I/O"</span>);
00237 
00238     <span class="keywordtype">int</span> points[100][200];
00239     <span class="keywordtype">int</span> check[100][200];
00240     <span class="keywordtype">int</span>         i, j, n;
00241 
00242     <span class="comment">/* Initialize the dataset */</span>
00243     <span class="keywordflow">for</span> (i = n = 0; i &lt; 100; i++)
00244     {
00245         <span class="keywordflow">for</span> (j = 0; j &lt; 200; j++) {
00246             points[i][j] = n++;
00247         }
00248     }
00249 
00250     <span class="keywordtype">char</span>* tconv_buf = <span class="keyword">new</span> <span class="keywordtype">char</span> [1000];
00251     <span class="keywordflow">try</span> 
00252     {
00253         <span class="comment">/* Create the data space */</span>
00254         hsize_t dims[2];
00255         dims[0] = 100;
00256         dims[1] = 200;
00257         DataSpace space (2, dims, NULL);
00258 
00259         <span class="comment">/* Create a small conversion buffer to test strip mining */</span>
00260         DSetMemXferPropList xfer;
00261 
00262         xfer.setBuffer (1000, tconv_buf, NULL);
00263 
00264         <span class="comment">/* Create the dataset */</span>
00265         DataSet dataset (file.createDataSet (DSET_SIMPLE_IO_NAME, PredType::NATIVE_INT, space));
00266 
00267         <span class="comment">/* Write the data to the dataset */</span>
00268         dataset.write ((<span class="keywordtype">void</span>*) points, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);
00269 
00270         <span class="comment">/* Read the dataset back */</span>
00271         dataset.read ((<span class="keywordtype">void</span>*) check, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);
00272 
00273         <span class="comment">/* Check that the values read are the same as the values written */</span>
00274         <span class="keywordflow">for</span> (i = 0; i &lt; 100; i++)
00275             <span class="keywordflow">for</span> (j = 0; j &lt; 200; j++)
00276             {
00277                 <span class="keywordtype">int</span> status = check_values (i, j, points[i][j], check[i][j]);
00278                 <span class="keywordflow">if</span> (status == -1) <span class="keywordflow">goto</span> error;
00279             }
00280 
00281         <span class="keyword">delete</span> [] tconv_buf;
00282         PASSED();
00283         <span class="keywordflow">return</span> 0;
00284     }  <span class="comment">// end try</span>
00285 
00286     <span class="comment">// catch all dataset, space, plist exceptions</span>
00287     <span class="keywordflow">catch</span> (Exception E) { <span class="keywordflow">goto</span> error; }
00288    
00289   error:
00290     <span class="comment">// cleaning up</span>
00291     <span class="keywordflow">if</span> (tconv_buf)
00292         <span class="keyword">delete</span> [] tconv_buf;
00293     <span class="keywordflow">return</span> -1;
00294 }
00295 
00296 <span class="comment">/*-------------------------------------------------------------------------</span>
00297 <span class="comment"> * Function:    test_tconv</span>
00298 <span class="comment"> *</span>
00299 <span class="comment"> * Purpose:     Test some simple data type conversion stuff.</span>
00300 <span class="comment"> *</span>
00301 <span class="comment"> * Return:      Success:        0</span>
00302 <span class="comment"> *</span>
00303 <span class="comment"> *              Failure:        -1</span>
00304 <span class="comment"> *</span>
00305 <span class="comment"> * Programmer:  Binh-Minh Ribler (using C version)</span>
00306 <span class="comment"> *              Friday, January 5, 2001</span>
00307 <span class="comment"> *</span>
00308 <span class="comment"> * Modifications:</span>
00309 <span class="comment"> *</span>
00310 <span class="comment"> *-------------------------------------------------------------------------</span>
00311 <span class="comment"> */</span>
00312 <span class="keyword">static</span> herr_t
00313 test_tconv( H5File&amp; file)
00314 {
00315     <span class="comment">// Prepare buffers for input/output</span>
00316     <span class="keywordtype">char</span>        *out=NULL, *in=NULL;
00317     out = <span class="keyword">new</span> <span class="keywordtype">char</span> [4*1000000];
00318     <span class="comment">// assert (out); - should use exception handler for new - BMR</span>
00319     in = <span class="keyword">new</span> <span class="keywordtype">char</span> [4*1000000];
00320     <span class="comment">//assert (in);</span>
00321 
00322     TESTING(<span class="stringliteral">"data type conversion"</span>);
00323     
00324     <span class="comment">/* Initialize the dataset */</span>
00325     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000000; i++) {
00326         out[i*4+0] = 0x11;
00327         out[i*4+1] = 0x22;
00328         out[i*4+2] = 0x33;
00329         out[i*4+3] = 0x44;
00330     }
00331 
00332     <span class="keywordflow">try</span>
00333     {
00334         <span class="comment">/* Create the data space */</span>
00335         hsize_t dims[1];
00336         dims[0] = 1000000;
00337         DataSpace space (1, dims, NULL);
00338 
00339         <span class="comment">/* Create the data set */</span>
00340         DataSet dataset (file.createDataSet (DSET_TCONV_NAME, PredType::STD_I32LE, space));
00341 
00342         <span class="comment">/* Write the data to the dataset */</span>
00343         dataset.write ((<span class="keywordtype">void</span>*) out, PredType::STD_I32LE);
00344 
00345         <span class="comment">/* Read data with byte order conversion */</span>
00346         dataset.read ((<span class="keywordtype">void</span>*) in, PredType::STD_I32BE);
00347 
00348         <span class="comment">/* Check */</span>
00349         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000000; i++) {
00350             <span class="keywordflow">if</span> (in[4*i+0]!=out[4*i+3] ||
00351                 in[4*i+1]!=out[4*i+2] ||
00352                 in[4*i+2]!=out[4*i+1] ||
00353                 in[4*i+3]!=out[4*i+0]) 
00354             {
00355                 H5_FAILED();
00356                 cout &lt;&lt; <span class="stringliteral">"    Read with byte order conversion failed."</span> &lt;&lt; endl;
00357                 <span class="keywordflow">goto</span> error;
00358             }
00359         }
00360 
00361         <span class="keyword">delete</span> [] out;
00362         <span class="keyword">delete</span> [] in;
00363         cout &lt;&lt; <span class="stringliteral">" PASSED"</span> &lt;&lt; endl;
00364         <span class="keywordflow">return</span> 0;
00365     }  <span class="comment">// end try</span>
00366 
00367     <span class="comment">// catch all dataset and space exceptions</span>
00368     <span class="keywordflow">catch</span> (Exception E) { <span class="keywordflow">goto</span> error; }
00369    
00370   error:
00371         <span class="keyword">delete</span> [] out;
00372         <span class="keyword">delete</span> [] in;
00373         <span class="keywordflow">return</span> -1;
00374 }
00375 
00376 <span class="comment">/* This message derives from H5Z */</span>
00377 <span class="keyword">const</span> H5Z_class_t H5Z_BOGUS[1] = {{
00378     H5Z_FILTER_BOGUS,           <span class="comment">/* Filter id number             */</span>
00379     <span class="stringliteral">"bogus"</span>,                    <span class="comment">/* Filter name for debugging    */</span>
00380     NULL,                       <span class="comment">/* The "can apply" callback     */</span>
00381     NULL,                       <span class="comment">/* The "set local" callback     */</span>
00382     bogus,                      <span class="comment">/* The actual filter function   */</span>
00383 }};
00384 
00385 <span class="comment">/*-------------------------------------------------------------------------</span>
00386 <span class="comment"> * Function:    bogus</span>
00387 <span class="comment"> *</span>
00388 <span class="comment"> * Purpose:     A bogus compression method that doesn't do anything.</span>
00389 <span class="comment"> *</span>
00390 <span class="comment"> * Return:      Success:        Data chunk size</span>
00391 <span class="comment"> *</span>
00392 <span class="comment"> *              Failure:        0</span>
00393 <span class="comment"> *</span>
00394 <span class="comment"> * Programmer:  Robb Matzke</span>
00395 <span class="comment"> *              Tuesday, April 21, 1998</span>
00396 <span class="comment"> *</span>
00397 <span class="comment"> * Modifications:</span>
00398 <span class="comment"> *</span>
00399 <span class="comment"> *-------------------------------------------------------------------------</span>
00400 <span class="comment"> */</span>
00401 <span class="keyword">static</span> size_t
00402 <span class="comment">/*bogus(unsigned int UNUSED flags, size_t UNUSED cd_nelmts,</span>
00403 <span class="comment">      const unsigned int UNUSED cd_values[], size_t nbytes,</span>
00404 <span class="comment">      size_t UNUSED *buf_size, void UNUSED **buf)</span>
00405 <span class="comment">BMR: removed UNUSED for now until asking Q. or R. to pass compilation*/</span>
00406 bogus(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags, size_t cd_nelmts,
00407       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cd_values[], size_t nbytes,
00408       size_t *buf_size, <span class="keywordtype">void</span> **buf)
00409 {
00410     <span class="keywordflow">return</span> nbytes;
00411 }
00412 
00413 
00414 <span class="comment">/*-------------------------------------------------------------------------</span>
00415 <span class="comment"> * Function:    test_compression</span>
00416 <span class="comment"> *</span>
00417 <span class="comment"> * Purpose:     Tests dataset compression. If compression is requested when</span>
00418 <span class="comment"> *              it hasn't been compiled into the library (such as when</span>
00419 <span class="comment"> *              updating an existing compressed dataset) then data is sent to</span>
00420 <span class="comment"> *              the file uncompressed but no errors are returned.</span>
00421 <span class="comment"> *</span>
00422 <span class="comment"> * Return:      Success:        0</span>
00423 <span class="comment"> *</span>
00424 <span class="comment"> *              Failure:        -1</span>
00425 <span class="comment"> *</span>
00426 <span class="comment"> * Programmer:  Binh-Minh Ribler (using C version)</span>
00427 <span class="comment"> *              Friday, January 5, 2001</span>
00428 <span class="comment"> *</span>
00429 <span class="comment"> * Modifications:</span>
00430 <span class="comment"> *</span>
00431 <span class="comment"> *-------------------------------------------------------------------------</span>
00432 <span class="comment"> */</span>
00433 
00434 <span class="keyword">static</span> herr_t
00435 test_compression(H5File&amp; file)
00436 {
00437     <span class="keyword">const</span> <span class="keywordtype">char</span>          *not_supported;
00438     not_supported = <span class="stringliteral">"    Deflate compression is not enabled."</span>;
00439     <span class="keywordtype">int</span>         points[100][200];
00440     <span class="keywordtype">int</span>         check[100][200];
00441     hsize_t     i, j, n;
00442 
00443     <span class="comment">/* Initialize the dataset */</span>
00444     <span class="keywordflow">for</span> (i = n = 0; i &lt; 100; i++)
00445     {
00446         <span class="keywordflow">for</span> (j = 0; j &lt; 200; j++) {
00447             points[i][j] = n++;
00448         }
00449     }
00450     <span class="keywordtype">char</span>* tconv_buf = <span class="keyword">new</span> <span class="keywordtype">char</span> [1000];
00451 
00452     <span class="keywordflow">try</span> 
00453     {
00454         <span class="keyword">const</span> hsize_t   size[2] = {100, 200};
00455         <span class="comment">/* Create the data space */</span>
00456         DataSpace space1(2, size, NULL);
00457 
00458         <span class="comment">/*</span>
00459 <span class="comment">        * Create a small conversion buffer to test strip mining. We</span>
00460 <span class="comment">        * might as well test all we can!</span>
00461 <span class="comment">        */</span>
00462         DSetMemXferPropList xfer;
00463 
00464         xfer.setBuffer (1000, tconv_buf, NULL);
00465   
00466         <span class="comment">/* Use chunked storage with compression */</span>
00467         DSetCreatPropList dscreatplist;
00468 
00469         <span class="keyword">const</span> hsize_t   chunk_size[2] = {2, 25};
00470         dscreatplist.setChunk (2, chunk_size);
00471         dscreatplist.setDeflate (6);
00472   
00473         DataSet* dataset;
00474 
00475 <span class="preprocessor">#ifdef H5_HAVE_FILTER_DEFLATE</span>
00476 <span class="preprocessor"></span>    TESTING(<span class="stringliteral">"compression (setup)"</span>);
00477     
00478         <span class="comment">/* Create the dataset */</span>
00479         dataset = <span class="keyword">new</span> DataSet (file.createDataSet 
00480             (DSET_COMPRESS_NAME, PredType::NATIVE_INT, space1, dscreatplist));
00481   
00482     PASSED();
00483 
00484         <span class="comment">/*----------------------------------------------------------------------</span>
00485 <span class="comment">        * STEP 1: Read uninitialized data.  It should be zero.</span>
00486 <span class="comment">        *---------------------------------------------------------------------- </span>
00487 <span class="comment">        */</span>
00488         TESTING(<span class="stringliteral">"compression (uninitialized read)"</span>);
00489   
00490         dataset-&gt;read ((<span class="keywordtype">void</span>*) check, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);
00491     
00492         <span class="keywordflow">for</span> (i=0; i&lt;size[0]; i++) {
00493             <span class="keywordflow">for</span> (j=0; j&lt;size[1]; j++) {
00494                 <span class="keywordflow">if</span> (0!=check[i][j]) {
00495                     H5_FAILED();
00496                     cout &lt;&lt; <span class="stringliteral">"    Read a non-zero value."</span> &lt;&lt; endl;
00497                     cout &lt;&lt; <span class="stringliteral">"    At index "</span> &lt;&lt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)i &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; 
00498                    (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)j &lt;&lt; endl;
00499                     <span class="keywordflow">goto</span> error;
00500                 }
00501             }
00502         }
00503     PASSED();
00504 
00505         <span class="comment">/*----------------------------------------------------------------------</span>
00506 <span class="comment">        * STEP 2: Test compression by setting up a chunked dataset and writing</span>
00507 <span class="comment">        * to it.</span>
00508 <span class="comment">        *---------------------------------------------------------------------- </span>
00509 <span class="comment">        */</span>
00510         TESTING(<span class="stringliteral">"compression (write)"</span>);
00511     
00512         <span class="keywordflow">for</span> (i=n=0; i&lt;size[0]; i++)
00513         {
00514             <span class="keywordflow">for</span> (j=0; j&lt;size[1]; j++) 
00515             {
00516                 points[i][j] = n++;
00517             }
00518         }
00519 
00520         dataset-&gt;write ((<span class="keywordtype">void</span>*) points, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);
00521 
00522     PASSED();
00523 
00524         <span class="comment">/*----------------------------------------------------------------------</span>
00525 <span class="comment">        * STEP 3: Try to read the data we just wrote.</span>
00526 <span class="comment">        *---------------------------------------------------------------------- </span>
00527 <span class="comment">        */</span>
00528         TESTING(<span class="stringliteral">"compression (read)"</span>);
00529 
00530         <span class="comment">/* Read the dataset back */</span>
00531         dataset-&gt;read ((<span class="keywordtype">void</span>*)check, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);
00532 
00533         <span class="comment">/* Check that the values read are the same as the values written */</span>
00534         <span class="keywordflow">for</span> (i = 0; i &lt; size[0]; i++)
00535             <span class="keywordflow">for</span> (j = 0; j &lt; size[1]; j++)
00536             {
00537                 <span class="keywordtype">int</span> status = check_values (i, j, points[i][j], check[i][j]);
00538                 <span class="keywordflow">if</span> (status == -1) <span class="keywordflow">goto</span> error;
00539             }
00540 
00541     PASSED();
00542 
00543         <span class="comment">/*----------------------------------------------------------------------</span>
00544 <span class="comment">        * STEP 4: Write new data over the top of the old data.  The new data is</span>
00545 <span class="comment">        * random thus not very compressible, and will cause the chunks to move</span>
00546 <span class="comment">        * around as they grow.  We only change values for the left half of the</span>
00547 <span class="comment">        * dataset although we rewrite the whole thing.</span>
00548 <span class="comment">        *---------------------------------------------------------------------- </span>
00549 <span class="comment">        */</span>
00550         TESTING(<span class="stringliteral">"compression (modify)"</span>);
00551     
00552         <span class="keywordflow">for</span> (i=0; i&lt;size[0]; i++)
00553         {
00554             <span class="keywordflow">for</span> (j=0; j&lt;size[1]/2; j++) 
00555             {
00556                 points[i][j] = rand ();
00557             }
00558         }
00559         dataset-&gt;write ((<span class="keywordtype">void</span>*)points, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);
00560 
00561         <span class="comment">/* Read the dataset back and check it */</span>
00562         dataset-&gt;read ((<span class="keywordtype">void</span>*)check, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);
00563 
00564         <span class="comment">/* Check that the values read are the same as the values written */</span>
00565         <span class="keywordflow">for</span> (i = 0; i &lt; size[0]; i++)
00566             <span class="keywordflow">for</span> (j = 0; j &lt; size[1]; j++)
00567             {
00568                 <span class="keywordtype">int</span> status = check_values (i, j, points[i][j], check[i][j]);
00569                 <span class="keywordflow">if</span> (status == -1) <span class="keywordflow">goto</span> error;
00570             }
00571 
00572     PASSED();
00573 
00574         <span class="comment">/*----------------------------------------------------------------------</span>
00575 <span class="comment">        * STEP 5: Close the dataset and then open it and read it again.  This</span>
00576 <span class="comment">        * insures that the compression message is picked up properly from the</span>
00577 <span class="comment">        * object header.</span>
00578 <span class="comment">        *---------------------------------------------------------------------- </span>
00579 <span class="comment">        */</span>
00580         TESTING(<span class="stringliteral">"compression (re-open)"</span>);
00581     
00582         <span class="keyword">delete</span> dataset;
00583     
00584         dataset = <span class="keyword">new</span> DataSet (file.openDataSet (DSET_COMPRESS_NAME));
00585         dataset-&gt;read ((<span class="keywordtype">void</span>*)check, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);
00586 
00587         <span class="comment">/* Check that the values read are the same as the values written */</span>
00588         <span class="keywordflow">for</span> (i = 0; i &lt; size[0]; i++)
00589             <span class="keywordflow">for</span> (j = 0; j &lt; size[1]; j++)
00590             {
00591                 <span class="keywordtype">int</span> status = check_values (i, j, points[i][j], check[i][j]);
00592                 <span class="keywordflow">if</span> (status == -1) <span class="keywordflow">goto</span> error;
00593             }
00594 
00595     PASSED();
00596     
00597 
00598         <span class="comment">/*----------------------------------------------------------------------</span>
00599 <span class="comment">        * STEP 6: Test partial I/O by writing to and then reading from a</span>
00600 <span class="comment">        * hyperslab of the dataset.  The hyperslab does not line up on chunk</span>
00601 <span class="comment">        * boundaries (we know that case already works from above tests).</span>
00602 <span class="comment">        *---------------------------------------------------------------------- </span>
00603 <span class="comment">        */</span>
00604         TESTING(<span class="stringliteral">"compression (partial I/O)"</span>);
00605 
00606         <span class="keyword">const</span> hsize_t   hs_size[2] = {4, 50};
00607         <span class="keyword">const</span> hssize_t  hs_offset[2] = {7, 30};
00608         <span class="keywordflow">for</span> (i = 0; i &lt; hs_size[0]; i++) {
00609             <span class="keywordflow">for</span> (j = 0; j &lt; hs_size[1]; j++) {
00610                 points[hs_offset[0]+i][hs_offset[1]+j] = rand ();
00611             }
00612         }
00613         space1.selectHyperslab( H5S_SELECT_SET, hs_size, hs_offset );
00614         dataset-&gt;write ((<span class="keywordtype">void</span>*)points, PredType::NATIVE_INT, space1, space1, xfer);
00615         dataset-&gt;read ((<span class="keywordtype">void</span>*)check, PredType::NATIVE_INT, space1, space1, xfer);
00616     
00617         <span class="comment">/* Check that the values read are the same as the values written */</span>
00618         <span class="keywordflow">for</span> (i=0; i&lt;hs_size[0]; i++) {
00619         <span class="keywordflow">for</span> (j=0; j&lt;hs_size[1]; j++) {
00620             <span class="keywordflow">if</span> (points[hs_offset[0]+i][hs_offset[1]+j] !=
00621                 check[hs_offset[0]+i][hs_offset[1]+j]) {
00622                 H5_FAILED();
00623                 cout &lt;&lt; <span class="stringliteral">"    Read different values than written.\n"</span> &lt;&lt; endl;
00624                 cout &lt;&lt; <span class="stringliteral">"    At index "</span> &lt;&lt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(hs_offset[0]+i) &lt;&lt; 
00625                    <span class="stringliteral">","</span> &lt;&lt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(hs_offset[1]+j) &lt;&lt; endl;
00626                 
00627                 cout &lt;&lt; <span class="stringliteral">"    At original: "</span> &lt;&lt; (<span class="keywordtype">int</span>)points[hs_offset[0]+i][hs_offset[1]+j] &lt;&lt; endl;
00628                 cout &lt;&lt; <span class="stringliteral">"    At returned: "</span> &lt;&lt; (<span class="keywordtype">int</span>)check[hs_offset[0]+i][hs_offset[1]+j] &lt;&lt; endl;
00629                 <span class="keywordflow">goto</span> error;
00630             }
00631         }
00632         }
00633 
00634         <span class="keyword">delete</span> dataset;
00635 
00636     PASSED();
00637 
00638 <span class="preprocessor">#else</span>
00639 <span class="preprocessor"></span>    TESTING(<span class="stringliteral">"deflate filter"</span>);
00640     SKIPPED();
00641     cout &lt;&lt; not_supported &lt;&lt; endl;
00642 <span class="preprocessor">#endif</span>
00643 <span class="preprocessor"></span>
00644         <span class="comment">/*----------------------------------------------------------------------</span>
00645 <span class="comment">        * STEP 7: Register an application-defined compression method and use it</span>
00646 <span class="comment">        * to write and then read the dataset.</span>
00647 <span class="comment">        *---------------------------------------------------------------------- </span>
00648 <span class="comment">        */</span>
00649         TESTING(<span class="stringliteral">"compression (app-defined method)"</span>);
00650 
00651 <span class="preprocessor">#ifdef H5_WANT_H5_V1_4_COMPAT</span>
00652 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (H5Zregister (H5Z_FILTER_BOGUS, <span class="stringliteral">"bogus"</span>, bogus)&lt;0) <span class="keywordflow">goto</span> error;
00653 <span class="preprocessor">#else </span><span class="comment">/* H5_WANT_H5_V1_4_COMPAT */</span>
00654         <span class="keywordflow">if</span> (H5Zregister (H5Z_BOGUS)&lt;0) <span class="keywordflow">goto</span> error;
00655 <span class="preprocessor">#endif </span><span class="comment">/* H5_WANT_H5_V1_4_COMPAT */</span>
00656         <span class="keywordflow">if</span> (H5Pset_filter (dscreatplist.getId(), H5Z_FILTER_BOGUS, 0, 0, NULL)&lt;0) <span class="keywordflow">goto</span> error;
00657         dscreatplist.setFilter (H5Z_FILTER_BOGUS, 0, 0, NULL);
00658 
00659         DataSpace space2 (2, size, NULL);
00660         dataset = <span class="keyword">new</span> DataSet (file.createDataSet (DSET_BOGUS_NAME, PredType::NATIVE_INT, space2, dscreatplist));
00661 
00662         dataset-&gt;write ((<span class="keywordtype">void</span>*)points, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);
00663         dataset-&gt;read ((<span class="keywordtype">void</span>*)check, PredType::NATIVE_INT, DataSpace::ALL, DataSpace::ALL, xfer);
00664     
00665         <span class="comment">/* Check that the values read are the same as the values written */</span>
00666         <span class="keywordflow">for</span> (i = 0; i &lt; size[0]; i++)
00667             <span class="keywordflow">for</span> (j = 0; j &lt; size[1]; j++)
00668             {
00669                 <span class="keywordtype">int</span> status = check_values (i, j, points[i][j], check[i][j]);
00670                 <span class="keywordflow">if</span> (status == -1) 
00671                     <span class="keywordflow">goto</span> error;
00672             }
00673 
00674         PASSED();
00675   
00676         <span class="comment">/*----------------------------------------------------------------------</span>
00677 <span class="comment">        * Cleanup</span>
00678 <span class="comment">        *---------------------------------------------------------------------- </span>
00679 <span class="comment">        */</span>
00680         <span class="keyword">delete</span> dataset;
00681         <span class="keyword">delete</span> [] tconv_buf;
00682         <span class="keywordflow">return</span> 0;
00683     } <span class="comment">// end try</span>
00684 
00685     <span class="comment">// catch all dataset, file, space, and plist exceptions</span>
00686     <span class="keywordflow">catch</span> (Exception E) { <span class="keywordflow">goto</span> error; }
00687    
00688   error:
00689     <span class="comment">// cleaning up</span>
00690     <span class="keywordflow">if</span> (tconv_buf)
00691         <span class="keyword">delete</span> [] tconv_buf;
00692     <span class="keywordflow">return</span> -1;
00693 }
00694 
00695 <span class="comment">/*-------------------------------------------------------------------------</span>
00696 <span class="comment"> * Function:    test_multiopen</span>
00697 <span class="comment"> *</span>
00698 <span class="comment"> * Purpose:     Tests that a bug no longer exists.  If a dataset is opened</span>
00699 <span class="comment"> *              twice and one of the handles is used to extend the dataset,</span>
00700 <span class="comment"> *              then the other handle should return the new size when</span>
00701 <span class="comment"> *              queried.</span>
00702 <span class="comment"> *</span>
00703 <span class="comment"> * Return:      Success:        0</span>
00704 <span class="comment"> *</span>
00705 <span class="comment"> *              Failure:        -1</span>
00706 <span class="comment"> *</span>
00707 <span class="comment"> * Programmer:  Binh-Minh Ribler (using C version)</span>
00708 <span class="comment"> *              Saturday, February 17, 2001</span>
00709 <span class="comment"> *</span>
00710 <span class="comment"> * Modifications:</span>
00711 <span class="comment"> *</span>
00712 <span class="comment"> *-------------------------------------------------------------------------</span>
00713 <span class="comment"> */</span>
00714 <span class="keyword">static</span> herr_t
00715 test_multiopen (H5File&amp; file)
00716 {
00717 
00718     TESTING(<span class="stringliteral">"multi-open with extending"</span>);
00719     <span class="keywordflow">try</span> {
00720 
00721         <span class="comment">// Create a dataset creation property list</span>
00722         DSetCreatPropList dcpl;
00723 
00724         <span class="comment">// Set chunk size to given size</span>
00725         hsize_t         cur_size[1] = {10};
00726         dcpl.setChunk (1, cur_size);
00727 
00728         <span class="comment">// Create a simple data space with unlimited size</span>
00729         <span class="keyword">static</span> hsize_t  max_size[1] = {H5S_UNLIMITED};
00730         DataSpace* space = <span class="keyword">new</span> DataSpace (1, cur_size, max_size);
00731 
00732         <span class="comment">// Create first dataset</span>
00733         DataSet dset1 = file.createDataSet (<span class="stringliteral">"multiopen"</span>, PredType::NATIVE_INT, *space, dcpl);
00734     
00735         <span class="comment">// Open again the first dataset from the file to another DataSet object.</span>
00736         DataSet dset2 = file.openDataSet (<span class="stringliteral">"multiopen"</span>);
00737 
00738         <span class="comment">// Relieve the dataspace</span>
00739         <span class="keyword">delete</span> space;
00740 
00741         <span class="comment">// Extend the dimensionality of the first dataset</span>
00742         cur_size[0] = 20;
00743         dset1.extend (cur_size);
00744 
00745         <span class="comment">/* Get the size from the second handle */</span>
00746         space = <span class="keyword">new</span> DataSpace (dset2.getSpace());
00747 
00748         hsize_t         tmp_size[1];
00749         space-&gt;getSimpleExtentDims (tmp_size);
00750         <span class="keywordflow">if</span> (cur_size[0]!=tmp_size[0]) 
00751         {
00752             H5_FAILED();
00753             cout &lt;&lt; <span class="stringliteral">"    Got "</span> &lt;&lt; (<span class="keywordtype">int</span>)tmp_size[0] &lt;&lt; <span class="stringliteral">" instead of "</span> 
00754                     &lt;&lt; (<span class="keywordtype">int</span>)cur_size[0] &lt;&lt; <span class="stringliteral">"!"</span> &lt;&lt; endl;
00755             <span class="keyword">delete</span> space;
00756             <span class="keywordflow">goto</span> error;
00757         }
00758     
00759         <span class="keyword">delete</span> space;
00760         PASSED();
00761         <span class="keywordflow">return</span> 0;
00762     } <span class="comment">// end try block</span>
00763 
00764     <span class="comment">// catch all dataset, file, space, and plist exceptions</span>
00765     <span class="keywordflow">catch</span> (Exception E)
00766     { <span class="keywordflow">goto</span> error; }
00767 
00768  error:
00769     <span class="keywordflow">return</span> -1;
00770 }
00771 
00772 
00773 <span class="comment">/*-------------------------------------------------------------------------</span>
00774 <span class="comment"> * Function:    test_types</span>
00775 <span class="comment"> *</span>
00776 <span class="comment"> * Purpose:     Test various types - should be moved to dtypes.cpp</span>
00777 <span class="comment"> *</span>
00778 <span class="comment"> * Return:      Success:        0</span>
00779 <span class="comment"> *</span>
00780 <span class="comment"> *              Failure:        -1</span>
00781 <span class="comment"> *</span>
00782 <span class="comment"> * Programmer:  Binh-Minh Ribler (using C version)</span>
00783 <span class="comment"> *              February 17, 2001</span>
00784 <span class="comment"> *</span>
00785 <span class="comment"> * Modifications:</span>
00786 <span class="comment"> *</span>
00787 <span class="comment"> *-------------------------------------------------------------------------</span>
00788 <span class="comment"> */</span>
00789 <span class="keyword">static</span> herr_t
00790 test_types(H5File&amp; file)
00791 {
00792     size_t              i;
00793 
00794     TESTING(<span class="stringliteral">"various datatypes"</span>);
00795     <span class="keywordflow">try</span> {
00796 
00797         <span class="comment">// Create a group in the file that was passed in from the caller</span>
00798         Group grp = file.createGroup (<span class="stringliteral">"typetests"</span>);
00799 
00800         <span class="comment">/* bitfield_1 */</span>
00801         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>   buf[32];
00802         hsize_t nelmts = <span class="keyword">sizeof</span>(buf);
00803         DataType type;
00804         <span class="keywordflow">try</span> { <span class="comment">// block of bitfield_1</span>
00805             <span class="comment">// test copying a predefined type</span>
00806             type.copy (PredType::STD_B8LE);
00807 
00808             <span class="comment">// Test copying a user-defined type using DataType::copy</span>
00809             DataType copied_type;
00810             copied_type.copy(type);
00811             <span class="comment">// Test copying a user-defined type using DataType::operator=</span>
00812             DataType another_copied_type;
00813             another_copied_type = type;
00814 
00815             <span class="comment">// Test copying a user-defined int type using DataType::operator=</span>
00816             IntType orig_int(PredType::STD_B8LE);
00817             DataType generic_type;
00818             generic_type = orig_int;
00819 
00820             <span class="comment">// Test copying an integer predefined type</span>
00821             IntType new_int_type(PredType::STD_B8LE);
00822 
00823             <span class="comment">// Test copying an int predefined type using DataType::operator=</span>
00824             IntType another_int_type;
00825             another_int_type = new_int_type;
00826 
00827             DataSpace space (1, &amp;nelmts);
00828             DataSet* dset = <span class="keyword">new</span> DataSet(grp.createDataSet(<span class="stringliteral">"bitfield_1"</span>, type, space));
00829 
00830             <span class="comment">// Fill buffer</span>
00831             <span class="keywordflow">for</span> (i=0; i&lt;<span class="keyword">sizeof</span> buf; i++) 
00832                 buf[i] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)0xff ^ (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)i;
00833 
00834             <span class="comment">// Write data from buf using all default dataspaces and property </span>
00835             <span class="comment">// list; if writing fails, deallocate dset and return.</span>
00836             <span class="keywordflow">try</span> { dset-&gt;write (buf, type); }
00837             <span class="keywordflow">catch</span>(DataSetIException E) 
00838             {
00839                 <span class="keyword">delete</span> dset;
00840                 <span class="keywordflow">goto</span> error;
00841             }
00842             <span class="keyword">delete</span> dset;
00843 
00844         } <span class="comment">// end try block of bitfield_1</span>
00845 
00846         <span class="comment">// catch exceptions thrown in try block of bitfield_1</span>
00847         <span class="keywordflow">catch</span> (Exception E) { 
00848             cout &lt;&lt; <span class="stringliteral">"Failure in "</span> &lt;&lt; E.getFuncName() &lt;&lt; <span class="stringliteral">" - "</span> 
00849                  &lt;&lt; E.getDetailMsg() &lt;&lt; endl;
00850             <span class="keywordflow">goto</span> error;
00851         }
00852 
00853         <span class="comment">/* bitfield_2 */</span>
00854         nelmts = <span class="keyword">sizeof</span>(buf)/2;
00855         <span class="keywordflow">try</span> { <span class="comment">// bitfield_2 block</span>
00856             type.copy (PredType::STD_B16LE);
00857             DataSpace space (1, &amp;nelmts);
00858             DataSet* dset = <span class="keyword">new</span> DataSet(grp.createDataSet(<span class="stringliteral">"bitfield_2"</span>, type, space));
00859 
00860             <span class="comment">// Fill buffer</span>
00861             <span class="keywordflow">for</span> (i=0; i&lt;<span class="keyword">sizeof</span>(buf); i++) 
00862                 buf[i] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)0xff ^ (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)i;
00863 
00864             <span class="comment">// Write data from buf using all default dataspaces and property </span>
00865             <span class="comment">// list; if writing fails, deallocate dset and return.</span>
00866             <span class="keywordflow">try</span> { dset-&gt;write (buf, type); }
00867             <span class="keywordflow">catch</span>(DataSetIException E) 
00868             {
00869                 cout &lt;&lt; <span class="stringliteral">"Failure in "</span> &lt;&lt; E.getFuncName() &lt;&lt; <span class="stringliteral">" - "</span> 
00870                  &lt;&lt; E.getDetailMsg() &lt;&lt; endl;
00871                 <span class="keyword">delete</span> dset;
00872                 <span class="keywordflow">goto</span> error;
00873             }
00874             <span class="keyword">delete</span> dset;
00875         } <span class="comment">// end try block of bitfield_2</span>
00876 
00877         <span class="comment">// catch exceptions thrown in try block of bitfield_2</span>
00878         <span class="keywordflow">catch</span> (Exception E) {
00879             cout &lt;&lt; <span class="stringliteral">"Failure in "</span> &lt;&lt; E.getFuncName() &lt;&lt; <span class="stringliteral">" - "</span> 
00880                  &lt;&lt; E.getDetailMsg() &lt;&lt; endl;
00881             <span class="keywordflow">goto</span> error;
00882         }
00883 
00884         <span class="comment">/* opaque_1 */</span>
00885         DataType* optype = <span class="keyword">new</span> DataType(H5T_OPAQUE, 1);
00886         <span class="keywordflow">try</span> { <span class="comment">// opaque_1 block</span>
00887             nelmts = <span class="keyword">sizeof</span>(buf);
00888             DataSpace space (1, &amp;nelmts);
00889             optype-&gt;setTag (<span class="stringliteral">"testing 1-byte opaque type"</span>);
00890             DataSet* dset = <span class="keyword">new</span> DataSet(grp.createDataSet(<span class="stringliteral">"opaque_1"</span>, *optype, space));
00891 
00892             <span class="comment">// Fill buffer</span>
00893             <span class="keywordflow">for</span> (i=0; i&lt;<span class="keyword">sizeof</span> buf; i++) 
00894                 buf[i] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)0xff ^ (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)i;
00895 
00896             <span class="comment">// Write data from buf using all default dataspaces and property </span>
00897             <span class="comment">// list; if writing fails, deallocate dset and return.</span>
00898             <span class="keywordflow">try</span> { dset-&gt;write (buf, *optype); }
00899             <span class="keywordflow">catch</span>(DataSetIException E) 
00900             {
00901                 <span class="keyword">delete</span> dset;
00902                 <span class="keywordflow">goto</span> error;
00903             }
00904             <span class="keyword">delete</span> dset;
00905             <span class="keyword">delete</span> optype;
00906         } <span class="comment">// end try block of opaque_1</span>
00907 
00908         <span class="comment">// catch exceptions thrown in try block of opaque_1</span>
00909         <span class="keywordflow">catch</span> (DataSetIException E) { 
00910             <span class="keyword">delete</span> optype;
00911             cout &lt;&lt; <span class="stringliteral">"Failure in "</span> &lt;&lt; E.getFuncName() &lt;&lt; <span class="stringliteral">" - "</span> 
00912                  &lt;&lt; E.getDetailMsg() &lt;&lt; endl;
00913             <span class="keywordflow">goto</span> error;
00914         }
00915         <span class="keywordflow">catch</span> (Exception E) {
00916             cout &lt;&lt; <span class="stringliteral">"Failure in "</span> &lt;&lt; E.getFuncName() &lt;&lt; <span class="stringliteral">" - "</span> 
00917                  &lt;&lt; E.getDetailMsg() &lt;&lt; endl;
00918             <span class="keywordflow">goto</span> error;
00919         }
00920     
00921         <span class="comment">/* opaque_2 */</span>
00922         <span class="keywordflow">try</span> { <span class="comment">// block opaque_2</span>
00923             nelmts = <span class="keyword">sizeof</span>(buf)/4;
00924             DataSpace space (1, &amp;nelmts);
00925             optype = <span class="keyword">new</span> DataType(H5T_OPAQUE, 4);
00926             optype-&gt;setTag (<span class="stringliteral">"testing 4-byte opaque type"</span>);
00927             DataSet* dset = <span class="keyword">new</span> DataSet(grp.createDataSet(<span class="stringliteral">"opaque_2"</span>, *optype, space));
00928 
00929             <span class="comment">// Fill buffer</span>
00930             <span class="keywordflow">for</span> (i=0; i&lt;<span class="keyword">sizeof</span>(buf); i++) 
00931                 buf[i] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)0xff ^ (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)i;
00932 
00933             <span class="comment">// Write data from buf using all default dataspaces and property </span>
00934             <span class="comment">// list; if writing fails, deallocate dset and return.</span>
00935             <span class="keywordflow">try</span> { dset-&gt;write (buf, *optype); }
00936             <span class="keywordflow">catch</span>(DataSetIException E) 
00937             {
00938                 <span class="keyword">delete</span> dset;
00939                 <span class="keywordflow">goto</span> error;
00940             }
00941             <span class="keyword">delete</span> dset;
00942             <span class="keyword">delete</span> optype;
00943         } <span class="comment">//end try block of opaque_2</span>
00944         <span class="keywordflow">catch</span> (DataSetIException E) { 
00945             <span class="keyword">delete</span> optype;
00946             cout &lt;&lt; <span class="stringliteral">"Failure in "</span> &lt;&lt; E.getFuncName() &lt;&lt; <span class="stringliteral">" - "</span> 
00947                  &lt;&lt; E.getDetailMsg() &lt;&lt; endl;
00948             <span class="keywordflow">goto</span> error;
00949         }
00950         <span class="keywordflow">catch</span> (Exception E) {
00951             cout &lt;&lt; <span class="stringliteral">"Failure in "</span> &lt;&lt; E.getFuncName() &lt;&lt; <span class="stringliteral">" - "</span> 
00952                  &lt;&lt; E.getDetailMsg() &lt;&lt; endl;
00953             <span class="keywordflow">goto</span> error;
00954         }
00955     
00956     PASSED();
00957     <span class="keywordflow">return</span> 0;
00958     } <span class="comment">// end top try block</span>
00959 
00960     <span class="keywordflow">catch</span> (Exception E) { <span class="comment">// Group and DataType exceptions</span>
00961             cout &lt;&lt; <span class="stringliteral">"Failure in "</span> &lt;&lt; E.getFuncName() &lt;&lt; <span class="stringliteral">" - "</span> 
00962                  &lt;&lt; E.getDetailMsg() &lt;&lt; endl;
00963             <span class="keywordflow">goto</span> error;
00964     }
00965 
00966  error:
00967     <span class="keywordflow">return</span> -1;
00968 }
00969 
00970 <span class="comment">/*-------------------------------------------------------------------------</span>
00971 <span class="comment"> * Function:    main</span>
00972 <span class="comment"> *</span>
00973 <span class="comment"> * Purpose:     Tests the dataset interface (H5D)</span>
00974 <span class="comment"> *</span>
00975 <span class="comment"> * Return:      Success:        exit(0)</span>
00976 <span class="comment"> *</span>
00977 <span class="comment"> *              Failure:        exit(1)</span>
00978 <span class="comment"> *</span>
00979 <span class="comment"> * Programmer:  Binh-Minh Ribler (using C version)</span>
00980 <span class="comment"> *              Friday, January 5, 2001</span>
00981 <span class="comment"> *</span>
00982 <span class="comment"> * Modifications:</span>
00983 <span class="comment"> *      Nov 12, 01:</span>
00984 <span class="comment"> *              - moved h5_cleanup to outside of try block because</span>
00985 <span class="comment"> *                dataset.h5 cannot be removed until "file" is out of</span>
00986 <span class="comment"> *                scope and dataset.h5 is closed. </span>
00987 <span class="comment"> *</span>
00988 <span class="comment"> *-------------------------------------------------------------------------</span>
00989 <span class="comment"> */</span>
00990 <span class="keywordtype">int</span>
00991 main(<span class="keywordtype">void</span>)
00992 {
00993     h5_reset(); <span class="comment">// in h5test.c, resets the library by closing it</span>
00994 
00995     hid_t       fapl_id;
00996     fapl_id = h5_fileaccess(); <span class="comment">// in h5test.c, returns a file access template</span>
00997     
00998     <span class="keywordtype">char</span>        filename[1024];
00999     h5_fixname(FILENAME[0], fapl_id, filename, <span class="keyword">sizeof</span> filename);
01000 
01001     <span class="keywordtype">int</span>         nerrors=0;      <span class="comment">// keep track of number of failures occurr</span>
01002     <span class="keywordflow">try</span> 
01003     {
01004         <span class="comment">// Turn of the auto-printing when failure occurs so that we can </span>
01005         <span class="comment">// handle the errors appropriately since sometime failures are</span>
01006         <span class="comment">// caused deliberately and expected.</span>
01007         Exception::dontPrint();
01008 
01009         <span class="comment">// Use the file access template id to create a file access prop.</span>
01010         <span class="comment">// list object to pass in H5File::H5File</span>
01011         FileAccPropList fapl(fapl_id);
01012 
01013         H5File file( filename, H5F_ACC_TRUNC, FileCreatPropList::DEFAULT, fapl);
01014        
01015         <span class="comment">/* Cause the library to emit initial messages */</span>
01016         Group grp = file.createGroup( <span class="stringliteral">"emit diagnostics"</span>, 0);
01017         grp.setComment( <span class="stringliteral">"."</span>, <span class="stringliteral">"Causes diagnostic messages to be emitted"</span>);
01018 
01019         nerrors += test_create(file)&lt;0  ?1:0;
01020         nerrors += test_simple_io(file)&lt;0       ?1:0;
01021         nerrors += test_tconv(file)&lt;0   ?1:0;
01022         nerrors += test_compression(file)&lt;0     ?1:0;
01023         nerrors += test_multiopen (file)&lt;0      ?1:0;
01024         nerrors += test_types(file)&lt;0       ?1:0;
01025 
01026         <span class="comment">// increment the ref count of this property list so that the </span>
01027         <span class="comment">// property list id won't be closed when fapl goes out of scope.</span>
01028         <span class="comment">// This is a bad hack, but I want to use existing routine h5_cleanup!</span>
01029         fapl.incRefCount();
01030     }
01031     <span class="keywordflow">catch</span> (Exception E) 
01032     {
01033         <span class="keywordflow">return</span>(test_report(nerrors, string(<span class="stringliteral">" Dataset"</span>)));
01034     }
01035     <span class="comment">/* use C test utility routine to clean up data files */</span>
01036     h5_cleanup(FILENAME, fapl_id);
01037 
01038     <span class="comment">/* print out dsets test results */</span>
01039     cerr &lt;&lt; endl &lt;&lt; endl;
01040     <span class="keywordflow">return</span>(test_report(nerrors, string(<span class="stringliteral">" Dataset"</span>)));
01041 }
</div></pre> </dd></dl>
<hr size="1"><address style="align: right;"><small>Generated on Sun Jul 25 01:27:17 2004 by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
