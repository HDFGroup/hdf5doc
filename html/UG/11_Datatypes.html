<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<head>
<title>Chapter 6: HDF5 Datatypes</title>

<!--(Meta)==========================================================-->

<!--(Links)=========================================================-->

<!--( Begin styles definition )=====================================-->
<link href="ed_styles/NewUGelect.css" rel="stylesheet" type="text/css">
<!--( End styles definition )=======================================-->

</head> 

<body>

<!-- #BeginLibraryItem "/ed_libs/Copyright.lbi" -->
<!--
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  * Copyright by The HDF Group.                                               *
  * Copyright by the Board of Trustees of the University of Illinois.         *
  * All rights reserved.                                                      *
  *                                                                           *
  * This file is part of HDF5.  The full HDF5 copyright notice, including     *
  * terms governing use, modification, and redistribution, is contained in    *
  * the files COPYING and Copyright.html.  COPYING can be found at the root   *
  * of the source code distribution tree; Copyright.html can be found at the  *
  * root level of an installed copy of the electronic HDF5 document set and   *
  * is linked from the top-level documents page.  It can also be found at     *
  * http://www.hdfgroup.org/HDF5/doc/Copyright.html.  If you do not have      *
  * access to either file, you may request a copy from help@hdfgroup.org.     *
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 -->
<!-- #EndLibraryItem --><!-- HEADER LEFT "HDF5 User's Guide" -->
<!-- HEADER RIGHT "HDF5 Datatypes" -->

<!--( TOC )=========================================================-->
<!--<SCRIPT language="JavaScript">-->
<!--
document.writeln ('\
<table x-use-null-cells\
                align=right\
		width="240"\
		cellspacing="0"\
		class="tocTable">\
  <tr valign="top"> \
    <td class="tocTableHeaderCell" colspan="2"> \
        <span class="TableHead">Chapter Contents</span></td>\
  </tr>\
-->
<!-- Table Version 3 -->
<!--
\
  <tr valign="top"> \
    <td class="tocTableContentCell2"> \
      <a href="#Intro">1.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#Intro">Introduction</a></td> \
  </tr>\
  <tr valign="top"> \
    <td class="tocTableContentCell2"> \
      <a href="#DtypesUsed">2.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#DtypesUsed">How Datatypes Are Used</a></td>\
  </tr>\
  <tr valign="top"> \
    <td class="tocTableContentCell2"> \
      <a href="#FileFunctSums">3.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#FileFunctSums">Datatype (H5T) Function Summaries</a></td> \
  </tr>\
  <tr valign="top"> \
    <td class="tocTableContentCell2"> \
      <a href="#Pmodel">4.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#Pmodel">The Programming Model</a></td>\
  </tr>\
  <tr valign="top"> \
    <td class="tocTableContentCell2"> \
      <a href="#NonNumDtypes">5.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#NonNumDtypes">Other Non-numeric Datatypes</a></td> \
  </tr>\
  <tr valign="top"> \
    <td class="tocTableContentCell2"> \
      <a href="#Fvalues">6.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#Fvalues">Fill Values</a></td>\
  </tr>\
  <tr valign="top"> \
    <td class="tocTableContentCell2"> \
      <a href="#CCDtypes">7.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#CCDtypes">Complex Combinations of Datatypes</a>\
	  </td>\
  </tr>\
  <tr valign="top"> \
    <td class="tocTableContentCell2"> \
      <a href="#LCDtypeObj">8.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#LCDtypeObj">Life Cycle of the Datatype Object</a>\
	  </td>\
  </tr>\
\
  <tr valign="top"> \
    <td class="tocTableContentCell"> \
-->
<!-- editingComment -- "tocTableContentCell" and "tocTableContentCell4" \
\-->
<!-- are the table-closing cell class.\
    <td class="tocTableContentCell2"> \
\-->
<!--
      <a href="#Dtransfer">9.</a></td>\
    <td class="tocTableContentCell4">\
	  <a href="#Dtransfer">Data Transfer: Datatype Conversion and Selection</a>\
  </td></tr>\
</table>\
')
-->
<!-- </SCRIPT> -->
<!--(End TOC)=======================================================-->

<!-- editingComment
  <span class="editingComment">[ [ [
  ] ] ]</span>
-->

<!-- editingComment
-->

<div align="center">
<a name="top">
<h2>Chapter 6<br /><font size="7">HDF5 Datatypes</font></h2>
</a>
</div>


<dir>

<!-- editingComment
  <span class="editingComment">[ [ [
<h1 class=editingComment align=center>- - - DRAFT - - -</h1>
  <p class="editingComment">- - - This is an early draft of the Datatypes chapter 
  of the new HDF5 User's Guide; much of this material will appear in the published 
  version of the new UG, but some will appear in other documents, such as the 
  HDF5 Reference Manual or the HDF5 Tutorial.  A PDF version of this draft is 
  being made available to HDF5 users prior to publication of the new UG because 
  it contains a great deal of information that is not otherwise available.  
  ] ] ]</span>
-->
</dir>

<a name="Intro">
<h3>6.1. Introduction</h3>
</a>


<h4>6.1.1. Introduction and Definitions</h4>

  <p>An HDF5 dataset is an array of data elements, arranged according to the 
  specifications of the dataspace.  In general, a data element is the smallest 
  addressable unit of storage in the HDF5 file. (Compound datatypes are the 
  exception to this rule.) The HDF5 datatype defines the storage format for a 
  single data element. See the figure below.</p>
  
  <p>The model for HDF5 attributes is extremely similar to datasets: 
  an attribute has a dataspace and a datatype, as shown in the figure below. 
  The information in this chapter applies to both datasets and attributes.</p>
  

<table width="500" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dtypes_fig1.JPG">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 1. Datatypes, dataspaces, and datasets</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

  <p>Abstractly, each data element within the dataset is a sequence of bits, 
  interpreted as a single value from a set of values (e.g., a number or a 
  character). For a given datatype, there is a standard or convention for 
  representing the values as bits, and when the bits are represented in 
  a particular storage the bits are laid out in a specific storage 
  scheme, e.g., as 8-bit bytes, with a specific ordering and alignment 
  of bytes within the storage array.</p>
  
  <p>HDF5 datatypes implement a flexible, extensible, and portable mechanism 
  for specifying and discovering the storage layout of the data elements, 
  determining how to interpret the elements (e.g., as floating point numbers), 
  and for transferring data from different compatible layouts.</p>
  
<!-- NEW PAGE -->
  <p>An HDF5 datatype describes one specific layout of bits. A dataset has a 
  single datatype which applies to every data element. When a dataset is 
  created, the storage datatype is defined. After the dataset or attribute 
  is created, the datatype cannot be changed.</p>
  
<ul>
    <li>The datatype describes the storage layout of a single data element</li>
    <li>All elements of the dataset must have the same type</li>
    <li>The datatype of a dataset is immutable</li>
</ul>

  <p>When data is transferred (e.g., a read or write), each end point of the 
  transfer has a datatype, which describes the correct storage for the elements. 
  The source and destination may have different (but compatible) layouts, in which 
  case the data elements are automatically transformed during the transfer.</p>
  
  <p>HDF5 datatypes describe commonly used binary formats for numbers (integers 
  and floating point) and characters (ASCII). A given computing architecture and 
  programming language supports certain number and character representations. 
  For example, a computer may support 8-, 16-, 32-, and 64-bit signed integers, 
  stored in memory in little-endian byte order. These would presumably correspond 
  to the C programming language types &lsquo;char&rsquo;, &lsquo;short&rsquo;, 
  &lsquo;int&rsquo;, and &lsquo;long&rsquo;.</p>
  
  <p>When reading and writing from memory, the HDF5 library must know the 
  appropriate datatype that describes the architecture specific layout. 
  The HDF5 library provides the platform independent &lsquo;NATIVE&rsquo; 
  types, which are mapped to an appropriate datatype for each platform. So 
  the type &lsquo;<code>H5T_NATIVE_INT</code>&rsquo; is an alias for 
  the appropriate descriptor for each platform.</p>
  
  <p>Data in memory has a datatype:</p>

<ul>
    <li>The storage layout in memory is architecture-specific</li>
    <li>The HDF5 &lsquo;NATIVE&rsquo; types are predefined aliases for the 
        architecture-specific memory layout</li>
    <li>The memory datatype need not be the same as the stored datatype of 
        the dataset</li>
</ul>

  <p>In addition to numbers and characters, an HDF5 datatype can describe more 
  abstract classes of types, including 
  <!-- date-times, 
            (TIME REFERENCES COMMENTED OUT 6 FEB 2006,
            UNTIL TIME DATATYPE IS PROPERLY SUPPORTED IN THE LIBRARY) -->
  enumerations, strings, bit strings, and references (pointers to objects 
  in the HDF5 file). HDF5 supports several classes of composite datatypes 
  which are combinations of one or more other datatypes. In addition to 
  the standard predefined datatypes, users can define new datatypes 
  within the datatype classes.</p>

  <p>The HDF5 datatype model is very general and flexible:</p>
  
<ul>
    <li>For common simple purposes, only predefined types will be needed</li>
    <li>Datatypes can be combined to create complex structured datatypes</li>
    <li>If needed, users can define custom atomic datatypes</li>
    <li>Committed datatypes can be shared by datasets or attributes</li>
</ul>

<!-- NEW PAGE -->
<h4>6.1.2. HDF5 Datatype Model</h4>

  <p>The HDF5 Library implements an object-oriented model of datatypes. 
  HDF5 datatypes are organized as a logical set of base types, or datatype 
  classes. Each datatype class defines a format for representing logical 
  values as a sequence of bits. For example the <code>H5T_INTEGER</code> 
  class is a format for representing twos complement integers of various 
  sizes.</p>
  
  <p>A datatype class is defined as a set of one or more datatype properties.  
  A datatype property is a property of the bit string. The datatype properties 
  are defined by the logical model of the datatype class.  For example, the 
  integer class (twos complement integers) has properties such as 
  &ldquo;signed or unsigned&rdquo;, &ldquo;length&rdquo;, and 
  &ldquo;byte-order&rdquo;. The float class (IEEE floating point 
  numbers) has these properties, plus &ldquo;exponent bits&rdquo;, 
  &ldquo;exponent sign&rdquo;, etc.</p>
  
  <p>A datatype is derived from one datatype class: a given datatype has 
  a specific value for the datatype properties defined by the class. 
  For example, for 32-bit signed integers, stored big-endian, the HDF5 
  datatype is a sub-type of integer with the properties set to 
  <code>signed=1</code>, <code>size=4</code> (bytes), and 
  <code>byte-order=BE</code>.</p>
  
  <p>The HDF5 datatype API (H5T functions) provides methods to create 
  datatypes of different datatype classes, to set the datatype properties 
  of a new datatype, and to discover the datatype properties of an 
  existing datatype.</p>
  
  <p>The datatype for a dataset is stored in the HDF5 file as part of 
  the metadata for the dataset.</p>
  
  <p>A datatype can be shared by more than one dataset in the file if the 
  datatype is saved to the file with a name. This shareable datatype is known
  as a committed datatype. In the past, this kind of datatype was called 
  a named datatype. </p>
  
  <p>When transferring data (e.g., a read or write), the data elements of 
  the source and destination storage must have compatible types.  As a 
  general rule, data elements with the same datatype class are compatible 
  while elements from different datatype classes are not compatible. When 
  transferring data of one datatype to another compatible datatype, the 
  HDF5 Library uses the datatype properties of the source and 
  destination to automatically transform each data element.  For 
  example, when reading from data stored as 32-bit signed integers, 
  big-endian into 32-bit signed integers, little-endian, the HDF5 
  Library will automatically swap the bytes.</p>
  
  <p>Thus, data transfer operations (<code>H5Dread</code>, 
  <code>H5Dwrite</code>, <code>H5Aread</code>, <code>H5Awrite</code>) require 
  a datatype for both the source and the destination.</p>
  
<!-- NEW PAGE -->
<table width="500" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dtypes_fig2.JPG">
        </td></tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 2. The datatype model</b> 
        <hr color="green" size="3"/></td></tr>
</table>
<br />


  <p>The HDF5 Library defines a set of predefined datatypes, corresponding to 
  commonly used storage formats, such as twos complement integers, IEEE Floating 
  point numbers, etc., 4- and 8-byte sizes, big-endian and little-endian 
  byte orders.  In addition, a user can derive types with custom values 
  for the properties. For example, a user program may create a datatype 
  to describe a 6-bit integer, or a 600-bit floating point number.</p>
  
  <p>In addition to atomic datatypes, the HDF5 Library supports 
  composite datatypes. A composite datatype is an aggregation of one 
  or more datatypes. Each class of composite datatypes has properties 
  that describe the organization of the composite datatype. See the 
  figure below. Composite datatypes include:</p>

<ul>
    <li>Compound datatypes: structured records</li>
    <li>Array: a multidimensional array of a datatype</li>
    <li>Variable-length: a one-dimensional array of a datatype</li>
</ul>

<br />

<!-- NEW PAGE -->
<table width="400" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dtypes_fig3.JPG">
        </td></tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 3. Composite datatypes</b> 
        <hr color="green" size="3"/></td></tr>
</table>
<br />


<h4><em>6.1.2.1. Datatype Classes and Properties</em></h4>

  <p>The figure below shows the HDF5 datatype classes. Each class is 
  defined to have a set of properties which describe the layout of the 
  data element and the interpretation of the bits. The table below 
  lists the properties for the datatype classes.</p>
  
<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dtypes_fig4.JPG">
        </td></tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 4. Datatype classes</b> 
        <hr color="green" size="3"/></td></tr>
</table>
<br />
<br />
<!-- NEW PAGE -->

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="7" align="left" valign="bottom">
        <b>Table 1. Datatype classes and their properties</b></td>
        </tr>
    <tr><td colspan="7"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="20%"><b>Class</b></td>
        <td width="2%">&nbsp;</td>
        <td width="18%"><b>Description</b></td>
        <td width="2%">&nbsp;</td>
        <td width="28%"><b>Properties</b></td>
        <td width="2%">&nbsp;</td>
        <td width="28%"><b>Notes</b></td>
        </tr>
    <tr><td colspan="7"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Integer</td>
        <td>&nbsp;</td>
        <td>Twos complement integers</td>
        <td>&nbsp;</td>
        <td>Size (bytes), precision (bits), offset (bits), 
        pad, byte order, signed/unsigned</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        </tr>
    <tr><td colspan="7"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Float</td>
        <td>&nbsp;</td>
        <td>Floating Point numbers</td>
        <td>&nbsp;</td>
        <td>Size (bytes), precision (bits), offset (bits), 
        pad, byte order, sign position, exponent position, exponent size (bits), 
        exponent sign, exponent bias, mantissa position, mantissa (size) bits, 
        mantissa sign, mantissa normalization, internal padding</td>
        <td>&nbsp;</td>
        <td>See IEEE 754 for a definition of these properties. These 
        properties describe non-IEEE 754 floating point formats as well.</td>
        </tr>
    <tr><td colspan="7"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Character</td>
        <td>&nbsp;</td>
        <td>Array of 1-byte character encoding </td>
        <td>&nbsp;</td>
        <td>Size (characters), Character set, byte order, 
        pad/no pad, pad character</td>
        <td>&nbsp;</td>
        <td>Currently, ASCII and UTF-8 are supported.</td>
        </tr>
    <tr><td colspan="7"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Bitfield</td>
        <td>&nbsp;</td>
        <td>String of bits</td>
        <td>&nbsp;</td>
        <td>Size (bytes), precision (bits), offset (bits), 
        pad, byte order</td>
        <td>&nbsp;</td>
        <td>A sequence of bit values packed into one or more bytes.</td>
        </tr>
    <tr><td colspan="7"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Opaque</td>
        <td>&nbsp;</td>
        <td>Uninterpreted data</td>
        <td>&nbsp;</td>
        <td>Size (bytes), precision (bits), offset (bits), 
        pad, byte order, tag</td>
        <td>&nbsp;</td>
        <td>A sequence of bytes, stored and retrieved as a block. The 
        &lsquo;tag&rsquo; is a string that can be used to label 
        the value.</td>
        </tr>
    <tr><td colspan="7"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Enumeration</td>
        <td>&nbsp;</td>
        <td>A list of discrete values, with symbolic names 
        in the form of strings.</td>
        <td>&nbsp;</td>
        <td>Number of elements, element names, element values</td>
        <td>&nbsp;</td>
        <td>Enumeration is a list of pairs, (name, value). The name is 
        a string, the value is an unsigned integer.</td>
        </tr>
    <tr><td colspan="7"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Reference</td>
        <td>&nbsp;</td>
        <td>Reference to object or region within the HDF5 file</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td> See the Reference API, H5R</td>
        </tr>
    <tr><td colspan="7"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Array</td>
        <td>&nbsp;</td>
        <td>Array (1-4 dimensions) of data elements</td>
        <td>&nbsp;</td>
        <td>Number of dimensions, dimension sizes, base datatype</td>
        <td>&nbsp;</td>
        <td>The array is accessed atomically: no selection or sub-setting.</td>
        </tr>
    <!-- NEW PAGE -->
    <tr><td colspan="7"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Variable-length</td>
        <td>&nbsp;</td>
        <td>A variable-length 1-dimensional array of data data elements</td>
        <td>&nbsp;</td>
        <td>Current size, base type</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        </tr>
    <tr><td colspan="7"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Compound</td>
        <td>&nbsp;</td>
        <td>A Datatype  of a sequence of Datatypes</td>
        <td>&nbsp;</td>
        <td>Number of members, member names, member types, 
        member offset, member class, member size, byte order </td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        </tr>
    <tr><td colspan="7"><hr color="green" size="3" /></td></tr>
</table>
<br />



<h4><em>6.1.2.2. Predefined Datatypes</em></h4>

  <p>The HDF5 library predefines a modest number of commonly used datatypes. 
  These types have standard symbolic names of the form 
  <code>H5T_<em>arch_base</em></code> where <em>arch</em> is an architecture 
  name and <em>base</em> is a programming type name (Table 2). New types can 
  be derived from the predefined types by copying the predefined type (see 
  <code>H5Tcopy()</code>) and then modifying the result. </p>
  
  <p>The base name of most types consists of a letter to indicate the class 
  (Table 3), a precision in bits, and an indication of the byte order (Table 4).</p>
  
  <p>Table 5 shows examples of predefined datatypes. 
  The full list can be found  in the &ldquo;HDF5 Predefined Datatypes&rdquo; 
  section of the <a href="../RM/RM_H5Front.html">
  <cite>HDF5 Reference Manual</cite></a>.</p>
<!-- editingComment
  <span class="editingComment">[ [ [
  Link to ../PredefDTypes.html
  ] ] ]</span>
-->
<br />

<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 2. Architectures used in predefined datatypes</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="20%"> 
        <b>Architecture<br />Name</b></td>
        <td width="80%"> 
        <b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>IEEE</code> </td>
        <td>IEEE-754 standard floating point types in 
        various byte orders.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>STD</code> </td>
        <td>
        This is an architecture that contains semi-standard 
        datatypes like signed two&rsquo;s complement integers, unsigned 
        integers, and bitfields in various byte orders.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>C <br /> FORTRAN</code> </td>
        <td>Types which are specific to the C or Fortran 
        programming languages are defined in these architectures. For instance, 
        <code>H5T_C_S1</code> defines a base string type with null termination 
        which can be used to derive string types of other lengths.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>NATIVE</code> </td>
        <td>This architecture contains C-like 
        datatypes for the machine on which the library was compiled. The 
        types were actually defined by running the <code>H5detect</code> 
        program when the library was compiled. In order to be portable, 
        applications should almost always use this architecture to describe 
        things in memory.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>CRAY</code> </td>
        <td>Cray architectures. These are 
        word-addressable, big-endian systems with non-IEEE floating point.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>INTEL</code> </td>
        <td>All Intel and compatible CPU&rsquo;s 
        including 80286, 80386, 80486, Pentium, Pentium-Pro, and Pentium-II. 
        These are little-endian systems with IEEE floating-point.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>MIPS</code> </td>
        <td>All MIPS CPU&rsquo;s commonly used in 
        SGI systems. These are big-endian systems with IEEE floating-point.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>ALPHA</code> </td>
        <td>All DEC Alpha CPU&rsquo;s, 
        little-endian systems with IEEE floating-point.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />




<table width="200" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 3. Base types</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="50">B</td>
        <td width="150">Bitfield</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>F</td>
        <td>Floating point</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>I</td>
        <td>Signed integer</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>R</td>
        <td>References</td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>S</td>
        <td>Character string</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>U</td>
        <td>Unsigned integer</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />


<!-- NEW PAGE -->
<table width="200" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 4. Byte order</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="50">BE</td>
        <td width="150">Big-endian</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>LE</td>
        <td>Little-endian</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />



<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 5. Some predefined datatypes</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="25%"> 
        <b>Example</b></td>
        <td width="75%"> 
        <b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_IEEE_F64LE</code> </td>
        <td>Eight-byte, little-endian, IEEE floating-point</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_IEEE_F32BE</code> </td>
        <td>Four-byte, big-endian, IEEE floating point</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_STD_I32LE</code> </td>
        <td>Four-byte, little-endian, signed two&rsquo;s complement 
        integer</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_STD_U16BE</code> </td>
        <td>Two-byte, big-endian, unsigned integer</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_C_S1</code> </td>
        <td>One-byte, null-terminated string of eight-bit characters</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_INTEL_B64</code> </td>
        <td>Eight-byte bit field on an Intel CPU</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_CRAY_F64</code> </td>
        <td>Eight-byte Cray floating point</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_STD_ROBJ</code> </td>
        <td>Reference to an entire object in a file</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />





  <p>The HDF5 Library predefines a set of <code>NATIVE</code> datatypes which 
  are similar to C type names. The native types are set to be an alias for the 
  appropriate HDF5 datatype for each platform. For example, 
  <code>H5T_NATIVE_INT</code> corresponds to a C <code>int</code> type. 
  On an Intel based PC, this type is the same as <code>H5T_STD_I32LE</code>, 
  while on a MIPS system this would be equivalent to <code>H5T_STD_I32BE</code>. 
  Table 6 shows examples of <code>NATIVE</code> types and corresponding 
  C types for a common 32-bit workstation.</p>
  
<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 6. Native and 32-bit C datatypes</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td><b>Example</b></td>
        <td><b>Corresponding C Type</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_CHAR</code> </td>
        <td>char</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_SCHAR</code> </td>
        <td>signed char</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_UCHAR</code> </td>
        <td>unsigned char</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_SHORT</code> </td>
        <td>short</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_USHORT</code> </td>
        <td>unsigned short</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_INT</code> </td>
        <td>int</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_UINT</code> </td>
        <td>unsigned</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_LONG</code> </td>
        <td>long</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_ULONG</code> </td>
        <td>unsigned long</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_LLONG</code> </td>
        <td>long long</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_ULLONG</code> </td>
        <td>unsigned long long</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_FLOAT</code> </td>
        <td>float</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_DOUBLE</code> </td>
        <td>double</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_LDOUBLE</code> </td>
        <td>long double</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_HSIZE</code> </td>
        <td>hsize_t</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_HSSIZE</code> </td>
        <td>hssize_t</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_HERR</code> </td>
        <td>herr_t</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_HBOOL</code> </td>
        <td>hbool_t</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_B8</code> </td>
        <td>8-bit unsigned integer or 8-bit buffer in memory</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_B16</code> </td>
        <td>16-bit unsigned integer or 16-bit buffer in memory</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_B32</code> </td>
        <td>32-bit unsigned integer or 32-bit buffer in memory</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_NATIVE_B64</code> </td>
        <td>64-bit unsigned integer or 64-bit buffer in memory</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />



<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="DtypesUsed">
<div align=right>
<a href="#TOP"><font size="-1">(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<!-- NEW PAGE -->
<a name="DtypesUsed">
<h3 class=pagebefore>6.2. How Datatypes are Used</h3>
</a>

<h4>6.2.1. The Datatype Object and the HDF5 Datatype API</h4>

  <p>The HDF5 Library manages datatypes as objects. The HDF5 datatype API 
  manipulates the datatype objects through C function calls.  New datatypes 
  can be created from scratch or copied from existing datatypes. When a 
  datatype is no longer needed its resources should be released by calling 
  <code>H5Tclose()</code>. </p>
  
  <p>The datatype object is used in several roles in the HDF5 data model 
  and library. Essentially, a datatype is used whenever the format of 
  data elements is needed. There are four major uses of datatypes in 
  the HDF5 Library: at dataset creation, during data transfers, when 
  discovering the contents of a file, and for specifying user-defined 
  datatypes. See the table below.</p>
  

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 7. Datatype uses</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td> 
        <b>Use</b></td>
        <td> 
        <b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Dataset creation</td>
        <td>The datatype of the data elements must be 
        declared when the dataset is created.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Data transfer</td>
        <td>The datatype (format) of the data elements 
        must be defined for both the source and destination.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Discovery</td>
        <td>The datatype of a dataset can be 
        interrogated to retrieve a complete description of the storage layout.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Creating user-defined datatypes</td>
        <td>Users can define their own datatypes by 
        creating datatype objects and setting their properties.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />



<h4>6.2.2. Dataset Creation</h4>

  <p>All the data elements of a dataset have the same datatype. When a dataset 
  is created, the datatype for the data elements must be specified. The 
  datatype of a dataset can never be changed. The example below shows 
  the use of a datatype to create a dataset called &ldquo;/dset&rdquo;.  In 
  this example, the dataset will be stored as 32-bit signed integers in 
  big-endian order.</p>
  
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
<pre>
  hid_t dt;
  dt = H5Tcopy(H5T_STD_I32BE);
  dataset_id = H5Dcreate(file_id, &ldquo;/dset&rdquo;, dt, dataspace_id,   
      H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 1. Using a datatype to create a dataset </b> 
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<h4>6.2.3. Data Transfer (Read and Write)</h4>

  <p>Probably the most common use of datatypes is to write or read data from a 
  dataset or attribute. In these operations, each data element is transferred 
  from the source to the destination (possibly rearranging the order of the 
  elements). Since the source and destination do not need to be identical 
  (i.e., one is disk and the other is memory) the transfer requires both the 
  format of the source element and the destination element. Therefore, data 
  transfers use two datatype objects, for the source and destination.</p>
   
  <p>When data is written, the source is memory and the destination is disk 
  (file). The memory datatype describes the format of the data element in the 
  machine memory, and the file datatype describes the desired format of the data 
  element on disk. Similarly, when reading, the source datatype describes the 
  format of the data element on disk, and the destination datatype describes the 
  format in memory.</p>
  

  <p>In the most common cases, the file datatype is the datatype specified 
  when the dataset was created, and the memory datatype should be the 
  appropriate NATIVE type.</p>
  
  <p>The examples below show samples of writing data to and reading data 
  from a dataset. The data in memory is declared C type &lsquo;int&rsquo;, 
  and the datatype <code>H5T_NATIVE_INT</code> corresponds to this type. 
  The datatype of the dataset should be of datatype class 
  <code>H5T_INTEGER</code>.</p>
  
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
<pre>
   int  dset_data[DATA_SIZE];

   status = H5Dwrite(dataset_id, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, 
         H5P_DEFAULT, dset_data);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 2. Writing to a dataset</b> 
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />
<br />


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
<pre>
  int dset_data[DATA_SIZE];

  status = H5Dread(dataset_id, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, 
      H5P_DEFAULT,  dset_data);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 3. Reading from a dataset</b> 
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<h4>6.2.4. Discovery of Data Format</h4>

  <p>The HDF5 Library enables a program to determine the datatype class and 
  properties for any datatype. In order to discover the storage format of data 
  in a dataset, the datatype is obtained, and the properties are determined 
  by queries to the datatype object. The example below shows code that 
  analyzes the datatype for an integer and prints out a description of 
  its storage properties (byte order, signed, size.)</p>
<!-- NEW PAGE -->

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
<pre>
  switch (H5Tget_class(type)) {
  case H5T_INTEGER:
  ord = H5Tget_order(type);
  sgn = H5Tget_sign(type);
  printf(&ldquo;Integer ByteOrder= &rdquo;);
  switch (ord) {
  case H5T_ORDER_LE:
      printf(&ldquo;LE&rdquo;);
      break;
  case H5T_ORDER_BE:
      printf(&ldquo;BE&rdquo;);
      break;
  }
  printf(&ldquo; Sign= &rdquo;);
  switch (sgn) {
  case H5T_SGN_NONE:
      printf(&ldquo;false&rdquo;);
      break;
  case H5T_SGN_2:
      printf(&ldquo;true&rdquo;);
      break;
  }
  printf(&ldquo; Size= &rdquo;);
  sz = H5Tget_size(type);
  printf(&ldquo;%d&rdquo;, sz);
  printf(&ldquo;\n&rdquo;);
  break;</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 4. Discovering datatype properties</b> 
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<h4>6.2.5. Creating and Using User-defined Datatypes</h4>

  <p>Most programs will primarily use the predefined datatypes described above, 
  possibly in composite datatypes such as compound or array datatypes.  
  However, the HDF5 datatype model is extremely general; a user program can 
  define a great variety of atomic datatypes (storage layouts). In particular, 
  the datatype properties can define signed and unsigned integers of any size 
  and byte order, and floating point numbers with different formats, size, and 
  byte order. The HDF5 datatype API provides methods to set these properties.</p>
  
  <p>User-defined types can be used to define the layout of data in memory, 
  e.g., to match some platform specific number format or application 
  defined bit-field. The user-defined type can also describe data in 
  the file, e.g., some application-defined format.  The user-defined 
  types can be translated to and from standard types of the same class, 
  as described above.</p>
  
<!-- editingComment
  <span class="editingComment">[ [ [
  <p><em>{Simple programming example…}</em>
  ] ] ]</span>
-->
  

<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="FileFunctSums">
<div align=right>
<a href="#TOP"><font size="-1">(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<!-- NEW PAGE -->
<a name="FileFunctSums">
<h3 class=pagebefore>6.3. Datatype (H5T) Function Summaries</h3>
</a>
  <p>Functions that can be used with datatypes (H5T functions) and property 
  list functions that can be used with datatypes (H5P functions) are listed 
  below.</p>
<br />



<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Function Listing 1. General datatype operations
        </b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"><td width="25%"><b>C Function<br />Fortran Function</b></td>
        <td width="2%">&nbsp;</td>
        <td width="73%"><b>Purpose</b></td>

    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tcreate<br />h5tcreate_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Creates a new datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Topen<br />h5topen_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Opens a committed datatype. The C function is a 
        macro: see <a href="../RM/APICompatMacros.html">&ldquo;API 
        Compatibility Macros in HDF5.&rdquo;</a>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tcommit<br />h5tcommit_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Commits a transient datatype to a file. The datatype is now a 
        committed datatype. The C function is a 
        macro: see <a href="../RM/APICompatMacros.html">&ldquo;API 
        Compatibility Macros in HDF5.&rdquo;</a>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tcommit_anon<br />h5tcommit_anon_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Commits a transient datatype to a file. The datatype is now a 
        committed datatype, but it is not linked into the file structure. 
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tcommitted<br />h5tcommitted_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Determines whether a datatype is a committed or a transient type.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tcopy<br />h5tcopy_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Copies an existing datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tequal<br />h5tequal_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Determines whether two datatype identifiers refer to the same datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tlock<br />(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Locks a datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_class<br />h5tget_class_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns the datatype class identifier.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_create_plist<br />h5tget_create_plist_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns a copy of a datatype creation property list. 
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_size<br />h5tget_size_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns the size of a datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_super<br />h5tget_super_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns the base datatype from which a datatype is derived.
        </td>
        </tr>
    <!-- NEW PAGE -->
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_native_type<br />h5tget_native_type_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns the native datatype of a specified datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tdetect_class<br />(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Determines whether a datatype is of the given datatype class.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_order<br />h5tget_order_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns the byte order of a datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tset_order<br />h5tset_order_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the byte ordering of a datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tdecode<br />h5tdecode_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Decode a binary object description of datatype and return a new 
        object identifier. 
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tencode<br />h5tencode</code> 
        </td><td>&nbsp;</td>
        <td>
        Encode a datatype object description into a binary buffer. 
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tclose<br />h5tclose_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Releases a datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />







<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Function Listing 2. Conversion functions
        </b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td>
        <b>C Function<br />Fortran Function</b>
        </td><td>&nbsp;</td>
        <td>
        <b>Purpose</b>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tconvert<br />h5tconvert_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Converts data between specified datatypes. 
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tcompiler_conv<br />h5tcompiler_conv_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Check whether the library’s default conversion is hard conversion. 
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tfind<br />(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Finds a conversion function.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tregister<br />(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Registers a conversion function.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tunregister<br />(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Removes a conversion function from all conversion paths.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />



<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Function Listing 3. Atomic datatype properties 
        </b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td>
        <b>C Function<br />Fortran Function</b>
        </td><td>&nbsp;</td>
        <td>
        <b>Purpose</b>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tset_size<br />h5tset_size_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the total size for an atomic datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_precision<br />h5tget_precision_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns the precision of an atomic datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tset_precision<br />h5tset_precision_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the precision of an atomic datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_offset<br />h5tget_offset_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the bit offset of the first significant bit.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tset_offset<br />h5tset_offset_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the bit offset of the first significant bit.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_pad<br />h5tget_pad_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the padding type of the least and most-significant bit 
        padding.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tset_pad<br />h5tset_pad_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the least and most-significant bits padding types.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_sign<br />h5tget_sign_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the sign type for an integer type.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tset_sign<br />h5tset_sign_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the sign property for an integer type.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_fields<br />h5tget_fields_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves floating point datatype bit field information.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tset_fields<br />h5tset_fields_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets locations and sizes of floating point bit fields.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_ebias<br />h5tget_ebias_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the exponent bias of a floating-point type.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tset_ebias<br />h5tset_ebias_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the exponent bias of a floating-point type.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_norm<br />h5tget_norm_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves mantissa normalization of a floating-point datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tset_norm<br />h5tset_norm_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the mantissa normalization of a floating-point datatype.
        </td>
        </tr>
    <!-- NEW PAGE -->
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_inpad<br />h5tget_inpad_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the internal padding type for unused bits in floating-point 
        datatypes.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tset_inpad<br />h5tset_inpad_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Fills unused internal floating point bits.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_cset<br />h5tget_cset_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the character set type of a string datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tset_cset<br />h5tset_cset_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets character set to be used.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_strpad<br />h5tget_strpad_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the storage mechanism for a string datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tset_strpad<br />h5tset_strpad_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Defines the storage mechanism for character strings.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />




<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Function Listing 4. Enumeration datatypes 
        </b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td>
        <b>C Function<br />Fortran Function</b>
        </td><td>&nbsp;</td>
        <td>
        <b>Purpose</b>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tenum_create<br />h5tenum_create_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Creates a new enumeration datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tenum_insert<br />h5tenum_insert_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Inserts a new enumeration datatype member.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tenum_nameof<br />h5tenum_nameof_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns the symbol name corresponding to a specified member of an 
        enumeration datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tenum_valueof<br />h5tenum_valueof_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns the value corresponding to a specified member of an 
        enumeration datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_member_value<br />h5tget_member_value_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns the value of an enumeration datatype member.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_nmembers<br />h5tget_nmembers_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the number of elements in a compound or enumeration datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_member_name<br />h5tget_member_name_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the name of a compound or enumeration datatype member.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_member_index<br />(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the index of a compound or enumeration datatype member.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />





<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Function Listing 5. Compound datatype properties 
        </b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td>
        <b>C Function<br />Fortran Function</b>
        </td><td>&nbsp;</td>
        <td>
        <b>Purpose</b>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_nmembers<br />h5tget_nmembers_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the number of elements in a compound or enumeration datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_member_class<br />h5tget_member_class_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns datatype class of compound datatype member.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_member_name<br />h5tget_member_name_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the name of a compound or enumeration datatype member.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_member_index<br />h5tget_member_index_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the index of a compound or enumeration datatype member.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_member_offset<br />h5tget_member_offset_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the offset of a field of a compound datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_member_type<br />h5tget_member_type_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns the datatype of the specified member.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tinsert<br />h5tinsert_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Adds a new member to a compound datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tpack<br />h5tpack_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Recursively removes padding from within a compound datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />





<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Function Listing 6. Array datatypes 
        </b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td>
        <b>C Function<br />Fortran Function</b>
        </td><td>&nbsp;</td>
        <td>
        <b>Purpose</b>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tarray_create<br />h5tarray_create_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Creates an array datatype object. The C function is a 
        macro: see <a href="../RM/APICompatMacros.html">&ldquo;API 
        Compatibility Macros in HDF5.&rdquo;</a>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_array_ndims<br />h5tget_array_ndims_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns the rank of an array datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_array_dims<br />h5tget_array_dims_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns sizes of array dimensions and dimension permutations. 
        The C function is a 
        macro: see <a href="../RM/APICompatMacros.html">&ldquo;API 
        Compatibility Macros in HDF5.&rdquo;</a>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />





<!-- NEW PAGE -->

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Function Listing 7. Variable-length datatypes 
        </b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td>
        <b>C Function<br />Fortran Function</b>
        </td><td>&nbsp;</td>
        <td>
        <b>Purpose</b>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tvlen_create<br />h5tvlen_create_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Creates a new variable-length datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tis_variable_str<br />h5tis_variable_str_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Determines whether datatype is a variable-length string.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />





<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Function Listing 8. Opaque datatypes 
        </b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td>
        <b>C Function<br />Fortran Function</b>
        </td><td>&nbsp;</td>
        <td>
        <b>Purpose</b>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tset_tag<br />h5tset_tag_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Tags an opaque datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Tget_tag<br />h5tget_tag_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Gets the tag associated with an opaque datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />




<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Function Listing 9. Conversions between datatype and text 
        </b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td>
        <b>C Function<br />Fortran Function</b>
        </td><td>&nbsp;</td>
        <td>
        <b>Purpose</b>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5LTtext_to_dtype<br />(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Creates a datatype from a text description.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5LTdtype_to_text<br />(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Generates a text description of a datatype.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />



<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Function Listing 10. Datatype creation property list 
        functions (H5P)</b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td>
        <b>C Function<br />Fortran Function</b>
        </td><td>&nbsp;</td>
        <td>
        <b>Purpose</b>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_char_encoding<br />h5pset_char_encoding_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the character encoding used to encode a string. 
        Use to set ASCII or UTF-8 character encoding for object names.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_char_encoding<br />h5pget_char_encoding_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the character encoding used to create a string. 
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />




<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Function Listing 11. Datatype access property list 
        functions (H5P)</b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td>
        <b>C Function<br />Fortran Function</b>
        </td><td>&nbsp;</td>
        <td>
        <b>Purpose</b>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_type_conv_cb<br />(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets user-defined datatype conversion callback function.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_type_conv_cb<br />(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Gets user-defined datatype conversion callback function. 
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />





  
<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="Pmodel">
<div align=right>
<a href="#TOP"><font size="-1">(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<!-- NEW PAGE -->
<a name="Pmodel">
<h3 class=pagebefore>6.4. The Programming Model</h3>
</a>
 
<h4>6.4.1. Introduction</h4>

  <p>The HDF5 Library implements an object-oriented model of datatypes. HDF5 
  datatypes 
  are organized as a logical set of base types, or datatype classes. The HDF5 
  Library manages datatypes as objects. The HDF5 datatype API manipulates the 
  datatype objects through C function calls. The figure below shows the 
  abstract view 
  of the datatype object. The table below shows the methods (C functions) 
  that operate on datatype objects. New datatypes can be created from 
  scratch or copied from existing datatypes.</p>


<table width="550" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>

        <table align="center" border="1">
            <tr>
                <td valign="middle" align="center"><code>Datatype</code></td>
                </tr>
            <tr>
                <td valign="middle" align="left">
                <code>&nbsp;size:int?<br />
                &nbsp;byteOrder:BOtype</code></td>
                </tr>
            <tr>
                <td valign="middle" align="left">
                <code>&nbsp;open(hid_t loc, char *, name):return hid_t<br />
                &nbsp;copy(hid_t tid) return hid_t<br />
                &nbsp;create(hid_class_t&nbsp;clss,&nbsp;size_t&nbsp;size)
                &nbsp;return&nbsp;hid_t&nbsp;</code>
                </td>
                </tr>
            </table>
        </td></tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 5. The datatype object</b>
        <hr color="green" size="3"/></td></tr>
</table>
<br />
<br />


<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 8. General operations on datatype objects</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="50%"><b>API Function</b></td>
        <td width="50%"><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>hid_t H5Tcreate (H5T_class_t 
        <i>class</i>, size_t <i>size</i>)</code></td>
        <td>Create a new datatype object of 
        datatype class <i>class</i>. The following datatype classes are 
        supported with this function: 
        <ul>
            <li><code>H5T_COMPOUND</code></li>
            <li><code>H5T_OPAQUE</code> </li>
            <li><code>H5T_ENUM </code></li>
        </ul>
        Other datatypes are created with <code>H5Tcopy()</code>.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>hid_t H5Tcopy (hid_t <i>type</i>)
        </code></td>
        <td>Obtain a modifiable transient datatype 
        which is a copy of <i>type</i>. If <i>type</i> is a dataset 
        identifier then the type returned is a modifiable transient copy 
        of the datatype of the specified dataset. </td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>hid_t H5Topen (hid_t <i>location</i>, <br />
        const char *<i>name</i>, H5P_DEFAULT)</code></td>
        <td>Open a committed datatype. The 
        committed datatype returned by this function is read-only.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>htri_t H5Tequal (hid_t <i>type1</i>, <br />
        hid_t <i>type2</i>)</code></td>
        <td>Determines if two types are equal. </td>
        </tr>
<!-- NEW PAGE -->
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tclose (hid_t <i>type</i>)
        </code></td>
        <td>Releases resources associated with a 
        datatype obtained from <code>H5Tcopy</code>, <code>H5Topen</code>, or 
        <code>H5Tcreate</code>. It is illegal to close an 
        immutable transient datatype (e.g., predefined types).</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tcommit (hid_t 
        <i>location</i>, const char *<i>name</i>, hid_t <i>type</i>, 
        H5P_DEFAULT, H5P_DEFAULT, <br />H5P_DEFAULT)</code></td>
        <td>Commit a transient datatype (not immutable) 
        to a file to become a committed datatype. Committed datatypes can be shared.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>htri_t H5Tcommitted (hid_t 
        <i>type</i>)</code></td>
        <td>Test whether the datatype is 
        transient or committed (named).</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tlock (hid_t 
        <i>type</i>)</code></td>
        <td>Make a transient datatype immutable 
        (read-only and not closable). Predefined types are locked.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />

  <p>In order to use a datatype, the object must be created 
  (<code>H5Tcreate</code>), or a reference obtained by cloning from an 
  existing type (<code>H5Tcopy</code>), or opened (<code>H5Topen</code>). 
  In addition, a reference to the datatype of a dataset or attribute 
  can be obtained with <code>H5Dget_type</code> or 
  <code>H5Aget_type</code>. For composite datatypes a reference 
  to the datatype for members or base types can be obtained 
  (<code>H5Tget_member_type</code>, <code>H5Tget_super</code>). 
  When the datatype object is no longer needed, the reference is 
  discarded with <code>H5Tclose</code>. </p>

  <p>Two datatype objects can be tested to see if they are the same with 
  <code>H5Tequal</code>. This function returns true if the two datatype 
  references refer to the same datatype object. However, if two datatype 
  objects define equivalent datatypes (the same datatype class and 
  datatype properties), they will not be considered &lsquo;equal&rsquo;.</p>
  
  <p>A datatype can be written to the file as a first class object 
  (<code>H5Tcommit</code>). This is a committed datatype and can be used 
  in the same way as any other datatype.</p>


<h4>6.4.2. Discovery of Datatype Properties</h4>
  
  <p>Any HDF5 datatype object can be queried to discover all of its 
  datatype properties. For each datatype class, there are a set of 
  API functions to retrieve the datatype properties for this class. </p>

<h4>6.4.2.1. Properties of Atomic Datatypes</h4>
  
  <p>Table 9 lists the functions to discover the properties of atomic 
  datatypes. Table 10 lists the queries relevant to specific numeric 
  types. Table 11 gives the properties for atomic string datatype, and 
  Table 12 gives the property of the opaque datatype.</p>

<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 9. Functions to discover properties of atomic datatypes</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="50%"><b>Functions</b></td>
        <td width="50%"><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_class_t H5Tget_class (hid_t 
        <i>type</i>)</code></td>
        <td>The datatype class: <code>H5T_INTEGER, 
        H5T_FLOAT, H5T_STRING, or H5T_BITFIELD, H5T_OPAQUE, 
        H5T_COMPOUND, H5T_REFERENCE, H5T_ENUM, H5T_VLEN, H5T_ARRAY</code></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>size_t H5Tget_size 
        (hid_t <i>type</i>)</code></td>
        <td>The total size of the element in bytes, including padding 
        which may appear on either side of the actual value.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_order_t H5Tget_order 
        (hid_t <i>type</i>)</code></td>
        <td>The byte order describes how the bytes of the datatype are 
        laid out in memory. If the lowest memory address contains the 
        least significant byte of the datum then it is 
        said to be <i>little-endian</i> or <code>H5T_ORDER_LE</code>. If 
        the bytes are in the opposite order then they are said to be 
        <i>big-endian</i> or <code>H5T_ORDER_BE.</code></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>size_t H5Tget_precision 
        (hid_t <i>type</i>)</code></td>
        <td>The <code>precision</code> property identifies the number 
        of significant bits of a datatype and the 
        <code>offset</code> property (defined below) identifies its location. 
        Some datatypes occupy more bytes than what is needed to store the 
        value. For instance, a <code>short</code> on a Cray is 32 significant 
        bits in an eight-byte field.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>int H5Tget_offset (hid_t <i>type</i>)</code></td>
        <td>The <code>offset</code> property defines the bit location 
        of the least significant bit of a bit 
        field whose length is <code>precision</code>.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tget_pad 
        (hid_t <i>type</i>, H5T_pad_t <i>*lsb</i>, H5T_pad_t 
        <i>*msb</i>)</code></td>
        <td>Padding is the bits of a data element 
        which are not significant as defined by the <code>precision</code> 
        and <code>offset</code> properties. Padding in the low-numbered 
        bits is <i>lsb</i> padding and padding in the high-numbered 
        bits is <i>msb</i> padding. Padding bits can be set to zero 
        (<code>H5T_PAD_ZERO</code>) or one (<code>H5T_PAD_ONE</code>).</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />

<!-- NEW PAGE -->

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 10. Functions to discover properties of atomic 
        numeric datatypes</b> </td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="50%"><b>Functions</b></td>
        <td width="50%"><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_sign_t H5Tget_sign 
        (hid_t <i>type</i>)</code></td>
        <td><b>(INTEGER)</b> Integer data can be signed two&rsquo;s 
        complement (<code>H5T_SGN_2</code>) 
        or unsigned (<code>H5T_SGN_NONE</code>).</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tget_fields 
        (hid_t <i>type</i>, size_t *<i>spos</i>, size_t *<i>epos</i>, 
        size_t *<i>esize</i>, size_t *<i>mpos</i>, 
        size_t *<i>msize</i>)</code> </td>
        <td><b>(FLOAT)</b> A floating-point 
        data element has bit fields which are the exponent and mantissa 
        as well as a mantissa sign bit. These properties define the 
        location (bit position of least significant bit of the field) 
        and size (in bits) of each field. The sign bit is always of 
        length one and none of the fields are allowed to overlap.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>size_t H5Tget_ebias 
        (hid_t <i>type</i>)</code></td>
        <td><b>(FLOAT)</b> The exponent is stored as a non-negative 
        value which is <code>ebias</code> larger than the true exponent. </td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_norm_t H5Tget_norm 
        (hid_t <i>type</i>)</code></td>
        <td><b>(FLOAT)</b> This property describes the normalization 
        method of the mantissa. 
        <ul>
            <li><code>H5T_NORM_MSBSET</code>: the mantissa is shifted left 
            (if non-zero) until the first bit after the radix point is 
            set and the exponent is adjusted accordingly. All bits of 
            the mantissa after the radix point are stored. </li>
            <li><code>H5T_NORM_IMPLIED</code>: the mantissa is shifted left \ 
            (if non-zero) until the first bit after the radix point is set 
            and the exponent is adjusted accordingly. The first bit after 
            the radix point is not stored since it&rsquo;s always set. </li>
            <li><code>H5T_NORM_NONE</code>: the fractional part of the 
            mantissa is stored without normalizing it. </li>
        </ul></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_pad_t H5Tget_inpad 
        (hid_t <i>type</i>)</code></td>
        <td><b>(FLOAT)</b> If any internal bits (that is, bits between 
        the sign bit, the mantissa field, and the exponent field but 
        within the precision field) are unused, then they will be 
        filled according to the value of this property. The padding can 
        be: <code>H5T_PAD_NONE</code>, <code>H5T_PAD_ZERO</code> 
        or <code>H5T_PAD_ONE</code>.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />

<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 11. Functions to discover properties of atomic 
        string datatypes</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="50%"><b>Functions</b></td>
        <td width="50%"><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_cset_t H5Tget_cset 
        (hid_t <em>type</em>)</code></td>
        <td>Two character sets are currently 
        supported: ASCII (<code>H5T_CSET_ASCII</code>) and UTF-8 
        (<code>H5T_CSET_UTF8</code>).</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_str_t H5Tget_strpad 
        (hid_t <em>type</em>)</code></td>
        <td>The string datatype has a fixed 
        length, but the string may be shorter than the length. This 
        property defines the storage mechanism for the left over bytes. 
        The options are: <code>H5T_STR_NULLTERM</code>, 
        <code>H5T_STR_NULLPAD</code>, or <code>H5T_STR_SPACEPAD</code>.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 12. Functions to discover properties of atomic opaque 
        datatypes</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="50%"><b>Functions</b></td>
        <td  width="50%"><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>char *H5Tget_tag(hid_t type_id)</code></td>
        <td>A user-defined string.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />


<h4><em>6.4.2.2. Properties of Composite Datatypes</em></h4>

  <p>The composite datatype classes can also be analyzed to discover their 
  datatype properties and the datatypes that are members or base types 
  of the composite datatype. The member or base type can, in turn, be 
  analyzed. The table below lists the functions that can access the 
  datatype properties of the different composite datatypes.</p>
  
<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 13. Functions to discover properties of composite datatypes</b>
        </td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="50%"><b>Functions</b></td>
        <td width="50%"><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>int H5Tget_nmembers(hid_t type_id)</code></td>
        <td><b>(COMPOUND)</b>The number of fields in the compound 
        datatype.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5T_class_t H5Tget_member_class<br />
        (hid_t cdtype_id, unsigned member_no)</code></td>
        <td><b>(COMPOUND)</b> The datatype class of compound datatype 
        member <code>member_no</code>.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>char * H5Tget_member_name
        (hid_t type_id, unsigned field_idx)</code></td>
        <td><b>(COMPOUND)</b> The name of field <code>field_idx</code> 
        of a compound datatype.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>size_t H5Tget_member_offset
        (hid_t type_id, unsigned memb_no)</code></td>
        <td><b>(COMPOUND)</b> The byte offset 
        of the beginning of a field within a compound datatype.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>hid_t H5Tget_member_type
        (hid_t type_id, unsigned field_idx)</code></td>
        <td><b>(COMPOUND)</b> The datatype of the specified member.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>int H5Tget_array_ndims
        (hid_t adtype_id)</code></td>
        <td><b>(ARRAY)</b> The number of dimensions (rank) of the array 
        datatype object.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>int H5Tget_array_dims
        (hid_t adtype_id, hsize_t *dims[])</code></td>
        <td><b>(ARRAY)</b> The sizes of the dimensions and the dimension 
        permutations of the array datatype object.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>hid_t H5Tget_super(hid_t type)
        </code></td>
        <td><b>(ARRAY, VL, ENUM)</b>The base datatype from which the 
        datatype type is derived.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tenum_nameof(hid_t type <br />
        void *value, char *name, size_t size)</code></td>
        <td><b>(ENUM)</b> The symbol name 
        that corresponds to the specified value of the enumeration datatype</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tenum_valueof(hid_t type <br />
        char *name, void *value)</code></td>
        <td><b>(ENUM)</b> The value that corresponds to the specified 
        name of the enumeration datatype</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tget_member_value<br />
        (hid_t type unsigned memb_no, <br />void *value)</code></td>
        <td><b>(ENUM)</b> The value of the 
        enumeration datatype member <code>memb_no</code></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />


<!-- NEW PAGE -->
<h4>6.4.3. Definition of Datatypes</h4>
  
  <p>The HDF5 Library enables user programs to create and modify datatypes. The 
  essential steps are: 

  <ol>
    <li>a) Create a new datatype object of a specific composite datatype class, 
      or <br />
      b) Copy an existing atomic datatype object</li>
    <li>Set properties of the datatype object</li>
    <li>Use the datatype object</li>
    <li>Close the datatype object</li>
  </ol>
  
  <p>To create a user-defined atomic datatype, the procedure is to clone 
    a predefined datatype of the appropriate datatype class 
    (<code>H5Tcopy</code>), and then set the datatype properties appropriate 
    to the datatype class. The table below shows how to create a datatype 
    to describe a 1024-bit unsigned integer.</p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  hid_t new_type = H5Tcopy (H5T_NATIVE_INT);
  H5Tset_precision(new_type, 1024);
  H5Tset_sign(new_type, H5T_SGN_NONE);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 5. Create a new datatype</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />
  
  <p>Composite datatypes are created with a specific API call for each datatype 
  class. The table below shows the creation method for each datatype class. A 
  newly created 
  datatype cannot be used until the datatype properties are set. For example, 
  a newly created compound datatype has no members and cannot be used.</p>



<table width="400" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 14. Functions to create each datatype class</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="50%"><b>Datatype Class</b></td>
        <td width="50%"><b>Function to Create</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>COMPOUND</td>
        <td><code>H5Tcreate</code></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>OPAQUE</td>
        <td><code>H5Tcreate</code></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>ENUM</td>
        <td><code>H5Tenum_create</code></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>ARRAY</td>
        <td><code>H5Tarray_create</code></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>VL</td>
        <td><code>H5Tvlen_create</code></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />

  <p>Once the datatype is created and the datatype properties set, the datatype 
  object can be used. </p>
  
  <p>Predefined datatypes are defined by the library during initialization 
  using the same mechanisms as described here. Each predefined datatype is 
  locked (<code>H5Tlock</code>), so that it cannot be changed or destroyed. 
  User-defined datatypes may also be locked using <code>H5Tlock</code>. </p>

<!-- NEW PAGE -->
<h4><em>6.4.3.1. User-defined Atomic Datatypes</em></h4>
  
  <p>Table 15 summarizes the API methods that set properties of atomic 
  types. Table 16 shows properties specific to numeric types, Table 17 
  shows properties specific to the string datatype class. Note that 
  offset, pad, etc. do not apply to strings. Table 18 shows the specific 
  property of the OPAQUE datatype class.</p>


<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 15. API methods that set properties of atomic datatypes</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="50%"><b>Functions</b></td>
        <td width="50%"><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tset_size (hid_t <i>type</i>, 
        <br />size_t <i>size</i>)</code></td>
        <td>Set the total size of the element 
        in bytes. This includes padding which may appear on either side of the 
        actual value. If this property is reset to a smaller value which 
        would cause the significant part of the data to extend beyond the 
        edge of the datatype, then the offset property is decremented a 
        bit at a time. If the offset reaches zero and the significant 
        part of the data still extends beyond the edge of the datatype 
        then the precision property is decremented a bit at a time. 
        Decreasing the size of a datatype may fail if the 
        <code>H5T_FLOAT</code> bit fields would extend beyond the significant 
        part of the type. </td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tset_order 
        (hid_t <i>type</i>, H5T_order_t <i>order</i>)</code></td>
         <td>Set the byte order to little-endian 
        (<code>H5T_ORDER_LE</code>) or big-endian (<code>H5T_ORDER_BE</code>).</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tset_precision 
        (hid_t <i>type</i>, size_t <i>precision</i>)</code></td>
        <td>Set the number of significant bits 
        of a datatype. The <code>offset</code> property (defined below) 
        identifies its location. The size property defined above represents 
        the entire size (in bytes) of the datatype. If the precision is 
        decreased then padding bits are inserted on the MSB side of the 
        significant bits (this will fail for <code>H5T_FLOAT</code> types 
        if it results in the sign, mantissa, or exponent bit field extending 
        beyond the edge of the significant bit field). On the other hand, 
        if the precision is increased so that it &ldquo;hangs over&rdquo; 
        the edge of the total size then the offset property is decremented 
        a bit at a time. If the offset reaches zero and the significant 
        bits still hang over the edge, then the total size is increased 
        a byte at a time. </td>
        </tr>
<!-- NEW PAGE -->
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tset_offset 
        (hid_t <i>type</i>, size_t <i>offset</i>)</code></td>
        <td>Set the bit location of the least 
        significant bit of a bit field whose length is <code>precision</code>. 
        The bits of the entire data are numbered beginning at zero at the 
        least significant bit of the least significant byte (the byte at 
        the lowest memory address for a little-endian type or the byte 
        at the highest address for a big-endian type). The offset property 
        defines the bit location of the least significant bit of a bit field 
        whose length is precision. If the offset is increased so the 
        significant bits &ldquo;hang over&rdquo; the edge of the datum, then 
        the size property is automatically incremented.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tset_pad (hid_t 
        <i>type</i>, H5T_pad_t <i>lsb</i>, H5T_pad_t <i>msb</i>)</code></td>
        <td>Set the padding to zeros 
        (<code>H5T_PAD_ZERO</code>) or ones (<code>H5T_PAD_ONE</code>). Padding 
        is the bits of a data element which are not significant as defined 
        by the <code>precision</code> and <code>offset</code> properties. 
        Padding in the low-numbered bits is <code><i>lsb</i></code> 
        padding and padding in the high-numbered bits is 
        <code><i>msb</i></code> padding. </td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />


<!-- NEW PAGE -->


<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 16. API methods that set properties of numeric datatypes</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="50%"><b>Functions</b></td>
        <td width="50%"><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tset_sign 
        (hid_t <i>type</i>, H5T_sign_t <i>sign</i>)</code></td>
        <td><b>(INTEGER)</b> Integer 
        data can be signed two&rsquo;s complement (<code>H5T_SGN_2</code>) 
        or unsigned (<code>H5T_SGN_NONE</code>).</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tset_fields 
        (hid_t <i>type</i>, size_t <i>spos</i>, size_t <i>epos</i>, 
        size_t <i>esize</i>, size_t <i>mpos</i>, size_t <i>msize</i>)
        </code></td>
        <td><b>(FLOAT)</b> Set the 
        properties define the location (bit position of least significant 
        bit of the field) and size (in bits) of each field. The sign bit 
        is always of length one and none of the fields are allowed to overlap.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tset_ebias (hid_t <i>type</i>, 
        size_t <i>ebias</i>)</code></td>
        <td><b>(FLOAT)</b> The exponent 
        is stored as a non-negative value which is <code>ebias</code> larger 
        than the true exponent.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tset_norm 
        (hid_t <i>type</i>, H5T_norm_t <i>norm</i>)</code></td>
        <td><b>(FLOAT)</b> This 
        property describes the normalization method of the mantissa. 
        <ul>
            <li><code>H5T_NORM_MSBSET</code>: the mantissa is shifted left 
            (if non-zero) until the first bit after the radix point is set and 
            the exponent is adjusted accordingly. All bits of the mantissa 
            after the radix point are stored. </li>
            <li><code>H5T_NORM_IMPLIED</code>: the mantissa is shifted left 
            (if non-zero) until the first bit after the radix point is set and 
            the exponent is adjusted accordingly. The first bit after the 
            radix point is not stored since it is always set. </li>
            <li><code>H5T_NORM_NONE</code>: the fractional part of the 
            mantissa is stored without normalizing it. </li></ul></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tset_inpad 
        (hid_t <i>type</i>, H5T_pad_t <i>inpad</i>)</code></td>
        <td><b>(FLOAT)</b> If any 
        internal bits (that is, bits between the sign bit, the mantissa field, 
        and the exponent field but within the precision field) are unused, 
        then they will be filled according to the value of this property. 
        The padding can be: <code>H5T_PAD_NONE</code>, <code>H5T_PAD_ZERO</code> 
        or <code>H5T_PAD_ONE</code>.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />

<!-- NEW PAGE -->

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 17. API methods that set properties of string datatypes</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="50%"><b>Functions</b></td>
        <td width="50%"><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tset_size (hid_t <i>type</i>, 
        <br />size_t <i>size</i>)</code></td>
        <td>Set the length of the string, in bytes. 
        The precision is automatically set to 8*<code>size</code>.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tset_precision 
        (hid_t <i>type</i>, size_t <i>precision</i>)</code></td>
        <td>The precision must be a multiple of 8.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tset_cset
        (hid_t type_id, H5T_cset_t cset )</code></td>
        <td>Two character sets are currently 
        supported: ASCII (<code>H5T_CSET_ASCII</code>) and UTF-8 
        (<code>H5T_CSET_UTF8</code>).</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tset_strpad
        (hid_t type_id, H5T_str_t strpad )</code></td>
        <td>The string datatype has a fixed 
        length, but the string may be shorter than the length. This property 
        defines the storage mechanism for the left over bytes. The method 
        used to store character strings differs with the programming language: 
        <ul>
            <li>C usually null terminates strings </li>
            <li>Fortran left-justifies and space-pads strings</li>
        </ul>
        <p>Valid string padding values, as passed in the parameter strpad, 
        are as follows: </p>
        <dl>
            <dt><code>H5T_STR_NULLTERM</code> (0) 
            <dd>Null terminate (as C does) 
            <dt><code>H5T_STR_NULLPAD</code> (1) 
            <dd>Pad with zeros 
            <dt><code>H5T_STR_SPACEPAD</code> (2) 
            <dd>Pad with spaces (as FORTRAN does).
            </dl></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />


<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 18. API methods that set properties of opaque datatypes</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="50%"><b>Functions</b></td>
        <td width="50%"><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tset_tag (hid_t type_id 
        <br />const char *tag )</code></td>
        <td>Tags the opaque datatype type_id 
        with an ASCII identifier tag.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />


<!-- NEW PAGE -->
<h4>Examples</h4>
  
  <p>The example below shows how to create a 128-bit little-endian signed 
  integer type. Increasing the precision of a type automatically increases 
  the total size. Note that the proper procedure is to begin from a type 
  of the intended datatype class which in this case is a 
  <code>NATIVE INT</code>.</p>

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  hid_t new_type = H5Tcopy (H5T_NATIVE_INT);
  H5Tset_precision (new_type, 128);
  H5Tset_order (new_type, H5T_ORDER_LE);</pre> </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 6. Create a new 128-bit little-endian signed integer 
        datatype</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />


  <p>The figure below shows the storage layout as the type is defined. The 
  <code>H5Tcopy</code> creates a datatype that is the same as 
  <code>H5T_NATIVE_INT</code>. In this example, suppose this is a 32-bit 
  big-endian number (Figure a). The precision is set to 128 bits, 
  which automatically extends the size to 8 bytes (Figure b). Finally, 
  the byte order is set to little-endian (Figure c).</p>


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <table align="center" border="0" width="100%">
        <tr><td>

        <table border="1" align="left">
            <tr>
                <td valign="middle" align="center"><code>Byte 0</code></td>
                <td valign="middle" align="center"><code>Byte 1</code></td>
                <td valign="middle" align="center"><code>Byte 2</code></td>
                <td valign="middle" align="center"><code>Byte 3</code></td>
                </tr>
            <tr>
                <td valign="middle" align="center"><code>01234567</code></td>
                <td valign="middle" align="center"><code>89012345</code></td>
                <td valign="middle" align="center"><code>67890123</code></td>
                <td valign="middle" align="center"><code>45678901</code></td>
                </tr>
                </table>

        </td></tr>
        <tr><td>
        
        <table border="0" align="left">
            <tr>
            <td>a) The <code>H5T_NATIVE_INT</code> datatype<br />&nbsp;</td></tr>
            </table>

        </td></tr>
        <tr><td>
      
        <table border="1" align="left">
            <tr>
            <td valign="middle" align="center"><code>Byte 0</code></td>
            <td valign="middle" align="center"><code>Byte 1</code></td>
            <td valign="middle" align="center"><code>Byte 2</code></td>
            <td valign="middle" align="center"><code>Byte 3</code></td>
            <td valign="middle" align="center"><code>Byte 4</code></td>
            <td valign="middle" align="center"><code>Byte 5</code></td>
            <td valign="middle" align="center"><code>Byte 6</code></td>
            <td valign="middle" align="center"><code>Byte 7</code></td>
            </tr>
            <tr>
            <td valign="middle" align="center"><code>01234567</code></td>
            <td valign="middle" align="center"><code>89012345</code></td>
            <td valign="middle" align="center"><code>67890123</code></td>
            <td valign="middle" align="center"><code>45678901</code></td>
            <td valign="middle" align="center"><code>23456789</code></td>
            <td valign="middle" align="center"><code>01234567</code></td>
            <td valign="middle" align="center"><code>89012345</code></td>
            <td valign="middle" align="center"><code>67890123</code></td>
            </tr>	
            </table>

        </td></tr>
        <tr><td>
	  
        <table border="0" align="left">
            <tr>
            <td>b) Precision is extended to 128-bits, and the size is 
            automatically adjusted.<br />&nbsp;</td></tr>
            </table>

        </td></tr>
        <tr><td>

        <table border="1" align="left">
            <tr>
            <td valign="middle" align="center"><code>Byte 0</code></td>
            <td valign="middle" align="center"><code>Byte 1</code></td>
            <td valign="middle" align="center"><code>Byte 2</code></td>
            <td valign="middle" align="center"><code>Byte 3</code></td>
            <td valign="middle" align="center"><code>Byte 4</code></td>
            <td valign="middle" align="center"><code>Byte 5</code></td>
            <td valign="middle" align="center"><code>Byte 6</code></td>
            <td valign="middle" align="center"><code>Byte 7</code></td>
            </tr>
            <tr>
            <td valign="middle" align="center"><code>01234567</code></td>
            <td valign="middle" align="center"><code>89012345</code></td>
            <td valign="middle" align="center"><code>67890123</code></td>
            <td valign="middle" align="center"><code>45678901</code></td>
            <td valign="middle" align="center"><code>23456789</code></td>
            <td valign="middle" align="center"><code>01234567</code></td>
            <td valign="middle" align="center"><code>89012345</code></td>
            <td valign="middle" align="center"><code>67890123</code></td>
            </tr>
            </table>

        </td></tr>
        <tr><td>

        <table border="0" align="left">
            <tr><td>c) The byte order is switched.</td></tr>
            </table>
        </td></tr>
        </table>
        </td></tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 6. The storage layout for a new 128-bit little-endian 
        signed integer datatype</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>The significant bits of a data element can be offset from the beginning of 
  the memory for that element by an amount of padding. The <code>offset</code> 
  property specifies the number of bits of padding that appear to the 
  &ldquo;right of&rdquo; the value. The table and figure below show how 
  a 32-bit unsigned integer with 16-bits of precision having the value 
  <code>0x1122</code> will be laid out in memory.</p>

<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="5" align="left" valign="bottom">
        <b>Table 19. Memory Layout for a 32-bit unsigned integer</b></td>
        </tr>
    <tr><td colspan="5"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td><b>Byte Position</b></td>
        <td><b>Big-Endian <br />Offset=0</b></td>
        <td><b>Big-Endian <br />Offset=16</b></td>
        <td><b>Little-Endian <br />Offset=0</b></td>
        <td><b>Little-Endian <br />Offset=16</b></td>
    <tr><td colspan="5"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>0:</td>
        <td>[pad]</td>
        <td>[0x11]</td>
        <td>[0x22]</td>
        <td>[pad]</td>
        </tr>
    <tr><td colspan="5"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>1:</td>
        <td>[pad]</td>
        <td>[0x22]</td>
        <td>[0x11]</td>
        <td>[pad]</td>
        </tr>
    <tr><td colspan="5"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>2:</td>
        <td>[0x11]</td>
        <td>[pad]</td>
        <td>[pad]</td>
        <td>[0x22]</td>
        </tr>
    <tr><td colspan="5"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>3:</td>
        <td>[0x22]</td>
        <td>[pad]</td>
        <td>[pad]</td>
        <td>[0x11]</td>
        </tr>
    <tr><td colspan="5"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />



<table width="400" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>

    <table align="center" border="0" width="100%">
        <tr>
        <td valign="middle" align="center">Big-Endian: Offset = 0</td>
        </tr>
        <tr><td>

        <table border="1" align="center">
            <tr>
            <td valign="middle" align="center"><code>Byte 0</code></td>
            <td valign="middle" align="center"><code>Byte 1</code></td>
            <td valign="middle" align="center"><code>Byte 2</code></td>
            <td valign="middle" align="center"><code>Byte 3</code></td>
            </tr>
            <tr>
            <td valign="middle" align="center"><code>01234567</code></td>
            <td valign="middle" align="center"><code>89012345</code></td>
            <td valign="middle" align="center"><code>67890123</code></td>
            <td valign="middle" align="center"><code>45678901</code></td>
            </tr>
            <tr>
            <td valign="middle" align="center"><code><em>PPPPPPPP</em></code></td>
            <td valign="middle" align="center"><code><em>PPPPPPPP</em></code></td>
            <td valign="middle" align="center"><code>00010001</code></td>
            <td valign="middle" align="center"><code>00100010</code></td>
            </tr>
            </table>

            </td></tr>
        <tr>
            <td valign="middle" align="center">&nbsp;<br />Big-Endian: Offset = 16</td>
            </tr>
        <tr>
            <td>
      
        <table border="1" align="center">
            <tr>
            <td valign="middle" align="center"><code>Byte 0</code></td>
            <td valign="middle" align="center"><code>Byte 1</code></td>
            <td valign="middle" align="center"><code>Byte 2</code></td>
            <td valign="middle" align="center"><code>Byte 3</code></td>
            </tr>
            <tr>
            <td valign="middle" align="center"><code>01234567</code></td>
            <td valign="middle" align="center"><code>89012345</code></td>
            <td valign="middle" align="center"><code>67890123</code></td>
            <td valign="middle" align="center"><code>45678901</code></td>
            </tr>
            <tr>
            <td valign="middle" align="center"><code>00010001</code></td>
            <td valign="middle" align="center"><code>00100010</code></td>
            <td valign="middle" align="center"><code><em>PPPPPPPP</em></code></td>
            <td valign="middle" align="center"><code><em>PPPPPPPP</em></code></td>
            </tr>	
            </table>

            </td></tr>
        <tr>
            <td valign="middle" align="center">&nbsp;<br />Little-Endian: 
            Offset = 0</td>
            </tr>

        <tr>
            <td>

        <table border="1" align="center">
            <tr>
            <td valign="middle" align="center"><code>Byte 0</code></td>
            <td valign="middle" align="center"><code>Byte 1</code></td>
            <td valign="middle" align="center"><code>Byte 2</code></td>
            <td valign="middle" align="center"><code>Byte 3</code></td>
            </tr>
            <tr>
            <td valign="middle" align="center"><code>01234567</code></td>
            <td valign="middle" align="center"><code>89012345</code></td>
            <td valign="middle" align="center"><code>67890123</code></td>
            <td valign="middle" align="center"><code>45678901</code></td>
            </tr>
            <tr>
            <td valign="middle" align="center"><code>00010001</code></td>
            <td valign="middle" align="center"><code>00100010</code></td>
            <td valign="middle" align="center"><code><em>PPPPPPPP</em></code></td>
            <td valign="middle" align="center"><code><em>PPPPPPPP</em></code></td>
            </tr>	
            </table>

            </td></tr>
        <tr>
            <td valign="middle" align="center">&nbsp;<br />Little-Endian: 
            Offset = 16</td>
            </tr>
        <tr>
            <td>
        <table border="1" align="center">
            <tr>
            <td valign="middle" align="center"><code>Byte 0</code></td>
            <td valign="middle" align="center"><code>Byte 1</code></td>
            <td valign="middle" align="center"><code>Byte 2</code></td>
            <td valign="middle" align="center"><code>Byte 3</code></td>
            </tr>
            <tr>
            <td valign="middle" align="center"><code>01234567</code></td>
            <td valign="middle" align="center"><code>89012345</code></td>
            <td valign="middle" align="center"><code>67890123</code></td>
            <td valign="middle" align="center"><code>45678901</code></td>
            </tr>
            <tr>
            <td valign="middle" align="center"><code><em>PPPPPPPP</em></code></td>
            <td valign="middle" align="center"><code><em>PPPPPPPP</em></code></td>
            <td valign="middle" align="center"><code>00010001</code></td>
            <td valign="middle" align="center"><code>00100010</code></td>
            </tr>
            </table>

            </td></tr>	  
        </table>&nbsp;

        </td></tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 7. Memory Layout for a 32-bit unsigned integer</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>If the offset is incremented then the total size is incremented also 
  if necessary to prevent significant bits of the value from hanging over 
  the edge of the datatype. </p>
  
  <p>The bits of the entire data are numbered beginning at zero at the 
  least significant bit of the least significant byte (the byte at the 
  lowest memory address for a little-endian type or the byte at the 
  highest address for a big-endian type). The <code>offset</code> 
  property defines the bit location of the least signficant bit of a 
  bit field whose length is <code>precision</code>. If the offset is 
  increased so the significant bits &ldquo;hang over&rdquo; the edge 
  of the datum, then the <code>size</code> property is automatically 
  incremented. </p>
  

  <p>To illustrate the properties of the integer datatype class, the example 
  below shows how to create a user-defined datatype that describes a 
  24-bit signed integer that starts on the third bit of a 32-bit word. 
  The datatype is specialized from a 32-bit integer, the <em>precision</em> 
  is set to 24 bits, and the <em>offset</em> is set to 3.</p>

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  hid_t dt;

  dt = H5Tcopy(H5T_SDT_I32LE);

  H5Tset_precision(dt, 24);
  H5Tset_offset(dt,3);
  H5Tset_pad(dt, H5T_PAD_ZERO, H5T_PAD_ONE);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 7. A user-defined datatype with a 24-bit signed integer</b> 
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>The figure below shows the storage layout for a data element. Note that 
  the unused bits in the offset will be set to zero and the unused bits at 
  the end will be 
  set to one, as specified in the <code>H5Tset_pad</code> call.</p>


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <br />
    <table border="1" align="center" width="67%">
        <tr>
            <td valign="middle" align="center"><code>Byte 0</code></td>
            <td valign="middle" align="center"><code>Byte 1</code></td>
            <td valign="middle" align="center"><code>Byte 2</code></td>
            <td valign="middle" align="center"><code>Byte 3</code></td>
            </tr>
        <tr>
            <td valign="middle" align="center"><code>01234567</code></td>
            <td valign="middle" align="center"><code>89012345</code></td>
            <td valign="middle" align="center"><code>67890123</code></td>
            <td valign="middle" align="center"><code>45678901</code></td>
            </tr>
        <tr>
            <td valign="middle" align="center"><code><strong><em>ooo</em></strong>00000</code></td>
            <td valign="middle" align="center"><code>00000000</code></td>
            <td valign="middle" align="center"><code>00000000</code></td>
            <td valign="middle" align="center"><code>00s<strong><em>ppppp</em></strong></code></td>
            </tr>
        <tr>
            <td valign="middle" align="center" colspan="4">
            <img src="Images/Dtypes_fig14.JPG">
            </td>
            </tr>
        </table>
        <br />
        <tr><td>
        </td>
        </tr>
  
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 8. A user-defined integer datatype a range of -1,048,583 
        to 1,048,584</b>
        <hr color="green" size="3"/></td>
  </tr>
</table>
<br />



  <p>To illustrate a user-defined floating point number, the example below 
  shows how to create a 24-bit floating point number that starts 5 bits 
  into a 4 byte word. The floating point number is defined to have a 
  mantissa of 19 bits (bits 5-23), an exponent of 3 bits (25-27), and 
  the sign bit is bit 28. (Note that this is an illustration of what 
  can be done and is not necessarily a floating point format that a 
  user would require.)</p>

<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  hid_t dt;

  dt = H5Tcopy(H5T_IEEE_F32LE);

  H5Tset_precision(dt, 24);
  H5Tset_fields (dt, 28, 25, 3, 5, 19);
  H5Tset_pad(dt, H5T_PAD_ZERO, H5T_PAD_ONE);
  H5Tset_inpad(dt, H5T_PAD_ZERO);</pre> </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 8. A user-defined 24-bit floating point datatype</b>
        <hr color="green" size="3"/></td>
  </tr>
</table>
<br />
<br />



<table width="500" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>

        <table border="1" align="center" width="67%">
            <tr>
            <td valign="middle" align="center"><code>Byte 0</code></td>
            <td valign="middle" align="center"><code>Byte 1</code></td>
            <td valign="middle" align="center"><code>Byte 2</code></td>
            <td valign="middle" align="center"><code>Byte 3</code></td>
            </tr>
            <tr>
            <td valign="middle" align="center"><code>01234567</code></td>
            <td valign="middle" align="center"><code>89012345</code></td>
            <td valign="middle" align="center"><code>67890123</code></td>
            <td valign="middle" align="center"><code>45678901</code></td>
            </tr>
            <tr>
            <td valign="middle" align="center"><code><strong><em>ooooo</em>
                </strong>mmm</code></td>
            <td valign="middle" align="center"><code>mmmmmmmm</code></td>
            <td valign="middle" align="center"><code>mmmmmmmm</code></td>
            <td valign="middle" align="center"><code><strong>i</strong>eees<strong>
                <em>ppp</em></strong></code></td>
            </tr>
            <tr>
            <td valign="middle" align="center" colspan="4">
            <img src="Images/Dtypes_fig16.JPG">
            </td>
            </tr>
            </table>

        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 9. A user-defined floating point datatype</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  
  <p>The figure above shows the storage layout of a data element for this 
  datatype. Note that there is an unused bit (24) between the mantissa and 
  the exponent. This bit is filled with the <em>inpad</em> value which 
  in this case is 0. </p>
  
  <p>The sign bit is always of length one and none of the fields are allowed 
  to overlap. When expanding a floating-point type one should set the 
  precision first; when decreasing the size one should set the field 
  positions and sizes first. </p>

<h4>6.4.3.2. Composite Datatypes</h4>
  
  <p>All composite datatypes must be user-defined; 
    there are no predefined composite datatypes. </p>

<h4>6.4.3.2.1. Compound Datatypes</h4>

  <p>The subsections below describe how to create a compound datatype 
    and how to write and read data of a compound datatype.

<h4>6.4.3.2.1.1. Defining Compound Datatypes</h4>
  
  <p>Compound datatypes are conceptually similar to a C struct or 
    Fortran derived types. The compound datatype defines a contiguous 
    sequence of bytes, which are formatted using one up to 2^16 datatypes 
    (members). A compound datatype may have any number of members, in 
    any order, and the members may have any datatype, including compound. 
    Thus, complex nested compound datatypes can be created. The total 
    size of the compound datatype is greater than or equal to the sum 
    of the size of its members, up to a maximum of 2^32 bytes. HDF5 does 
    not support datatypes with distinguished records or the equivalent 
    of C unions or Fortran EQUIVALENCE statements.</p>
  
  <p>Usually a C struct or Fortran derived type will be defined to hold 
    a data point in memory, and the offsets of the members in memory will 
    be the offsets of the struct members from the beginning of an instance 
    of the struct. The HDF5 C library provides a macro 
    <code>HOFFSET (s,m)</code> to calculate the member&rsquo;s offset. The HDF5 
    Fortran applications have to calculate offsets by using sizes of members 
    datatypes and by taking in consideration the order of members in the 
    Fortran derived type.</p>
    
<dl>
<dt><code>HOFFSET(s,m)</code>
  <dd>This macro computes the offset of member <em>m</em> within a struct 
    <em>s</em></dd>
<dt><code>offsetof(s,m)</code>
  <dd>This macro defined in <code>stddef.h</code> does exactly the same 
    thing as the <code>HOFFSET()</code> macro.</dd>
</dl>
    
  <p><em>Note for Fortran users</em>: Offsets of Fortran structure members 
    correspond to the offsets within a packed datatype (see explanation below) 
    stored in an HDF5 file.</p>
    
  <p>Each member of a compound datatype must have a descriptive name which 
    is the key used to uniquely identify the member within the compound 
    datatype. A member name in an HDF5 datatype does not necessarily have 
    to be the same as the name of the member in the C struct or Fortran 
    derived type, although this is often the case. Nor does one need to 
    define all members of the C struct or Fortran derived type in the HDF5 
    compound datatype (or vice versa).</p>
    
  <p>Unlike atomic datatypes which are derived from other atomic datatypes, 
    compound datatypes are created from scratch. First, one creates an empty 
    compound datatype and specifies its total size. Then members are added to 
    the compound datatype in any order. Each member type is inserted at a 
    designated offset. Each member has a name which is the key used to uniquely 
    identify the member within the compound datatype.</p>
    
  <p>The example below shows a way of creating an HDF5 C compound datatype to 
    describe a complex number. This is a structure with two components, 
    &ldquo;real&rdquo; and &ldquo;imaginary&rdquo;, and each component 
    is a double. An equivalent C struct whose type is defined by the 
    <code>complex_t</code> struct is shown.</p>


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  typedef struct {
      double re;   /*real part*/
      double im;   /*imaginary part*/
   } complex_t;

   hid_t complex_id = H5Tcreate (H5T_COMPOUND, sizeof (complex_t));
   H5Tinsert (complex_id, &ldquo;real&rdquo;, HOFFSET(complex_t,re),
            H5T_NATIVE_DOUBLE);
   H5Tinsert (complex_id, &ldquo;imaginary&rdquo;, HOFFSET(complex_t,im),
            H5T_NATIVE_DOUBLE);</pre> </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 9. A compound datatype for complex numbers in C</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>The example below shows a way of creating an HDF5 Fortran compound 
  datatype to describe a complex number. This is a Fortran derived type 
  with two components, &ldquo;real&rdquo; and &ldquo;imaginary&rdquo;, 
  and each component is DOUBLE PRECISION. An equivalent Fortran TYPE 
    whose type is defined by the TYPE <code>complex_t</code> is shown.</p>

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  TYPE complex_t
     DOUBLE PRECISION re   ! real part
     DOUBLE PRECISION im;  ! imaginary part
  END TYPE complex_t

  CALL h5tget_size_f(H5T_NATIVE_DOUBLE, re_size, error)
  CALL h5tget_size_f(H5T_NATIVE_DOUBLE, im_size, error)
  complex_t_size = re_size + im_size
  CALL h5tcreate_f(H5T_COMPOUND_F, complex_t_size, type_id)
  offset = 0
  CALL h5tinsert_f(type_id, &ldquo;real&rdquo;, offset, H5T_NATIVE_DOUBLE, error)
  offset = offset + re_size
  CALL h5tinsert_f(type_id, &ldquo;imaginary&rdquo;, offset, H5T_NATIVE_DOUBLE, error)</pre> </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 10. A compound datatype for complex numbers in Fortran</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

  <p><em>Important Note</em>: The compound datatype is created with a size 
    sufficient to hold all its members. In the C example above, the size of 
    the C struct and the <code>HOFFSET</code> macro are used as a convenient 
    mechanism to determine the appropriate size and offset. Alternatively, the 
    size and offset could be manually determined: the size can be set to 
    16 with &ldquo;real&rdquo; at offset 0 and &ldquo;imaginary&rdquo; at 
    offset 8. However, different platforms and compilers have different 
    sizes for &ldquo;double&rdquo; and may have alignment restrictions 
    which require additional padding within the structure. It is much 
    more portable to use the <code>HOFFSET</code> macro which assures 
    that the values will be correct for any platform.</p>
  
  <p>The figure below shows how the compound datatype would be laid out 
  assuming that <code>NATIVE_DOUBLE</code> are 64-bit numbers and that 
  there are no alignment requirements. The total size of the compound 
  datatype will be 16 bytes, the &ldquo;real&rdquo; component will 
  start at byte 0, and &ldquo;imaginary&rdquo; will start at byte 8.</p>


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>

      <table border="1" align="center" width="550">
	    <tr>
		  <td valign="top" align="right" rowspan="4" width="150">
		    <img src="Images/Dtypes_fig18_a.jpg">
		  </td>
	      <td valign="middle" align="center" width="100"><code>Byte 0</code></td>
		  <td valign="middle" align="center" width="100"><code>Byte 1</code></td>
		  <td valign="middle" align="center" width="100"><code>Byte 2</code></td>
		  <td valign="middle" align="center" width="100"><code>Byte 3</code></td>
	</tr>
		<tr>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		</tr>
	    <tr>
	      <td valign="middle" align="center"><code>Byte 4</code></td>
		  <td valign="middle" align="center"><code>Byte 5</code></td>
		  <td valign="middle" align="center"><code>Byte 6</code></td>
		  <td valign="middle" align="center"><code>Byte 7</code></td>
	</tr>
		<tr>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		</tr>
	    <tr>
		  <td valign="top" align="right" rowspan="4" width="150">
		    <img src="Images/Dtypes_fig18_b.jpg">
	      </td>
	      <td valign="middle" align="center"><code>Byte 8</code></td>
		  <td valign="middle" align="center"><code>Byte 9</code></td>
		  <td valign="middle" align="center"><code>Byte 10</code></td>
		  <td valign="middle" align="center"><code>Byte 11</code></td>
	</tr>
		<tr>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		</tr>
	    <tr>
	      <td valign="middle" align="center"><code>Byte 12</code></td>
		  <td valign="middle" align="center"><code>Byte 13</code></td>
		  <td valign="middle" align="center"><code>Byte 14</code></td>
		  <td valign="middle" align="center"><code>Byte 15</code></td>
	</tr>
		<tr>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		</tr>
      </table>
	  
	  <table align="center" border="0" width="550">
        <tr>
		  <td valign="top" align="right" width="150">&nbsp;</td>
		  <td valign="top" align="left" colspan="4">Total size of 
          compound datatype is 16 bytes</td>
	    </tr>
	  </table>
	  
    </td>
  </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 10. Layout of a compound datatype</b>
        <hr color="green" size="3"/></td>
  </tr>
</table>
<br />



  <p>The members of a compound datatype may be any HDF5 datatype 
    including the compound, array, and variable-length (VL) types. The 
    figure and example below show the memory layout and code 
    which creates a compound datatype composed of two complex 
    values, and each complex value is also a compound datatype as in the 
    figure above.</p>



<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>

	  <table border="1" align="center" width="550">
	    <tr>
		  <td valign="top" align="right" rowspan="4" width="150">
		  <img src="Images/Dtypes_fig19_a.jpg">
		  </td>
	      <td valign="middle" align="center" width="100"><code>Byte 0</code></td>
		  <td valign="middle" align="center" width="100"><code>Byte 1</code></td>
		  <td valign="middle" align="center" width="100"><code>Byte 2</code></td>
		  <td valign="middle" align="center" width="100"><code>Byte 3</code></td>
	    </tr>
		<tr>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		</tr>
	    <tr>
	      <td valign="middle" align="center"><code>Byte 4</code></td>
		  <td valign="middle" align="center"><code>Byte 5</code></td>
		  <td valign="middle" align="center"><code>Byte 6</code></td>
		  <td valign="middle" align="center"><code>Byte 7</code></td>
	    </tr>
		<tr>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		</tr>
	    <tr>
		  <td valign="top" align="right" rowspan="4">
		  <img src="Images/Dtypes_fig19_b.jpg" align="middle">
		  </td>
	      <td valign="middle" align="center"><code>Byte 8</code></td>
		  <td valign="middle" align="center"><code>Byte 9</code></td>
		  <td valign="middle" align="center"><code>Byte 10</code></td>
		  <td valign="middle" align="center"><code>Byte 11</code></td>
	    </tr>
		<tr>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		</tr>
	    <tr>
	      <td valign="middle" align="center"><code>Byte 12</code></td>
		  <td valign="middle" align="center"><code>Byte 13</code></td>
		  <td valign="middle" align="center"><code>Byte 14</code></td>
		  <td valign="middle" align="center"><code>Byte 15</code></td>
	    </tr>
		<tr>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		</tr>
	    <tr>
		  <td valign="top" align="right" rowspan="4">
		  <img src="Images/Dtypes_fig19_c.jpg"></td>
	      <td valign="middle" align="center" width="100"><code>Byte 16</code></td>
		  <td valign="middle" align="center" width="100"><code>Byte 17</code></td>
		  <td valign="middle" align="center" width="100"><code>Byte 18</code></td>
		  <td valign="middle" align="center" width="100"><code>Byte 19</code></td>
	    </tr>
		<tr>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		</tr>
	    <tr>
	      <td valign="middle" align="center"><code>Byte 20</code></td>
		  <td valign="middle" align="center"><code>Byte 21</code></td>
		  <td valign="middle" align="center"><code>Byte 22</code></td>
		  <td valign="middle" align="center"><code>Byte 23</code></td>
	    </tr>
		<tr>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		  <td valign="middle" align="center"><code><strong>rrrrrrrr</strong></code></td>
		</tr>
	    <tr>
		  <td valign="top" align="right" rowspan="4">
		  <img src="Images/Dtypes_fig19_d.jpg"></td>
	      <td valign="middle" align="center"><code>Byte 24</code></td>
		  <td valign="middle" align="center"><code>Byte 25</code></td>
		  <td valign="middle" align="center"><code>Byte 26</code></td>
		  <td valign="middle" align="center"><code>Byte 27</code></td>
	    </tr>
		<tr>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		</tr>
	    <tr>
	      <td valign="middle" align="center"><code>Byte 28</code></td>
		  <td valign="middle" align="center"><code>Byte 29</code></td>
		  <td valign="middle" align="center"><code>Byte 30</code></td>
		  <td valign="middle" align="center"><code>Byte 31</code></td>
	    </tr>
		<tr>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		  <td valign="middle" align="center"><code><strong>iiiiiiii</strong></code></td>
		</tr>
	  </table>
	  
	  <table align="center" width="550">
	    <tr>
		  <td width="150">&nbsp;</td>
		  <td>Total size of compound datatype is 32 bytes.</td>
	    </tr>
	  </table>
    </td>
  </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 11. Layout of a compound datatype nested within a compound 
        datatype</b>
        <hr color="green" size="3"/></td>
  </tr>
</table>
<br />
<br />


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  typedef struct {
     complex_t x;
     complex_t y;
  } surf_t;

  hid_t complex_id, surf_id; /*hdf5 datatypes*/

  complex_id = H5Tcreate (H5T_COMPOUND, sizeof(complex_t));
  H5Tinsert (complex_id, &ldquo;re&rdquo;, HOFFSET(complex_t,re),
            H5T_NATIVE_DOUBLE);
  H5Tinsert (complex_id, &ldquo;im&rdquo;, HOFFSET(complex_t,im),
            H5T_NATIVE_DOUBLE);

  surf_id = H5Tcreate (H5T_COMPOUND, sizeof(surf_t));
  H5Tinsert (surf_id, &ldquo;x&rdquo;, HOFFSET(surf_t,x), complex_id);
  H5Tinsert (surf_id, &ldquo;y&rdquo;, HOFFSET(surf_t,y), complex_id);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 11. Code for a compound datatype nested within a compound 
        datatype</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>Note that a similar result could be accomplished by creating a 
    compound datatype and inserting four fields. See the figure below. This 
    results in the same layout as the figure above. The difference 
    would be how the fields are addressed. In the first case, the 
    real part of &lsquo;y&rsquo; is called &lsquo;y.re&rsquo;; in the 
    second case it is &lsquo;y-re&rsquo;.</p>



<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  typedef struct {
      complex_t x;
      complex_t y;
   } surf_t;

  hid_t surf_id = H5Tcreate (H5T_COMPOUND, sizeof(surf_t));
  H5Tinsert (surf_id, &ldquo;x-re&rdquo;, HOFFSET(surf_t,x.re),
            H5T_NATIVE_DOUBLE);
  H5Tinsert (surf_id, &ldquo;x-im&rdquo;, HOFFSET(surf_t,x.im),
            H5T_NATIVE_DOUBLE);
  H5Tinsert (surf_id, &ldquo;y-re&rdquo;, HOFFSET(surf_t,y.re),
            H5T_NATIVE_DOUBLE);
  H5Tinsert (surf_id, &ldquo;y-im&rdquo;, HOFFSET(surf_t,y.im),
            H5T_NATIVE_DOUBLE);        </pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 12. Another compound datatype nested within a 
        compound datatype </b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>The members of a compound datatype do not always 
    fill all the bytes. The <code>HOFFSET</code> macro 
    assures that the members will be laid out according 
    to the requirements of the platform and language. 
    The example below shows an example of a C struct which requires 
    extra bytes of padding on many platforms. The second 
    element, &lsquo;b&rsquo;, is a 1-byte character followed by an 8 
    byte double, &lsquo;c&rsquo;. On many systems, the 8-byte value must 
    be stored on a 4- or 8-byte boundary. This requires the struct 
    to be larger than the sum of the size of its elements. </p>
  

  <p>In the example below, <code>sizeof</code> and 
    <code>HOFFSET</code> are used to assure that the 
    members are inserted at the correct offset to match the 
    memory conventions of the platform. The figure below shows how 
    this data element would be stored in memory, assuming the 
    double must start on a 4-byte boundary. Notice the extra 
    bytes between &lsquo;b&rsquo; and &lsquo;c&rsquo;.</p>


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
<pre>
  typedef struct s1_t {                
     int    a;         
     char  b;                  
     double c;          
  } s1_t;
 
  s1_tid = H5Tcreate (H5T_COMPOUND, sizeof(s1_t));
  H5Tinsert(s1_tid, &ldquo;a_name&rdquo;, HOFFSET(s1_t, a), H5T_NATIVE_INT);
  H5Tinsert(s1_tid, &ldquo;b_name&rdquo;, HOFFSET(s1_t, b), H5T_NATIVE_CHAR);
  H5Tinsert(s1_tid, &ldquo;c_name&rdquo;, HOFFSET(s1_t, c), H5T_NATIVE_DOUBLE);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 13. A compound datatype that requires padding</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />
<br />

<!-- NEW PAGE -->

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dtypes_fig23.JPG">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 12. Memory layout of a compound datatype that requires 
        padding </b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

  <p>However, data stored on disk does not require 
    alignment, so unaligned versions of compound data 
    structures can be created to improve space efficiency 
    on disk. These unaligned compound datatypes can be 
    created by computing offsets by hand to eliminate 
    inter-member padding, or the members can be packed by 
    calling <code>H5Tpack</code> (which modifies a datatype 
    directly, so it is usually preceded by a call to 
    <code>H5Tcopy</code>).  </p>
  
  <p>The example below shows how to create a disk version of the 
    compound datatype from the figure above in order to store 
    data on disk in as compact a form as possible. 
    
    Packed compound datatypes should generally not be used to 
    describe memory as they may violate alignment constraints 
    for the architecture being used. Note also that using a 
    packed datatype for disk storage may involve a higher 
    data conversion cost.</p>


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  hid_t s2_tid = H5Tcopy (s1_tid);
                 H5Tpack (s2_tid);</pre> </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 14. Create a packed compound datatype in C</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />




  <p>The example below shows the sequence of Fortran calls to 
    create a packed compound datatype. An HDF5 Fortran 
    compound datatype never describes a compound datatype 
    in memory and compound data is <em>ALWAYS</em> written 
    by fields as described in the next section. Therefore 
    packing is not needed unless the offset of each consecutive 
    member is not equal to the sum of the sizes of the 
    previous members.</p>
    

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  CALL h5tcopy_f(s1_id, s2_id, error)
  CALL h5tpack_f(s2_id, error)</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 15. Create a packed compound datatype in Fortran</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



<h4>6.4.3.2.1.2. Creating and Writing Datasets with Compound Datatypes</h4>

  <p>Creating datasets with compound datatypes is similar 
    to creating datasets with any other HDF5 datatypes. But 
    writing and reading may be different since datasets that 
    have compound datatypes can be written or read by a field 
    (member) or subsets of fields (members). The compound datatype 
    is the only composite datatype that supports &ldquo;sub-setting&rdquo; by 
    the elements the datatype is built from.</p>
    
  <p>The example below shows a C example of creating and writing a dataset 
    with a compound datatype.</p>
    

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  typedef struct s1_t {
     int    a;
     float  b;
     double c;
  } s1_t;

  s1_t data[LENGTH];

  /* Initialize data */
  for (i = 0; i &lt; LENGTH; i++) {
       data[i].a = i;
       data[i].b = i*i;
       data[i].c = 1./(i+1);
  ...
  s1_tid = H5Tcreate (H5T_COMPOUND, sizeof(s1_t));
  H5Tinsert(s1_tid, &ldquo;a_name&rdquo;, HOFFSET(s1_t, a), H5T_NATIVE_INT);
  H5Tinsert(s1_tid, &ldquo;b_name&rdquo;, HOFFSET(s1_t, b), H5T_NATIVE_FLOAT);
  H5Tinsert(s1_tid, &ldquo;c_name&rdquo;, HOFFSET(s1_t, c), H5T_NATIVE_DOUBLE);
  ...
  dataset_id = H5Dcreate(file_id, &ldquo;SDScompound.h5&rdquo;, s1_t, space_id, 
                 H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
  H5Dwrite (dataset_id, s1_tid, H5S_ALL, H5S_ALL, H5P_DEFAULT, data);</pre> </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 16. Create and write a dataset with a compound datatype in C</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />


<!-- NEW PAGE -->
  <p>The example below shows the content of the file written on 
    a little-endian machine.</p>

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  HDF5 &ldquo;SDScompound.h5&rdquo; {
  GROUP &ldquo;/&rdquo; {
      DATASET &ldquo;ArrayOfStructures&rdquo; {
         DATATYPE  H5T_COMPOUND {
            H5T_STD_I32LE &ldquo;a_name&rdquo;;
            H5T_IEEE_F32LE &ldquo;b_name&rdquo;;
            H5T_IEEE_F64LE &ldquo;c_name&rdquo;;
         }
         DATASPACE  SIMPLE { ( 3 ) / ( 3 ) }
         DATA {
         (0): {
               0,
               0,
               1
            },
         (1): {
               1,
               1,
               0.5
            },
         (2): {
               2,
               4,
               0.333333
            }
         }
      }
  }
  }</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 17. Create and write a little-endian dataset with a compound 
        datatype in C</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />


<!-- NEW PAGE -->
  <p>It is not necessary to write the whole data at once. 
    Datasets with compound datatypes can be written by 
    field or by subsets of fields. In order to do this one 
    has to remember to set the transfer property of the dataset 
    using the <code>H5Pset_preserve</code> call and to define the 
    memory datatype that corresponds to a field. The example below 
    shows how float and double fields are  written to the 
    dataset.</p>
    

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  typedef struct sb_t {
     float  b;
     double c;
  } sb_t;

  typedef struct sc_t {
     float  b;
     double c;
  } sc_t;
  sb_t data1[LENGTH];
  sc_t data2[LENGTH];

  /* Initialize data */
  for (i = 0; i &lt; LENGTH; i++) {
       data1.b = i*i;
       data2.c = 1./(i+1);
  }
  ...
  /* Create dataset as in example 15 */
  ...
  /* Create memory datatypes corresponding to float and 
  double datatype fileds */

  sb_tid = H5Tcreate (H5T_COMPOUND, sizeof(sb_t));
  H5Tinsert(sb_tid, &ldquo;b_name&rdquo;, HOFFSET(sb_t, b), H5T_NATIVE_FLOAT);
  sc_tid = H5Tcreate (H5T_COMPOUND, sizeof(sc_t));
  H5Tinsert(sc_tid, &ldquo;c_name&rdquo;, HOFFSET(sc_t, c), H5T_NATIVE_DOUBLE);
  ...
  /* Set transfer property */
  xfer_id = H5Pcreate(H5P_DATASET_XFER);
  H5Pset_preserve(xfer_id, 1);
  H5Dwrite (dataset_id, sb_tid, H5S_ALL, H5S_ALL, xfer_id, data1);
  H5Dwrite (dataset_id, sc_tid, H5S_ALL, H5S_ALL, xfer_id, data2);</pre> </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 18. Writing floats and doubles to a dataset</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



<!-- NEW PAGE -->
  <p>The figure below shows the content of the file written on a 
    little-endian machine. Only float and double fields are 
    written. The default fill value is used to initialize the 
    unwritten integer field.</p>
    

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  HDF5 &ldquo;SDScompound.h5&rdquo; {
  GROUP &ldquo;/&rdquo; {
      DATASET &ldquo;ArrayOfStructures&rdquo; {
         DATATYPE  H5T_COMPOUND {
            H5T_STD_I32LE &ldquo;a_name&rdquo;;
            H5T_IEEE_F32LE &ldquo;b_name&rdquo;;
            H5T_IEEE_F64LE &ldquo;c_name&rdquo;;
         }
         DATASPACE  SIMPLE { ( 3 ) / ( 3 ) }
         DATA {
         (0): {
               0,
               0,
               1
            },
         (1): {
               0,
               1,
               0.5
            },
         (2): {
               0,
               4,
               0.333333
            }
         }
      }
  }
  }</pre> </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 19. Writing floats and doubles to a dataset on a little-endian 
        system</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



<!-- NEW PAGE -->
  <p>The example below contains a Fortran example that creates and writes 
    a dataset with a compound datatype. As this example illustrates, 
    writing and reading compound datatypes in Fortran is <em>always</em> 
    done by fields. The content of the written file is the same as 
    shown in the example above.</p>
    

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  ! One cannot write an array of a derived datatype in Fortran.
  TYPE s1_t
     INTEGER          a
     REAL             b
     DOUBLE PRECISION c
  END TYPE s1_t
  TYPE(s1_t) d(LENGTH)
  ! Therefore, the following code initializes an array corresponding 
  ! to each field in the derived datatype and writes those arrays 
  ! to the dataset

  INTEGER, DIMENSION(LENGTH)          :: a
  REAL, DIMENSION(LENGTH)             :: b
  DOUBLE PRECISION, DIMENSION(LENGTH) :: c
  
  ! Initialize data
   do i = 1, LENGTH
      a(i) = i-1
      b(i) = (i-1) * (i-1)
      c(i) = 1./i
   enddo

  ...

   ! Set dataset transfer property to preserve partially initialized fields
   ! during write/read to/from dataset with compound datatype.
   !
   CALL h5pcreate_f(H5P_DATASET_XFER_F, plist_id, error)
   CALL h5pset_preserve_f(plist_id, .TRUE., error)
  ...
   !
   ! Create compound datatype.
   !
   ! First calculate total size by calculating sizes of each member
   !
   CALL h5tget_size_f(H5T_NATIVE_INTEGER, type_sizei, error)
   CALL h5tget_size_f(H5T_NATIVE_REAL, type_sizer, error)
   CALL h5tget_size_f(H5T_NATIVE_DOUBLE, type_sized, error)
   type_size = type_sizei + type_sizer + type_sized
   CALL h5tcreate_f(H5T_COMPOUND_F, type_size, dtype_id, error)
   !
   ! Insert memebers
   !
   !
   ! INTEGER member
   !
   offset = 0
   CALL h5tinsert_f(dtype_id, &ldquo;a_name&rdquo;, offset, H5T_NATIVE_INTEGER, error)
   !
   ! REAL member
   !
   offset = offset + type_sizei
   CALL h5tinsert_f(dtype_id, &ldquo;b_name&rdquo;, offset, H5T_NATIVE_REAL, error)
   !
   ! DOUBLE PRECISION member
   !
   offset = offset + type_sizer
   CALL h5tinsert_f(dtype_id, &ldquo;c_name&rdquo;, offset, H5T_NATIVE_DOUBLE, error)

   !
   ! Create the dataset with compound datatype.
   !
   CALL h5dcreate_f(file_id, dsetname, dtype_id, dspace_id, &amp;
                    dset_id, error, H5P_DEFAULT_F, H5P_DEFAULT_F, H5P_DEFAULT_F)
   !
  ...
   ! Create memory types. We have to create a compound datatype
   ! for each member we want to write.
   !
   !
   CALL h5tcreate_f(H5T_COMPOUND_F, type_sizei, dt1_id, error)
   offset = 0
   CALL h5tinsert_f(dt1_id, &ldquo;a_name&rdquo;, offset, H5T_NATIVE_INTEGER, error)
   !
   CALL h5tcreate_f(H5T_COMPOUND_F, type_sizer, dt2_id, error)
   offset = 0
   CALL h5tinsert_f(dt2_id, &ldquo;b_name&rdquo;, offset, H5T_NATIVE_REAL, error)
   !
   CALL h5tcreate_f(H5T_COMPOUND_F, type_sized, dt3_id, error)
   offset = 0
   CALL h5tinsert_f(dt3_id, &ldquo;c_name&rdquo;, offset, H5T_NATIVE_DOUBLE, error)
   !
   ! Write data by fields in the datatype. Fields order is not important.
   !
   CALL h5dwrite_f(dset_id, dt3_id, c, data_dims, error, xfer_prp = plist_id)
   CALL h5dwrite_f(dset_id, dt2_id, b, data_dims, error, xfer_prp = plist_id)
   CALL h5dwrite_f(dset_id, dt1_id, a, data_dims, error, xfer_prp = plist_id)</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 20. Create and write a dataset with a compound datatype in 
        Fortran</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



<!-- NEW PAGE -->
<h4>6.4.3.2.1.3. Reading Datasets with Compound Datatypes</h4>

  <p>Reading datasets with compound datatypes may be a 
    challenge. For general applications there is no way to 
    know <em>a priori</em> the corresponding C structure. 
    Also, C structures cannot be allocated on the fly during discovery 
    of the dataset&rsquo;s datatype. For general C , C++, Fortran 
    and Java application the following steps will be required 
    to read and to interpret data from the dataset with 
    compound datatype:</p>
 
  <dl>    
  <dt>
  <ol>
    <li>Get the identifier of the compound datatype in the file 
      with the <code>H5Dget_type</code> call</li>
    <li>Find the number of the compound datatype members 
      with the <code>H5Tget_nmembers</code> call</li>
    <li>Iterate through compound datatype members</li>
  </ol>
    <dd>
      <ul>
        <li>Get member class with the 
	  <code>H5Tget_member_class</code> call</li>
	<li>Get member name with the 
	  <code>H5Tget_member_name</code> call</li>
	<li>Check class type against predefined classes</li>
        
	<ul>
	  <li><code>H5T_INTEGER</code></li>
          <li><code>H5T_FLOAT</code></li>
          <li><code>H5T_STRING</code></li>
          <li><code>H5T_BITFIELD</code></li>
          <li><code>H5T_OPAQUE</code></li>
          <li><code>H5T_COMPOUND</code></li>
          <li><code>H5T_REFERENCE</code></li>
          <li><code>H5T_ENUM</code></li>
          <li><code>H5T_VLEN</code></li>
          <li><code>H5T_ARRAY</code></li>
	</ul>
	
	<li>If class is <code>H5T_COMPOUND</code>, 
	  then go to step 2 and repeat all steps under 
	  step 3. If class is not <code>H5T_COMPOUND</code>, 
	  then a member is of an atomic class and can be 
	  read to a corresponding buffer after discovering 
	  all necessary information specific to each atomic 
	  type (e.g. size of the integer or floats, super 
	  class for enumerated and array datatype, 
	  and it sizes, etc.)</li>
      </ul>
    </dd>
  </dl>


  <p>The examples below show how to read a dataset with a known 
    compound datatype.</p>
    
  <p>The first example below shows the steps needed to read data of a 
    known structure. First, build a memory datatype 
    the same way it was built when the dataset was created, and then
    second use the datatype in a <code>H5Dread</code> call.</p>
    

<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  typedef struct s1_t {
     int    a;
     float  b;
     double c;
  } s1_t;

  s1_t *data;

  ...
  s1_tid = H5Tcreate(H5T_COMPOUND, sizeof(s1_t));
  H5Tinsert(s1_tid, &ldquo;a_name&rdquo;, HOFFSET(s1_t, a), H5T_NATIVE_INT);
  H5Tinsert(s1_tid, &ldquo;b_name&rdquo;, HOFFSET(s1_t, b), H5T_NATIVE_FLOAT);
  H5Tinsert(s1_tid, &ldquo;c_name&rdquo;, HOFFSET(s1_t, c), H5T_NATIVE_DOUBLE);
  ...
  dataset_id = H5Dopen(file_id, &ldquo;SDScompound.h5&rdquo;, H5P_DEFAULT);
  ...
  data = (s1_t *) malloc (sizeof(s1_t)*LENGTH);
  H5Dread(dataset_id, s1_tid, H5S_ALL, H5S_ALL, H5P_DEFAULT, data);</pre> </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 21. Read a dataset using a memory datatype
        <!-- used to be Figure 25f --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>Instead of building a memory datatype, the application could use the 
  <code>H5Tget_native_type</code> function. See the example below.</p>
    

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  typedef struct s1_t {
     int    a;
     float  b;
     double c;
  } s1_t;

  s1_t *data;
  hid_t file_s1_t, mem_s1_t;
  ...
  dataset_id = H5Dopen(file_id, &ldquo;SDScompound.h5&rdquo;, H5P_DEFAULT);
  /* Discover datatype in the file */
  file_s1_t  = H5Dget_type(dataset_id);
  /* Find corresponding memory datatype */
  mem_s1_t   = H5Tget_native_type(file_s1_t, H5T_DIR_DEFAULT); 
  
  ...
  data = (s1_t *) malloc (sizeof(s1_t)*LENGTH);
  H5Dread (dataset_id, mem_s1_tid, H5S_ALL, H5S_ALL, H5P_DEFAULT, data);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 22. Read a dataset using <code>H5Tget_native_type</code>
        <!-- used to be Figure 25g --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />


<!-- NEW PAGE -->


  <p>The example below shows how to read just one float member of a 
  compound datatype.</p>
  <!-- used to be Example 25h -->
  


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  typedef struct s1_t {
     float  b;
  } sf_t;

  sf_t *data;

  ...
  sf_tid = H5Tcreate(H5T_COMPOUND, sizeof(sf_t));
  H5Tinsert(s1_tid, &ldquo;b_name&rdquo;, HOFFSET(sf_t, b), H5T_NATIVE_FLOAT);
  ...
  dataset_id = H5Dopen(file_id, &ldquo;SDScompound.h5&rdquo;, H5P_DEFAULT);
  ...
  data = (sf_t *) malloc (sizeof(sf_t)*LENGTH);
  H5Dread(dataset_id, sf_tid, H5S_ALL, H5S_ALL, H5P_DEFAULT, data);</pre> </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 23. Read one floating point member of a compound datatype
        <!-- used to be Figure 25h --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>The example below <!-- used to be Figure 25i --> shows how to read float 
    and 
    double members of a compound datatype into 
    a structure that has those fields in a different 
    order. Please notice that <code>H5Tinsert</code> 
    calls can be used in an order different from the 
    order of the structure’s members.</p>
    


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  typedef struct s1_t {
     double c;
     float  b;
  } sdf_t;

  sdf_t *data;

  ...
  sdf_tid = H5Tcreate(H5T_COMPOUND, sizeof(sdf_t));
  H5Tinsert(sdf_tid, &ldquo;b_name&rdquo;, HOFFSET(sdf_t, b), H5T_NATIVE_FLOAT);
  H5Tinsert(sdf_tid, &ldquo;c_name&rdquo;, HOFFSET(sdf_t, c), H5T_NATIVE_DOUBLE);
  ...
  dataset_id = H5Dopen(file_id, &ldquo;SDScompound.h5&rdquo;, H5P_DEFAULT);
  ...
  data = (sdf_t *) malloc (sizeof(sdf_t)*LENGTH);
  H5Dread(dataset_id, sdf_tid, H5S_ALL, H5S_ALL, H5P_DEFAULT, data);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 24. Read float and double members of a compound datatype 
        <!-- used to be Figure 25i --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



<!-- NEW PAGE -->
<h4>6.4.3.2.2. Array</h4>
  
  <p>Many scientific datasets have multiple measurements for each point 
  in a space. There are several natural ways to represent this data, 
  depending on the variables and how they are used in computation. 
  See the table and the figure below.</p>

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Table 20. Representing data with multiple measurements</b></td>
        </tr>
    <tr><td colspan="5"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="25%"><b>Storage Strategy</b></td>
        <td width="2%">&nbsp;</td>
        <td width="25%"><b>Stored as</b></td>
        <td width="2%">&nbsp;</td>
        <td width="46%"><b>Remarks</b></td>
        <tr><td colspan="5"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Mulitple planes</td>
        <td>&nbsp;</td>
        <td>Several datasets with identical dataspaces</td>
        <td>&nbsp;</td>
        <td>This is optimal when variables are 
        accessed individually, or when often uses only selected variables.</td>
        </tr>
    <tr><td colspan="5"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Additional dimension</td>
        <td>&nbsp;</td>
        <td>One dataset, the last &ldquo;dimension&rdquo; 
        is a vector of variables</td>
        <td>&nbsp;</td>
        <td>This can give good performance, although 
        selecting only a few variables may be slow. This may not reflect the 
        science.</td>
        </tr>
    <tr><td colspan="5"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Record with multiple values</td>
        <td>&nbsp;</td>
        <td>One dataset with compound datatype</td>
        <td>&nbsp;</td>
        <td>This enables the variables to be read all 
        together or selected. Also handles &ldquo;vectors&rdquo; of 
        heterogenous data.</td>
        </tr>
    <tr><td colspan="5"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Vector or Tensor value</td>
        <td>&nbsp;</td>
        <td>One dataset, each data element is a small 
        array of values.</td>
        <td>&nbsp;</td>
        <td>This uses the same amount of space as 
        the previous two, and may represent the science model better.</td>
        </tr>
    <tr><td colspan="5"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />

<!-- NEW PAGE -->
<table width="400" cellspacing="0" align="center">
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td align="left">
        <img src="Images/Dtypes_fig26_pic1of4.JPG"></td>
        <td>&nbsp;</td>
        <td align="center"> 
        <img src="Images/Dtypes_fig26_pic2of4.JPG"></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td align="left">
        <img src="Images/Dtypes_fig26_pic3of4.JPG"></td>
        <td>&nbsp;</td>
        <td align="center"> 
        <img src="Images/Dtypes_fig26_pic4of4.JPG"></td>
        </tr>

    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" colspan="3" >
        <b>Figure 13. Representing data with multiple measurements</b>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />



  <p>The HDF5 <code>H5T_ARRAY</code> datatype defines 
    the data element to be a homogeneous, multi-dimensional 
    array. See Figure 13d above. The elements of the array 
    can be any HDF5 datatype (including compound and array), and 
    the size of the datatype is the total size of the array. 
    A dataset of array datatype cannot be subdivided for I/O 
    within the data element: the entire array of the data element 
    must be transferred. If the data elements need to be accessed 
    separately, e.g., by plane, then the array datatype should not 
    be used. The table below <!-- formerly Table 22 --> 
    shows advantages and disadvantages of various 
    storage methods.</p>

<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="5" align="left" valign="bottom">
        <b>Table 21. Storage method advantages and disadvantages</b></td>
        </tr>
    <tr><td colspan="5"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="20%"><b>Method</b></td>
        <td width="2%">&nbsp;</td>
        <td width="38%"><b>Advantages</b></td>
        <td width="2%">&nbsp;</td>
        <td width="38%"><b>Disadvantages</b></td>
    <tr><td colspan="5"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>a) Multiple Datasets</td>
        <td>&nbsp;</td>
        <td>Easy to access each plane, can select any plane(s)</td>
        <td>&nbsp;</td>
        <td>Less efficient to access a &lsquo;column&rsquo; through the 
            planes</td>
        </tr>
    <tr><td colspan="5"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>b) N+1 Dimension</td>
        <td>&nbsp;</td>
        <td>All access patterns supported</td>
        <td>&nbsp;</td>
        <td>Must be homogeneous datatype<br /><br />
        The added dimension may not make sense in the scientific 
        model</td>
        </tr>
    <tr><td colspan="5"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>c) Compound Datatype</td>
        <td>&nbsp;</td>
        <td>Can be heterogenous datatype</td>
        <td>&nbsp;</td>
        <td>Planes must be named, selection is by plane<br /><br />
        Not a natural representation for a matrix</td>
        </tr>
    <tr><td colspan="5"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>d) Array</td>
        <td>&nbsp;</td>
        <td>A natural representation for vector or tensor data</td>
        <td>&nbsp;</td>
        <td>Cannot access elements separately (no access by plane)</td>
        </tr>
    <tr><td colspan="5"><hr color="green" size="3" /></td></tr>
</table>
<br />



  <p>An array datatype may be multi-dimensional with 1 to 
  <code>H5S_MAX_RANK</code> (the maximum rank of a dataset is currently 
  32) dimensions. The dimensions can be any size greater than 0, but 
  unlimited dimensions are not supported (although the datatype can be 
  a variable-length datatype).</p>
  
  <p>An array datatype is created with the <code>H5Tarray_create</code> 
  call, which specifies the number of dimensions, the size of each 
  dimension, and the base type of the array. The array datatype can 
  then be used in any way that any datatype object is used. The example 
  below <!-- formerly Figure 27 --> shows the creation of a datatype 
  that is a two-dimensional array of native integers, and this is then 
  used to create a dataset. Note that the dataset can be a dataspace 
  that is any number and size of dimensions. The figure below 
  <!-- formerly Figure 28 --> shows the layout in memory assuming that 
  the native integers are 4 bytes. Each data element has 6 elements, 
  for a total of 24 bytes.</p>



<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  hid_t       file, dataset;
  hid_t       datatype, dataspace;
  hsize_t     adims[] = {3, 2}; 
  
  datatype = H5Tarray_create(H5T_NATIVE_INT, 2, adims, NULL);

  dataset = H5Dcreate(file, datasetname, datatype, dataspace,
        H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 25. Create a two-dimensional array datatype
        <!-- formerly Figure 27 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />
<br />



<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dtypes_fig28.JPG" width="550">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 14. Memory layout of a two-dimensional array datatype
        <!-- formerly Figure 28 --></b>
        <hr color="green" size="3"/></td>
  </tr>
</table>
<br />



<!-- NEW PAGE -->
<a name="VariableLengthDatatypes">
<h4>6.4.3.2.3. Variable-length Datatypes</h4></a>
  
  <p>A variable-length (VL) datatype is a one-dimensional sequence of a 
  datatype which are not fixed in length from one dataset location to 
  another, i.e., each data element may have a different number of members. 
  Variable-length datatypes cannot be divided, the entire data element 
  must be transferred.</p>
  
  <p>VL datatypes are useful to the scientific community in many different 
  ways, possibly including: </p>
  <ul>
    <li><em>Ragged arrays</em>: Multi-dimensional ragged arrays can be 
    implemented with the last (fastest changing) dimension being ragged by 
    using a VL datatype as the type of the element stored. </li>
    <li><em>Fractal arrays</em>: A nested VL datatype can be used to implement 
    ragged arrays of ragged arrays, to whatever nesting depth is required 
    for the user. </li>
    <li><em>Polygon lists</em>: A common storage requirement is to 
    efficiently store arrays of polygons with different numbers of 
    vertices. A VL datatypes can be used to efficiently and succinctly 
    describe an array of polygons with different numbers of vertices. </li>
    <li><em>Character strings</em>: Perhaps the most common use of VL 
    datatypes will be to store C-like VL character strings in dataset 
    elements or as attributes of objects. </li>
    <li><em>Indices, e.g. of objects within the file</em>: An array of 
    VL object references could be used as an index to all the objects 
    in a file which contain a particular sequence of dataset values. </li>
    <li><em>Object Tracking</em>: An array of VL dataset region references 
    can be used as a method of tracking objects or features appearing 
    in a sequence of datasets. </li>
  </ul>
  
  <p>A VL datatype is created by calling <code>H5Tvlen_create</code> which 
  specifies the base datatype. The first example below <!-- formerly 
  Figure 29 --> shows an example of code that creates a VL datatype 
  of unsigned integers. Each data element is a one-dimensional array of 
  zero or more members and is stored in the <code>hvl_t</code> structure. 
  See the second example below. <!-- formerly Figure 30 --></p>



<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  tid1 = H5Tvlen_create (H5T_NATIVE_UINT);

  dataset=H5Dcreate(fid1, &ldquo;Dataset1&rdquo;, tid1, sid1, H5P_DEFAULT, 
            H5P_DEFAULT, H5P_DEFAULT);</pre> </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 26. Create a variable-length datatype of unsigned integers
        <!-- formerly Figure 29 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />
<br />



<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
 typedef struct  {
     size_t len; /* Length of VL data (in base type units) */      
     void *p;    /* Pointer to VL data */        
 } hvl_t;</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 27. Data element storage for members of the VL datatype
        <!-- formerly Figure 30 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



<!-- NEW PAGE -->
  <p>The first example below <!-- formerly Figure 31 --> shows how the VL 
  data is written. For each of the 10 data elements, 
  a length and data buffer must be allocated. Below the two examples is a 
  figure <!-- formerly Figure 33 --> that shows how the data is 
  laid out in memory. </p>
  
  <p>An analogous procedure must be used to read the data. See the second 
  example below. 
  An appropriate array of <code>vl_t</code> must be allocated, 
  and the data read. It is then traversed one data element at a time. 
  The <code>H5Dvlen_reclaim</code> call frees the data buffer for the buffer. 
  With each element possibly being of different sequence lengths for a 
  dataset with a VL datatype, the memory for the VL datatype 
  must be dynamically allocated. Currently there are two methods of managing the 
  memory for VL datatypes: the standard C malloc/free memory allocation routines 
  or a method of calling user-defined memory management routines to allocate or 
  free memory (set with <code>H5Pset_vlen_mem_manager</code>). Since the memory 
  allocated when reading (or writing) may be complicated to release, 
  the <code>H5Dvlen_reclaim</code> function
  is provided to traverse a memory buffer and free the VL datatype information 
  without leaking memory.</p>



<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  hvl_t wdata[10];           /* Information to write */
  
  /* Allocate and initialize VL data to write */
  for(i=0; i &lt; 10; i++) {
      wdata[i].p = malloc((i+1)*sizeof(unsigned int));
      wdata[i].len = i+1;
      for(j=0; j<(i+1); j++)
           ((unsigned int *)wdata[i].p)[j]=i*10+j;
   }

   ret=H5Dwrite(dataset, tid1, H5S_ALL, H5S_ALL, H5P_DEFAULT, wdata);</pre> </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 28. Write VL data 
        <!-- formerly Figure 31 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />
<br />



<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  hvl_t rdata[SPACE1_DIM1];      
  ret=H5Dread(dataset, tid1, H5S_ALL, H5S_ALL, xfer_pid, rdata);

  for(i=0; i&lt;SPACE1_DIM1; i++) {
    printf(&ldquo;%d: len %d &rdquo;,rdata[i].len);
    for(j=0; j&lt;rdata[i].len; j++) {
       printf(&ldquo; value: %u\n&rdquo;,((unsigned int *)rdata[i].p)[j]);
    }
  } 
  ret=H5Dvlen_reclaim(tid1, sid1, xfer_pid, rdata);</pre> </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 29. Read VL data 
        <!-- formerly Figure 32 --></b>
        <hr color="green" size="3"/></td>
  </tr>
</table>
<br />
<br />


<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dtypes_fig33.JPG" width="550">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 15. Memory layout of a VL datatype
        <!-- formerly Figure 33 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>The user program must carefully manage these relatively complex data 
  structures. 
  The <code>H5Dvlen_reclaim</code> function performs a standard traversal, 
  freeing all the data. This function analyzes the datatype and dataspace 
  objects, and visits each VL data element, recursing through nested 
  types. By default, the system <code>free</code> is called for the 
  pointer in each <code>vl_t</code>. Obviously, this call assumes that 
  all of this memory was allocated with the system <code>malloc</code>.</p>
  
  <p>The user program may specify custom memory manager routines, one for 
  allocating and one for freeing. These may be set with the 
  <code>H5Pvlen_mem_manager</code>, and must have the following prototypes: </p>
  
  <ul>
    <li><code>typedef void *(*H5MM_allocate_t)(size_t size, void *info);</code> </li>
    <li><code>typedef void (*H5MM_free_t)(void *mem, void *free_info);</code> </li>
  </ul>
  
  <p>The utility function <code>H5Dget_vlen_buf_size</code> checks the 
  number of bytes required to store the VL data from the dataset. This 
  function analyzes the datatype and dataspace object to visit all the 
  VL data elements, to determine the number of bytes required to store 
  the data for the in the destination storage (memory). The 
  <code>size</code> value is adjusted for data conversion and alignment 
  in the destination.</p>


<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="NonNumDtypes">
<div align=right>
<a href="#TOP"><font size="-1">(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>


<a name="NonNumDtypes">
<h3 class=pagebefore>6.5. Other Non-numeric Datatypes</h3>
</a>

  <p>Several datatype classes define special types of objects.</p>
  
<h4>6.5.1. Strings</h4>

  <p>Text data is represented by arrays of characters called strings. 
  Because C and Fortran terminate strings differently, the library can 
  read and write strings in several ways. The important questions that 
  an application needs to answer to read strings correctly are the 
  following: </p>
  
  <ul>
    <li>What is the size of the string?</li>
    <li>How is the string terminated?</li>
  </ul>
  
  <p>See the entry for <code>H5Tset_strpad</code> in the 
  <i>HDF5 Reference Manual</i> for more information on how to specify a 
  particular style of string padding and terminating. </p>

  <p>In the rest of this section, we will look at some of the common 
  ways strings might be stored.</p>
  
  <p>The figures below show different ways that the strings &ldquo;Four 
  score&rdquo; and &ldquo;seven years ago&rdquo; might be stored 
  in a C environment. By C environment, we mean that the disk and memory 
  versions of the dataset terminate the strings with a NULL, \0. This 
  also means that the length of a string 
  is one less than the size of the string: the size counts the NULL. 
  Note that the single quotation marks have been added for 
  clarity in the examples in this section and would not be stored in an 
  actual dataset. See <a href="#stringsInMixedEnvironments">
  &ldquo;Strings in Mixed Environments&rdquo;</a> at 
  the end of this section for more information. </p>

  <p>The figure below shows a string stored in a dataset in a 
  one-dimensional array using 27 elements. The  <code>H5T_NATIVE_CHAR</code> 
  datatype is used. Each character of the string is stored in an element 
  of the dataset. The result is a block of text data that 
  gives little indication of any structure in the text.</p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>

  <table align="center" width="100%">
	  <tr>
		<td colspan="2">
		  <table align="center" border="1" width="95%">
		    <tr>
			  <td width="12.5%" align="center">0</td>
			  <td width="12.5%" align="center">1</td>
			  <td width="12.5%" align="center">2</td>
			  <td width="12.5%" align="center">3</td>
			  <td width="12.5%" align="center">4</td>
			  <td width="12.5%" align="center">5</td>
			  <td width="12.5%" align="center">6</td>
			  <td width="12.5%" align="center">7</td>
		    </tr>
		    <tr>
			  <td align="center">&lsquo;F&rsquo;</td>
			  <td align="center">&lsquo;o&rsquo;</td>
			  <td align="center">&lsquo;u&rsquo;</td>
			  <td align="center">&lsquo;r&rsquo;</td>
			  <td align="center">&lsquo;&nbsp;&rsquo;</td>
			  <td align="center">&lsquo;s&rsquo;</td>
			  <td align="center">&lsquo;c&rsquo;</td>
			  <td align="center">&lsquo;o&rsquo;</td>
		    </tr>
		  </table>
		</td>
	  </tr>
	  <tr><td colspan="3">&nbsp;</td></tr>
      </table>

  <table align="center" width="100%">
	  <tr>
		<td colspan="2">
		  <table align="center" border="1" width="95%">
		    <tr>
			  <td width="12.5%" align="center">8</td>
			  <td width="12.5%" align="center">9</td>
			  <td width="12.5%" align="center">10</td>
			  <td width="12.5%" align="center">11</td>
			  <td width="12.5%" align="center">12</td>
			  <td width="12.5%" align="center">13</td>
			  <td width="12.5%" align="center">14</td>
			  <td width="12.5%" align="center">15</td>
		    </tr>
		    <tr>
			  <td align="center">&lsquo;r&rsquo;</td>
			  <td align="center">&lsquo;e&rsquo;</td>
			  <td align="center">&lsquo;\0&rsquo;</td>
			  <td align="center">&lsquo;s&rsquo;</td>
			  <td align="center">&lsquo;e&rsquo;</td>
			  <td align="center">&lsquo;v&rsquo;</td>
			  <td align="center">&lsquo;e&rsquo;</td>
			  <td align="center">&lsquo;n&rsquo;</td>
		    </tr>
		  </table>
		</td>
	  </tr>
	  <tr><td colspan="3">&nbsp;</td></tr>
      </table>

  <table align="center" width="100%">
	  <tr>
		<td colspan="2">
		  <table align="center" border="1" width="95%">
		    <tr>
			  <td width="12.5%" align="center">16</td>
			  <td width="12.5%" align="center">17</td>
			  <td width="12.5%" align="center">18</td>
			  <td width="12.5%" align="center">19</td>
			  <td width="12.5%" align="center">20</td>
			  <td width="12.5%" align="center">21</td>
			  <td width="12.5%" align="center">22</td>
			  <td width="12.5%" align="center">23</td>
		    </tr>
		    <tr>
			  <td align="center">&lsquo;&nbsp;&rsquo;</td>
			  <td align="center">&lsquo;y&rsquo;</td>
			  <td align="center">&lsquo;e&rsquo;</td>
			  <td align="center">&lsquo;a&rsquo;</td>
			  <td align="center">&lsquo;r&rsquo;</td>
			  <td align="center">&lsquo;s&rsquo;</td>
			  <td align="center">&lsquo;&nbsp;&rsquo;</td>
			  <td align="center">&lsquo;a&rsquo;</td>
		    </tr>
		  </table>
		</td>
	  </tr>
	  <tr><td colspan="3">&nbsp;</td></tr>
      </table>

  <table align="center" width="100%">
	  <tr>
		<td colspan="2">
		  <table align="center" border="1" width="95%">
		    <tr>
			  <td width="12.5%" align="center">24</td>
			  <td width="12.5%" align="center">25</td>
			  <td width="12.5%" align="center">26</td>
			  <td width="12.5%" align="center">27</td>
			  <td width="12.5%" align="center">28</td>
			  <td width="12.5%" align="center">29</td>
			  <td width="12.5%" align="center">30</td>
			  <td width="12.5%" align="center">31</td>
		    </tr>
		    <tr>
			  <td align="center">&lsquo;g&rsquo;</td>
			  <td align="center">&lsquo;o&rsquo;</td>
			  <td align="center">&lsquo;\0&rsquo;</td>
			  <td align="center">&nbsp;</td>
			  <td align="center">&nbsp;</td>
			  <td align="center">&nbsp;</td>
			  <td align="center">&nbsp;</td>
			  <td align="center">&nbsp;</td>
		    </tr>
		  </table>
		</td>
	  </tr>
      </table>


      
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 16. A string stored as one-character elements in a 
        one-dimensional array
        <!-- formerly part of Figure 34 --></b><hr color="green" size="3"/></td>
        </tr>  
</table>
<br />

  <p>The figure below shows how these strings might be stored using 
  a <b>fixed-length</b> datatype. This one-dimensional array uses the 
  <code>H5T_STRING</code> datatype. The dataset reserves space for a 
  specified number of characters in each string although some strings may 
  be shorter. In the figure below, the size is set to 20. This approach 
  is simple and usually fast to access, but this approach can waste storage 
  space if the lengths of the strings vary. The single quotation marks are 
  used to show the 20 characters included in each dataset element.</p>

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>

    
  <table align="center" width="100%">
	  <tr>
		<td colspan="2">
		  <table align="center" border="1" width="70%">
		    <tr>
			  <td width="50%" align="center">0</td>
			  <td width="50%" align="center">1</td>
		    </tr>
		    <tr>
			  <td align="center">&lsquo;Four&nbsp;score\0
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rsquo;</td>
			  <td align="center">&lsquo;seven&nbsp;years&nbsp;ago\0
              &nbsp;&nbsp;&nbsp;&nbsp;&rsquo;</td>
		    </tr>
		  </table>
		</td>
	  </tr>
      </table>

    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 17. Strings stored as fixed-length dataset elements
        <!-- formerly part of Figure 34 --></b><hr color="green" size="3"/></td>
        </tr>  
</table>
<br />



  <p>The figure below illustrates how these strings might be stored using 
  a <b>variable-length datatype</b>. This can be done using the mechanisms 
  described in the <a href="#VariableLengthDatatypes">
  &ldquo;Variable-length Datatypes&rdquo;</a> section above.
  The program would use <code>vl_t</code> structures to write and 
  read the data. The dataset is a one-dimensional array with two 
  elements, and each element is a variable-length string. 
  This is the same result as the strings stored in fixed-length elements
  in the figure above except that the first element of the array will 
  need only 11 bytes for storage instead of 20, and the second element
  will need only 16 bytes instead of 20. Note that the single 
  quotation marks are used to show the characters in each dataset element.</p>

  
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>

  <table align="center" width="100%">
	  <tr>
		<td colspan="2">
		  <table align="center" border="1" width="70%">
		    <tr>
			  <td width="50%" align="center">0</td>
			  <td width="50%" align="center">1</td>
		    </tr>
		    <tr>
			  <td align="center">&lsquo;Four&nbsp;score\0&rsquo;</td>
			  <td align="center">&lsquo;seven&nbsp;years&nbsp;ago\0&rsquo;</td>
		    </tr>
		  </table>
		</td>
	  </tr>
      </table>

    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 18. Strings stored as variable-length dataset elements
        <!-- formerly part of Figure 34 --></b><hr color="green" size="3"/></td>
        </tr>  
</table>
<br />

  
  <p>An alternate way to set up variable-length dataset elements is to set
  the size of the string datatype class to <code>H5T_VARIABLE</code>. 
  The example below <!-- formerly Figure 35 -->
  shows a declaration of a datatype of type <code>H5T_C_S1</code> 
  which is set to <code>H5T_VARIABLE</code>.  The HDF5 Library automatically 
  translates between this and the <code>vl_t</code> structure. Note that the 
  <code>H5T_VARIABLE</code> size can only be used with string datatypes.</p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  tid1 = H5Tcopy (H5T_C_S1); 
                    
  ret = H5Tset_size (tid1, H5T_VARIABLE);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 30. Set the string datatype size to <code>H5T_VARIABLE</code>
        <!-- formerly Figure 35 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>Variable-length strings can be read into C strings 
  (in other words, pointers to zero 
  terminated arrays of <code>char</code>). See the example below.  </p>
  

<table width="650" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  char *rdata[SPACE1_DIM1];  

  ret=H5Dread(dataset, tid1, H5S_ALL, H5S_ALL, xfer_pid, rdata);

  for(i=0; i&lt;SPACE1_DIM1; i++) {   
           printf(&ldquo;%d: len: %d, str is: %s\n&rdquo;, i, strlen(rdata[i]),rdata[i]);
  } 

  ret=H5Dvlen_reclaim(tid1, sid1, xfer_pid, rdata);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 31. Read variable-length strings into C strings
        <!-- formerly Figure 36 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />


<!-- 
3.23.2012. I commented out the "Strings in Mixed Environments" section below. 
I have spent too many GMQS hours and have to stop charging GMQS for awhile. MEE.

<a name="stringsInMixedEnvironments">
<b>Strings in Mixed Environments</b></a>

  <p>In the figures above, the strings are terminated with NULLs. 
  Suppose in another scenario that the strings were stored on disk and 
  were not terminated with NULLs, and suppose that the users of the data 
  would be using applications that expected strings to be terminated with 
  NULLs? What APIs might an application use to properly handle the strings? 
  </p>

  <p>The figure below shows the strings &ldquo;Four score&rdquo; and 
  &ldquo;seven years ago&rdquo; stored as fixed-length dataset elements 
  without NULL terminators.</p>
  
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>

    
  <table align="center" width="100%">
	  <tr>
		<td colspan="2">
		  <table align="center" border="1" width="70%">
		    <tr>
			  <td width="50%" align="center">0</td>
			  <td width="50%" align="center">1</td>
		    </tr>
		    <tr>
			  <td align="center">&lsquo;Four&nbsp;score
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rsquo;</td>
			  <td align="center">&lsquo;seven&nbsp;years&nbsp;ago
              &nbsp;&nbsp;&nbsp;&nbsp;&rsquo;</td>
		    </tr>
		  </table>
		</td>
	  </tr>
      </table>

    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 17???. Strings stored as fixed-length dataset elements
        and not terminated with NULLs
        </b><hr color="green" size="3"/></td>
        </tr>  
</table>
<br />
  
  <p>
  

  <p>??????? rewrite for this new example
  The figure below shows how these strings might be stored using 
  a <b>fixed-length</b> datatype. This one-dimensional array uses the 
  <code>H5T_STRING</code> datatype. The dataset reserves space for a 
  specified number of characters in each string although some strings may 
  be shorter. In the example below, the size is set to 20. This approach 
  is simple and usually fast to access, but this approach can waste storage 
  space if the lengths of the strings vary. The single quotation marks are 
  used to show the 20 characters included in each dataset element.</p>

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>

    
  <table align="center" width="100%">
	  <tr>
		<td colspan="2">
		  <table align="center" border="1" width="70%">
		    <tr>
			  <td width="50%" align="center">0</td>
			  <td width="50%" align="center">1</td>
		    </tr>
		    <tr>
			  <td align="center">&lsquo;Four&nbsp;score\0
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rsquo;</td>
			  <td align="center">&lsquo;seven&nbsp;years&nbsp;ago\0
              &nbsp;&nbsp;&nbsp;&nbsp;&rsquo;</td>
		    </tr>
		  </table>
		</td>
	  </tr>
      </table>

    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 17???. Strings stored as fixed-length dataset elements
        </b><hr color="green" size="3"/></td>
        </tr>  
</table>
<br />

  <p>Please note that a data element of size 1 might be useful in an 
  environment where a NULL is not needed to terminate a string. If a NULL 
  is needed to terminate a string, then a data element of size 1 
  would not be useful.</p>
  
  
  
  
  
<br /><br />
-->




<h4>6.5.2. Reference</h4>
  
  <p>In HDF5, objects (i.e. groups, datasets, and committed datatypes) 
  are usually accessed by name. There is another way to access stored 
  objects - by reference. There are two reference datatypes: object 
  reference and region reference. Object reference objects are created 
  with <code>H5Rcreate</code> and other calls (cross reference). These 
  objects can be stored and retrieved in a dataset as elements with 
  reference datatype. The first example below <!-- formerly Figure 37 -->
  shows an example of code that creates references to four objects, 
  and then writes the array of object references to a dataset. The 
  second example below <!-- formerly Figure 38 -->shows a dataset of datatype 
  reference being read and one of the reference objects being 
  dereferenced to obtain an object pointer.</p>
  
  <p>In order to store references to regions of a dataset, the datatype 
  should be <code>H5T_REGION_OBJ</code>. Note that a data element must 
  be either an object reference or a region reference: these are different 
  types and cannot be mixed within a single array.</p>
  

  <p>A reference datatype cannot be divided for I/O: an element is read or 
  written completely.</p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  dataset=H5Dcreate(fid1, &ldquo;Dataset3&rdquo;, H5T_STD_REF_OBJ, sid1,
            H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);

    /* Create reference to dataset */
    ret = H5Rcreate(&amp;wbuf[0], fid1,&ldquo;/Group1/Dataset1&rdquo;, H5R_OBJECT, -1);

    /* Create reference to dataset */
    ret = H5Rcreate(&amp;wbuf[1], fid1, &ldquo;/Group1/Dataset2&rdquo;, H5R_OBJECT, -1);

    /* Create reference to group */
    ret = H5Rcreate(&amp;wbuf[2], fid1, &ldquo;/Group1&rdquo;, H5R_OBJECT, -1);

    /* Create reference to committed datatype */
    ret = H5Rcreate(&amp;wbuf[3], fid1, &ldquo;/Group1/Datatype1&rdquo;, H5R_OBJECT, -1);

    /* Write selection to disk */
      
  ret=H5Dwrite(dataset, H5T_STD_REF_OBJ, H5S_ALL, H5S_ALL, H5P_DEFAULT, wbuf);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 32. Create object references and write to a dataset
        <!-- formerly Figure 37 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />
<br />


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  rbuf = malloc(sizeof(hobj_ref_t)*SPACE1_DIM1);

  /* Read selection from disk */
  ret=H5Dread(dataset, H5T_STD_REF_OBJ, H5S_ALL, H5S_ALL, H5P_DEFAULT, rbuf);

  /* Open dataset object */
  dset2 = H5Rdereference(dataset, H5R_OBJECT, &amp;rbuf[0]);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 33. Read a dataset with a reference datatype
        <!-- formerly Figure 38 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



<!-- NEW PAGE -->
<h4>6.5.3. ENUM</h4>
  
  <p>The enum datatype implements a set of (name, value) pairs, similar 
  to C/C++ enum.  The values are currently limited to native integer datatypes.  
  Each name can be the name of only one value, and each value can have only 
  one name.  </p>
  
  <p>The data elements of the ENUMERATION are stored according to the datatype, 
  e.g., as an array of integers. The example below <!-- formerly Figure 39 -->
  shows an example of how to create 
  an enumeration with five elements. The elements map symbolic names to 
  2-byte integers. See the table below.</p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
hid_t hdf_en_colors = H5Tcreate(H5T_ENUM, sizeof(short));
short val;
    H5Tenum_insert(hdf_en_colors, &ldquo;RED&rdquo;,   (val=0,&amp;val));
    H5Tenum_insert(hdf_en_colors, &ldquo;GREEN&rdquo;, (val=1,&amp;val));
    H5Tenum_insert(hdf_en_colors, &ldquo;BLUE&rdquo;,  (val=2,&amp;val));
    H5Tenum_insert(hdf_en_colors, &ldquo;WHITE&rdquo;, (val=3,&amp;val));
    H5Tenum_insert(hdf_en_colors, &ldquo;BLACK&rdquo;, (val=4,&amp;val));

    H5Dcreate(fileid, datasetname, hdf_en_colors, spaceid, H5P_DEFAULT, 
        H5P_DEFAULT, H5P_DEFAULT);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 34. Create an enumeration with five elements
        <!-- formerly Figure 39 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />
<br />


<table width="200" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 22. An enumeration<br />with five elements</b>
        <!-- formerly Table 23 --></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="50%"><b>Name</b></td>
        <td width="50%"><b>Value</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>RED</td>
        <td>0</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>GREEN</td>
        <td>1</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>BLUE</td>
        <td>2</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>WHITE</td>
        <td>3</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>BLACK</td>
        <td>4</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />



<!-- NEW PAGE -->
  <p>The figure below <!-- formerly Figure 40 -->shows how an array of eight 
  values might be stored. Conceptually, 
  the array is an array of symbolic names [BLACK, RED, WHITE, BLUE, ...]. See 
  item a in the figure below. <!-- formerly Figure 40a --> 
  These are stored as the values and are short integers. So, the first 2 bytes 
  are the value associated with &ldquo;BLACK&rdquo;, which is the number 4, 
  and so on. See item b in the figure below. <!-- formerly Figure 40b --></p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
      <table align="center" width="100%">
	  <tr>
	    <td align="center">a) Logical data to be written - 
            eight elements</td>
	  </tr>
		<tr>
		  <td align="center">
		    <table>
			  <tr>
			    <td width="50" align="center">Index</td>
				<td width="135" align="center">Name</td>
			  </tr>
		    </table>
		    <table border="1">
			  <tr>
			    <td width="30" align="center">0</td>
				<td width="130" align="left">:BLACK</td>
			  </tr>
			  <tr>
			    <td width="30" align="center">1</td>
				<td width="130" align="left">RED</td>
			  </tr>
			  <tr>
			    <td width="30" align="center">2</td>
				<td width="130" align="left">WHITE</td>
			  </tr>
			  <tr>
			    <td width="30" align="center">3</td>
				<td width="130" align="left">BLUE</td>
			  </tr>
			  <tr>
			    <td width="30" align="center">4</td>
				<td width="130" align="left">RED</td>
			  </tr>
			  <tr>
			    <td width="30" align="center">5</td>
				<td width="130" align="left">WHITE</td>
			  </tr>
			  <tr>
			    <td width="30" align="center">6</td>
				<td width="130" align="left">BLUE</td>
			  </tr>
			  <tr>
			    <td width="30" align="center">7</td>
				<td width="130" align="left">GREEN</td>
			  </tr>
		    </table>
		  </td>
		</tr>
		<tr><td>&nbsp;</td></tr>
		<tr>
		  <td align="center"><img src="Images/Dtypes_fig40.JPG"></td>
		</tr>
		<tr>
		  <td align="center">b) The storage layout. Total size of the 
                  array is 16 bytes, 2 bytes per element.
		  </td>
		</tr>

      </table>
    </td>
    </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 19. Storing an enum array
        <!-- formerly Figure 40 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>The order that members are inserted into an enumeration type is 
  unimportant; the important part is the associations between the symbol 
  names and the values. Thus, two enumeration datatypes will be considered 
  equal if and only if both types have the same symbol/value associations 
  and both have equal underlying integer datatypes. Type equality is 
  tested with the <code>H5Tequal</code> function.</p>

  <p>If a particular architecture type is required, a little-endian or 
  big-endian datatype for example, use a native integer datatype as the 
  ENUM base datatype and use <code>H5Tconvert</code> on values as they 
  are read from or written to a dataset. </p>
  
  <!-- NEW PAGE -->
<h4>6.5.4. Opaque</h4>
  
  <p>In some cases, a user may have data objects that should be stored and 
  retrieved as blobs with no attempt to interpret them.  For example, 
  an application might wish to store an array of encrypted certificates 
  which are 100 bytes long.</p>
  
  <p>While an arbitrary block of data may always be stored as bytes, 
  characters, integers, or whatever, this might mislead programs about 
  the meaning of the data. The opaque datatype defines data elements which 
  are uninterpreted by HDF5. The opaque data may be labeled with 
  <code>H5Tset_tag</code> with a string that might be used by an 
  application. For example, the encrypted certificates might have 
  a tag to indicate the encryption and the certificate standard.</p>

<h4>6.5.5. Bitfield</h4>
  
  <p>Some data is represented as bits, where the number of bits is not an 
  integral byte and the bits are not necessarily interpreted as a standard 
  type. Some examples might include readings from machine registers (e.g., 
  switch positions), a cloud mask, or data structures with several small 
  integers that should be store in a single byte.</p>
  
  <p>This data could be stored as integers, strings, or enumerations.  
  However, these storage methods would likely result in considerable wasted 
  space. For example, storing a cloud mask with one byte per value would 
  use up to eight times the space of a packed array of bits. </p>
  
  <p>The HDF5 bitfield datatype class defines a data element that is a 
  contiguous sequence of bits, which are stored on disk in a packed array. 
  The programming model is the same as for unsigned integers:  the datatype 
  object is created by copying a predefined datatype, and then the 
  precision, offset, and padding are set.</p>

  <p>While the use of the bitfield datatype will reduce storage space 
  substantially, there will still be wasted space if the bitfield as a 
  whole does not match the 1-, 2-, 4-, or 8-byte unit in which it is 
  written.  The remaining unused space can be removed by applying the 
  <a href="10_Datasets.html#N-Bit">N-bit filter</a> to the dataset 
  containing the bitfield data. </p>

<!--
<h4>5.6. Time</h4>

  <p>The HDF5 time datatype defines storage layout for various date and 
  time standards. Currently, only Unix "time" and "timeval" structs are 
  supported. The H5T_UNIX_D32BE (LE) defines storage for 4 bytes 
  (sufficient for the time struct), H5T_UNIX_D64BE (LE) is sufficient 
  for timeval.  The data is treated as a single opaque value.</p>
-->
  
<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="Fvalues">
<div align=right>
<a href="#TOP"><font size="-1">(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>


<a name="Fvalues">
<h3 class=pagebefore>6.6. Fill Values</h3>
</a>

  <p>The &ldquo;fill value&rdquo; for a dataset is the specification of 
  the default value assigned to data elements that have not yet been 
  written. In the case of a dataset with an atomic datatype, the fill 
  value is a single value of the appropriate datatype, such as 
  &lsquo;0&rsquo; or &lsquo;-1.0&rsquo;. In the case of a dataset with 
  a composite datatype, the fill value is a single data element of the 
  appropriate type. For example, for an array or compound datatype, 
  the fill value is a single data element with values for all the 
  component elements of the array or compound datatype.</p>
  
  <p>The fill value is set (permanently) when the dataset is created. 
  The fill value is set in the dataset creation properties 
<!-- editingComment
  <span class="editingComment">[ [ [
  (see chapter ??) 
  ] ] ]</span>
-->
  in the <code>H5Dcreate</code> call. Note that the <code>H5Dcreate</code> 
  call must also include the datatype of the dataset, and the value provided 
  for the fill value will be interpreted as a single element of this datatype. 
  The example below <!-- formerly Figure 41 -->shows code which creates a 
  dataset of integers with fill 
  value -1. Any unwritten data elements will be set to -1.</p>
  
<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  hid_t       plist_id;  
  int filler;

  filler = -1;
  plist_id = H5Pcreate(H5P_DATASET_CREATE);
  H5Pset_fill_value(plist_id, H5T_NATIVE_INT, &amp;filler);

  /* Create the dataset with fill value &lsquo;-1&rsquo;. */
  dataset_id = H5Dcreate(file_id, &ldquo;/dset&rdquo;, H5T_STD_I32BE, 
      dataspace_id, H5P_DEFAULT, plist_id, H5P_DEFAULT);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 35. Create a dataset with a fill value of -1
        <!-- formerly Figure 41 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />
<br />


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  typedef struct s1_t {
  int    a;
  char  b;
  double c; 
  } s1_t;
  s1_t       filler;

  s1_tid = H5Tcreate (H5T_COMPOUND, sizeof(s1_t));
  H5Tinsert(s1_tid, &ldquo;a_name&rdquo;, HOFFSET(s1_t, a), H5T_NATIVE_INT);
  H5Tinsert(s1_tid, &ldquo;b_name&rdquo;, HOFFSET(s1_t, b), H5T_NATIVE_CHAR);
  H5Tinsert(s1_tid, &ldquo;c_name&rdquo;, HOFFSET(s1_t, c), H5T_NATIVE_DOUBLE);

  filler.a = -1;
  filler.b = &lsquo;*&rsquo;;
  filler.c = -2.0;

  plist_id = H5Pcreate(H5P_DATASET_CREATE);
  H5Pset_fill_value(plist_id, s1_tid, &amp;filler);

  /* Create the dataset with fill value (-1, &lsquo;*&rsquo;, -2.0). */
  dataset = H5Dcreate(file, datasetname, s1_tid, space, H5P_DEFAULT, 
      plist_id, H5P_DEFAULT);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 36. Create a fill value for a compound datatype
        <!-- formerly Figure 42 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>The figure above <!-- formerly Figure 42 -->shows how to create a fill 
  value for a compound datatype. The procedure is the same as the previous 
  example except the filler must be a structure with the correct fields. 
  Each field is initialized to the desired fill value.</p>
  

  <p>The fill value for a dataset can be retrieved by reading the dataset 
  creation properties of the dataset and then by reading the fill value with 
  <code>H5Pget_fill_value</code>. The data will be read into memory using 
  the storage layout specified by the datatype. This transfer will convert 
  data in the same way as <code>H5Dread</code>. 

  The figure below <!-- formerly Figure 43 --> shows how to get the fill 
  value from the dataset created in Example 33 above.</p>
  
<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  hid_t plist2;
  int filler;
  
  dataset_id = H5Dopen(file_id, &ldquo;/dset&rdquo;, H5P_DEFAULT);
  plist2 = H5Dget_create_plist(dataset_id);

  H5Pget_fill_value(plist2, H5T_NATIVE_INT, &amp;filler);

  /* filler has the fill value, &lsquo;-1&rsquo; */</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 37. Retrieve a fill value
        <!-- formerly Figure 43 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>A similar procedure is followed for any datatype. The example below 
  <!-- formerly Figure 45 -->shows how to 
  read the fill value for the compound datatype created in an example above 
  <!-- formerly Figure 42 -->. Note that the program must pass an 
  element large enough to hold a fill value of the datatype indicated by the 
  argument to <code>H5Pget_fill_value</code>.  Also, the program must 
  understand the datatype in order to interpret its components. This may 
  be difficult to determine without knowledge of the application that 
  created the dataset.</p>
  


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  char *       fillbuf;
  int sz;
  dataset = H5Dopen( file, DATASETNAME, H5P_DEFAULT);

  s1_tid = H5Dget_type(dataset);

  sz = H5Tget_size(s1_tid);

  fillbuf = (char *)malloc(sz);

  plist_id = H5Dget_create_plist(dataset);

  H5Pget_fill_value(plist_id, s1_tid, fillbuf);

  printf(&ldquo;filler.a: %d\n&rdquo;,((s1_t *) fillbuf)-&gt;a);
  printf(&ldquo;filler.b: %c\n&rdquo;,((s1_t *) fillbuf)-&gt;b);
  printf(&ldquo;filler.c: %f\n&rdquo;,((s1_t *) fillbuf)-&gt;c);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 38. Read the fill value for a compound datatype
        <!-- formerly Figure 44 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="CCDtypes">
<div align=right>
<a href="#TOP"><font size="-1">(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<!-- NEW PAGE -->
<a name="CCDtypes">
<h3 class=pagebefore>6.7. Complex Combinations of Datatypes</h3>
</a>

  
  <p>Several composite datatype classes define collections of other datatypes, 
  including other composite datatypes.  In general, a datatype can be nested 
  to any depth, with any combination of datatypes.</p>
  
  <p>For example, a compound datatype can have members that are other compound 
  datatypes, arrays, VL datatypes.  An array can be an array of array, 
  an array of compound, or an array of VL.  And a VL datatype can be a 
  variable-length array of compound, array, or VL datatypes.</p>

  <p>These complicated combinations of datatypes form a logical tree, 
  with a single root datatype, and leaves which must be atomic datatypes 
  (predefined or user-defined). The figure below <!-- formerly Figure 45 --> 
  shows an example of a logical 
  tree describing a compound datatype constructed from different datatypes.</p>

  <p>Recall that the datatype is a description of the layout of storage. 
  The complicated compound datatype is constructed from component datatypes, 
  each of which describe the layout of part of the storage. Any datatype can 
  be used as a component of a compound datatype, with the following 
  restrictions:</p>

  <ol>
      <li>No byte can be part of more than one component datatype (i.e., the 
          fields cannot overlap within the compound datatype)</li><br />
      <li>The total size of the components must be less than or equal to the 
          total size of the compound datatype</li>
  </ol>
  
  <p>These restrictions are essentially the rules for C structures and similar 
  record types familiar from programming languages.  Multiple typing, such 
  as a C union, is not allowed in HDF5 datatypes.</p>
  

<table width="500" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dtypes_fig45.JPG">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 20. A compound datatype built with 
        different datatypes<!-- formerly Figure 45 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



<!-- NEW PAGE -->
<h4>6.7.1. Creating a Complicated Compound Datatype</h4>
  
  <p>To construct a complicated compound datatype, each component is 
  constructed, and then added to the enclosing datatype description. 
  The example below <!-- formerly Figure 46 --> shows  
  how to create a compound datatype with four members:</p>
  
  <ul>
      <li>&ldquo;T1&rdquo;, a compound datatype with three members</li>
      <li>&ldquo;T2&rdquo;, a compound datatype with two members</li>
      <li>&ldquo;T3&rdquo;, a one-dimensional array of integers</li>
      <li>&ldquo;T4&rdquo;, a string</li>
  </ul>
  
  <p>Below the example code is a figure that shows this datatype as a logical 
  tree. <!-- formerly Figure 47 --> The output of the 
  <em>h5dump</em> utility is shown in the example below the figure. 
  <!-- the example was formerly called Figure 48.--></p>
  
  <p>Each datatype is created as a separate datatype object. Figure 20 below 
  <!-- formerly Figure 49 --> shows 
  the storage layout for the four individual datatypes. Then the datatypes are 
  inserted into the outer datatype at an appropriate offset. Figure 21 below 
  <!-- formerly Figure 50 -->shows 
  the resulting storage layout. The combined record is 89 bytes long.</p>
  
  <p>The Dataset is created using the combined compound datatype. The dataset 
  is declared to be a 4 by 3 array of compound data.  Each data element is an 
  instance of the 89-byte compound datatype. Figure 22 below 
  <!-- formerly Figure 51 -->shows the layout of 
  the dataset, and expands one of the elements to show the relative position 
  of the component data elements.</p>
  
  <p>Each data element is a compound datatype, which can be written or read 
  as a record, or each field may be read or written individually. The first 
  field (&ldquo;T1&rdquo;) is itself a compound datatype with three fields 
  (&ldquo;T1.a&rdquo;, &ldquo;T1.b&rdquo;, and &ldquo;T1.c&rdquo;). 
  &ldquo;T1&rdquo; can be read or written as a record, or individual 
  fields can be accessed. Similarly, the second filed is a compound datatype 
  with two fields (&ldquo;T2.f1&rdquo;, &ldquo;T2.f2&rdquo;).</p>
  
  <p>The third field (&ldquo;T3&rdquo;) is an array datatype.  Thus, 
  &ldquo;T3&rdquo; should be accessed as an array of 40 integers. Array 
  data can only be read or written as a single element, so all 40 
  integers must be read or written to the third field. The fourth 
  field (&ldquo;T4&rdquo;) is a single string of length 25.</p>
  
<!-- NEW PAGE -->

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  typedef struct s1_t {
  int    a;
  char  b;
  double c; 
  } s1_t;

  typedef struct s2_t {
  float f1;
  float f2;
  } s2_t;
  hid_t      s1_tid, s2_tid, s3_tid, s4_tid, s5_tid;

  /* Create a datatype for s1 */
  s1_tid = H5Tcreate (H5T_COMPOUND, sizeof(s1_t));
  H5Tinsert(s1_tid, &ldquo;a_name&rdquo;, HOFFSET(s1_t, a), H5T_NATIVE_INT);
  H5Tinsert(s1_tid, &ldquo;b_name&rdquo;, HOFFSET(s1_t, b), H5T_NATIVE_CHAR);
  H5Tinsert(s1_tid, &ldquo;c_name&rdquo;, HOFFSET(s1_t, c), H5T_NATIVE_DOUBLE);

  /* Create a datatype for s2. *.
  s2_tid = H5Tcreate (H5T_COMPOUND, sizeof(s2_t));
  H5Tinsert(s2_tid, &ldquo;f1&rdquo;, HOFFSET(s2_t, f1), H5T_NATIVE_FLOAT);
  H5Tinsert(s2_tid, &ldquo;f2&rdquo;, HOFFSET(s2_t, f2), H5T_NATIVE_FLOAT);

  /* Create a datatype for an Array of integers */
  s3_tid = H5Tarray_create(H5T_NATIVE_INT, RANK, dim);

  /* Create a datatype for a String of 25 characters */
  s4_tid = H5Tcopy(H5T_C_S1);
  H5Tset_size(s4_tid, 25);

  /* 
   * Create a compound datatype composed of one of each of these
   *  types.
   * The total size is the sum of the size of each.
   */ 

  sz = H5Tget_size(s1_tid) + H5Tget_size(s2_tid) + H5Tget_size(s3_tid) 
       + H5Tget_size(s4_tid);
  
  s5_tid = H5Tcreate (H5T_COMPOUND, sz);

  /* insert the component types at the appropriate offsets */

  H5Tinsert(s5_tid, &ldquo;T1&rdquo;, 0, s1_tid);
  H5Tinsert(s5_tid, &ldquo;T2&rdquo;, sizeof(s1_t), s2_tid);
  H5Tinsert(s5_tid, &ldquo;T3&rdquo;, sizeof(s1_t)+sizeof(s2_t), s3_tid);
  H5Tinsert(s5_tid, &ldquo;T4&rdquo;, (sizeof(s1_t) +sizeof(s2_t)+ 
          H5Tget_size(s3_tid)), s4_tid);

  /* 
   * Create the dataset with this datatype.
   */
  dataset = H5Dcreate(file, DATASETNAME, s5_tid, space, H5P_DEFAULT, 
      H5P_DEFAULT, H5P_DEFAULT);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 39. Create a compound datatype with four members
        <!-- formerly Figure 46 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />
<br />



<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
    <img src="Images/Dtypes_fig47.JPG">
    </td>
  </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 21. Logical tree for the compound 
        datatype with four members<!-- formerly Figure 47 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />
<br />



<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  DATATYPE  H5T_COMPOUND {
   H5T_COMPOUND {
      H5T_STD_I32LE &ldquo;a_name&rdquo;;
      H5T_STD_I8LE &ldquo;b_name&rdquo;;
      H5T_IEEE_F64LE &ldquo;c_name&rdquo;;
   } &ldquo;T1&rdquo;;
   H5T_COMPOUND {
      H5T_IEEE_F32LE &ldquo;f1&rdquo;;
      H5T_IEEE_F32LE &ldquo;f2&rdquo;;
   } &ldquo;T2&rdquo;;
   H5T_ARRAY { [10] H5T_STD_I32LE } &ldquo;T3&rdquo;;
   H5T_STRING {
      STRSIZE 25;
      STRPAD H5T_STR_NULLTERM;
      CSET H5T_CSET_ASCII;
      CTYPE H5T_C_S1;
   } &ldquo;T4&rdquo;;
  }</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 40. Output from h5dump for the compound datatype
        <!-- formerly Figure 48 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />
<br />




<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
	  <table align="center" border="0" width="100%">
	    <tr>
		  <td valign="middle" align="left">a) Compound type &lsquo;s1_t&rsquo;, size 16 bytes.</td>
	    </tr>	     	  
		<tr><td>
		
	  <table border="1" align="center" width="100%">
		<tr>
	      <td valign="middle" align="center" width="25%"><code>Byte 0</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 1</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 2</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 3</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>aaaaaaaa</code></td>
		  <td valign="middle" align="center"><code>aaaaaaaa</code></td>
		  <td valign="middle" align="center"><code>aaaaaaaa</code></td>
		  <td valign="middle" align="center"><code>aaaaaaaa</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>Byte 4</code></td>
		  <td valign="middle" align="center"><code>Byte 5</code></td>
		  <td valign="middle" align="center"><code>Byte 6</code></td>
		  <td valign="middle" align="center"><code>Byte 7</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>bbbbbbbb</code></td>
		  <td valign="middle" align="center"><code>&nbsp;</code></td>
		  <td valign="middle" align="center"><code>&nbsp;</code></td>
		  <td valign="middle" align="center"><code>&nbsp;</code></td>
		</tr>
	  </table>
	  
	  <table border="1" align="center" width="100%">
		<tr>
	      <td valign="middle" align="center" width="25%"><code>Byte 8</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 9</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 10</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 11</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>Byte 12</code></td>
		  <td valign="middle" align="center"><code>Byte 13</code></td>
		  <td valign="middle" align="center"><code>Byte 14</code></td>
		  <td valign="middle" align="center"><code>Byte 15</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		</tr>
	  </table>
	  
	  </td></tr>
	  <tr>
	    <td valign="middle" align="left">&nbsp;<br />b) Compound type &lsquo;s2_t&rsquo;, size 8 bytes.</td>
	  </tr>	  

	  <tr><td>
      
	  <table border="1" align="center" width="100%">
	    <tr>
		  <td valign="middle" align="center" width="25%"><code>Byte 0</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 1</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 2</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 3</code></td>
	      </tr>
		<tr>
		  <td valign="middle" align="center"><code>ffffffff</code></td>
		  <td valign="middle" align="center"><code>ffffffff</code></td>
		  <td valign="middle" align="center"><code>ffffffff</code></td>
		  <td valign="middle" align="center"><code>ffffffff</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>Byte 4</code></td>
		  <td valign="middle" align="center"><code>Byte 5</code></td>
		  <td valign="middle" align="center"><code>Byte 6</code></td>
		  <td valign="middle" align="center"><code>Byte 7</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>gggggggg</code></td>
		  <td valign="middle" align="center"><code>gggggggg</code></td>
		  <td valign="middle" align="center"><code>gggggggg</code></td>
		  <td valign="middle" align="center"><code>gggggggg</code></td>
		</tr>	
      </table>
	  
	  </td></tr>
      <tr>
	    <td valign="middle" align="left">&nbsp;<br />c) Array type &lsquo;s3_tid&rsquo;, 40 integers, total size 40 bytes.</td>
	  </tr>
		
	  <tr><td>
	  
	  <table border="1" align="center" width="100%">
	    <tr>
		  <td valign="middle" align="center" width="25%"><code>Byte 0</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 1</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 2</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 3</code></td>
	      </tr>
		<tr>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>00000000</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>Byte 4</code></td>
		  <td valign="middle" align="center"><code>Byte 5</code></td>
		  <td valign="middle" align="center"><code>Byte 6</code></td>
		  <td valign="middle" align="center"><code>Byte 7</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>00000001</code></td>
		</tr>	
      </table>
	  
	  <table align="center" width="100%">
		<tr>
		  <td align="center" colspan="4">&nbsp;...&nbsp;<br />&nbsp;</td>
		</tr>
	  </table>
	  
	  <table border="1" align="center" width="100%">
        <tr>
		  <td valign="middle" align="center" width="25%"><code>Byte 36</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 37</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 38</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 39</code></td>
	      </tr>
		<tr>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>00001010</code></td>
		</tr>
	  </table>
	  
	  </td></tr>
      <tr>
	    <td valign="middle" align="left">&nbsp;<br />d) String type &lsquo;s4_tid&rsquo;, size 25 bytes.</td>
	  </tr>
	  <tr><td>
	  
	  <table border="1" align="center" width="100%">
		<tr>
	      <td valign="middle" align="center" width="25%"><code>Byte 0</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 1</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 2</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 3</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>&lsquo;a&rsquo;</code></td>
		  <td valign="middle" align="center"><code>&lsquo;b&rsquo;</code></td>
		  <td valign="middle" align="center"><code>&lsquo;c&rsquo;</code></td>
		  <td valign="middle" align="center"><code>&lsquo;d&rsquo;</code></td>
		</tr>
	  </table>
	  
	  <table align="center" width="100%">
		<tr>
		  <td align="center" colspan="4">&nbsp;...&nbsp;<br />&nbsp;</td>
		</tr>
	  </table>
	  
	  <table border="1" align="center" width="100%">
		<tr>
	      <td valign="middle" align="center" width="25%"><code>Byte 24</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 25</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 26</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 27</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>00000000</code></td>
		  <td valign="middle" align="center"><code>&nbsp;</code></td>
		  <td valign="middle" align="center"><code>&nbsp;</code></td>
		  <td valign="middle" align="center"><code>&nbsp;</code></td>
		</tr>
	  </table>
	  
	  </td></tr>	  
	  </table>
	  
    </td></tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 22. The storage layout for the 
        four member datatypes<!-- formerly Figure 49 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />
<br />




<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dtypes_fig50.JPG" width="550">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 23. The storage layout of the combined four members
        <!-- formerly Figure 50 --></b>
        <hr color="green" size="3"/></td>
  </tr>
</table>
<br />
<br />

<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/></td>
        </tr>
    <tr align="center">
        <td align="center"><img src="Images/Dtypes_fig51.JPG" 
        width="550"></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 24. The layout of the dataset
        <!-- formerly Figure 51 --></b>
        <hr color="green" size="3"/></td>
        </tr>
<!-- 9.1.10, the JPG above, Dtypes_fig51.jpg, spells Element incorrectly -->
<!-- 9.1.10, the section above has text and many examples and figures. 
Should the text be interspersed with the examples and figures at some 
point? -->
</table>
<br />



<!-- NEW PAGE -->
<h4>6.7.2. Analyzing and Navigating a Compound Datatype</h4>
  
  <p>A complicated compound datatype can be analyzed piece by piece to 
  discover the exact storage layout. In the example above, the outer 
  datatype is analyzed to discover that it is a compound datatype with 
  four members. Each member is analyzed in turn to construct a complete 
  map of the storage layout.</p>
  
  <p>The example below <!-- formerly Figure 52 -->shows an example of code 
  that partially analyzes a nested 
  compound datatype. The name and overall offset and size of the component 
  datatype is discovered, and then its type is analyzed depending on the 
  datatype class. Through this method, the complete storage layout can be 
  discovered.</p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  s1_tid = H5Dget_type(dataset);

  if (H5Tget_class(s1_tid) == H5T_COMPOUND) {
      printf(&ldquo;COMPOUND DATATYPE {\n&rdquo;);
      sz = H5Tget_size(s1_tid);
      nmemb = H5Tget_nmembers(s1_tid);
      printf(&ldquo;  %d bytes\n&rdquo;,sz);
      printf(&ldquo;  %d members\n&rdquo;,nmemb);
      for (i =0; i &lt; nmemb; i++) {
        s2_tid = H5Tget_member_type(s1_tid, i);
        if (H5Tget_class(s2_tid) == H5T_COMPOUND) {
            /* recursively analyze the nested type. */
      
        } else if (H5Tget_class(s2_tid) == H5T_ARRAY) {
            sz2 = H5Tget_size(s2_tid);
            printf(&ldquo;  %s: NESTED ARRAY DATATYPE offset %d size %d  {\n&rdquo;,
                H5Tget_member_name(s1_tid, i),
                H5Tget_member_offset(s1_tid, i),
                 sz2);
                H5Tget_array_dims(s2_tid, dim);
                 s3_tid = H5Tget_super(s2_tid);
                /* Etc., analyze the base type of the array */
        } else {
                /* analyze a simple type */
                printf(&ldquo;    %s: type code %d offset %d size %d\n&rdquo;,
                              H5Tget_member_name(s1_tid, i),
                              H5Tget_class(s2_tid),
                              H5Tget_member_offset(s1_tid, i),
                              H5Tget_size(s2_tid));
        }
        /* and so on…. */</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 41. Analyzing a compound datatype and its members
        <!-- formerly Figure 52--></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="LCDtypeObj">
<div align=right>
<a href="#TOP"><font size="-1">(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>
<br />

<!-- NEW PAGE -->
<a name="LCDtypeObj">
<h3 class=pagebefore>6.8. Life Cycle of the Datatype Object</h3>
</a>

  <p>Application programs access HDF5 datatypes through identifiers. 
  Identifiers are obtained by creating a new datatype or by copying 
  or opening an existing datatype. The identifier can be used until 
  it is closed or until the library shuts down. See items a and b in 
  the figure below. <!-- formerly Figure 53a,b --> By default, a 
  datatype is <em>transient</em>, and it disappears when it is closed. </p>
  
  <p>When a dataset or attribute is created (<code>H5Dcreate</code> or 
  <code>H5Acreate</code>), its datatype is stored in the HDF5 
  file as part of the dataset or attribute object. See item c in 
  the figure below. Once an object created, its datatype cannot 
  be changed or deleted. The datatype can be accessed by calling 
  <code>H5Dget_type</code>, <code>H5Aget_type</code>, 
  <code>H5Tget_super</code>, or <code>H5Tget_member_type</code>. 
  See item d in the figure below. These calls return an identifier to a 
  <em>transient</em> copy of the datatype of the dataset or attribute 
  unless the datatype is a committed datatype. </p>
  
  <p>Note that when an object is created, the stored datatype is a copy 
  of the transient datatype. If two objects are created with the same 
  datatype, the information is stored in each object with the same 
  effect as if two different datatypes were created and used. </p>
  
  <p>A transient datatype can be stored using <code>H5Tcommit</code> in the 
  HDF5 file as an independent, named object, called a committed datatype. 
  Committed datatypes were formerly known as named datatypes. 
  See item e in the figure below. Subsequently, when a committed datatype 
  is opened with <code>H5Topen</code> (item f), or is obtained with 
  <code>H5Tget_type</code> or similar call (item k), the return 
  is an identifier to a transient copy of the stored datatype. The identifier 
  can be used in the same way as other datatype identifiers except that 
  the committed datatype cannot be modified. When a committed datatype is 
  copied with <code>H5Tcopy</code>, the return is a new, modifiable, 
  transient datatype object (item f). </p>
  
  <p>When an object is created using a committed datatype (<code>H5Dcreate</code>, 
  <code>H5Acreate</code>), the stored datatype is used without copying 
  it to the object. See item j in the figure below. In this case, if 
  multiple objects are created using the same committed datatype, they 
  all share the exact same datatype object. This saves space and makes 
  clear that the datatype is shared. Note that a committed datatype can 
  be shared by objects within the same HDF5 file, but not by objects 
  in other files. For more information on copying committed datatypes to 
  other HDF5 files, see the 
  &ldquo;Copying Committed Datatypes with H5Ocopy&rdquo; topic in 
  the &ldquo;<a href="17_Additional.html">Additional Resources</a>&rdquo; 
  chapter.</p>
  
  <p>A committed datatype can be deleted from the file by calling 
  <code>H5Ldelete</code> which replaces <code>H5Gunlink</code>. 
  See item i in the figure below.  If one or more objects are still using the 
  datatype, the committed datatype cannot be accessed with <code>H5Topen</code>, 
  but will not be removed from the file until it is no longer used. 
  <code>H5Tget_type</code> and similar calls will return a transient 
  copy of the datatype.</p>


<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
    <img src="Images/Dtypes_fig53.JPG">
    </td>
  </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 25. Life cycle of a datatype
        <!-- formerly Figure 53 --> </b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>Transient datatypes are initially modifiable. Note that 
  when a datatype is copied or when it is written to the file (when an 
  object is created) or the datatype is used to create a composite 
  datatype, a copy of the current state of the datatype is used. If 
  the datatype is then modified, the changes have no effect on 
  datasets, attributes, or datatypes that have already been created. 
  See the figure below.</p>

  <p>A transient datatype can be made <em>read-only</em> 
  (<code>H5Tlock</code>). Note that the datatype is still transient, 
  and otherwise does not change. A datatype that is <em>immutable</em> 
  is <em>read-only</em> but cannot be closed except when the entire 
  library is closed. The predefined types such as 
  <code>H5T_NATIVE_INT</code> are <em>immutable transient</em> types.</p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dtypes_fig54.JPG">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 26. Transient datatype states: modifiable, read-only, and 
        immutable <!-- formerly Figure 54 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>To create two or more datasets that share a common datatype, 
  first commit the datatype, and then use that datatype to create the 
  datasets. See the example below.</p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  hid_t t1 = ...some transient type...;
  H5Tcommit (file, &ldquo;shared_type&rdquo;, t1, H5P_DEFAULT, H5P_DEFAULT, 
      H5P_DEFAULT);
  hid_t dset1 = H5Dcreate (file, &ldquo;dset1&rdquo;, t1, space, H5P_DEFAULT, 
      H5P_DEFAULT, H5P_DEFAULT);
  hid_t dset2 = H5Dcreate (file, &ldquo;dset2&rdquo;, t1, space, H5P_DEFAULT, 
      H5P_DEFAULT, H5P_DEFAULT);
               

  hid_t dset1 = H5Dopen (file, &ldquo;dset1&rdquo;, H5P_DEFAULT);
  hid_t t2 = H5Dget_type (dset1);
  hid_t dset3 = H5Dcreate (file, &ldquo;dset3&rdquo;, t2, space, H5P_DEFAULT, 
      H5P_DEFAULT, H5P_DEFAULT);
  hid_t dset4 = H5Dcreate (file, &ldquo;dset4&rdquo;, t2, space, H5P_DEFAULT, 
      H5P_DEFAULT, H5P_DEFAULT);</pre> </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 42. Create a shareable datatype
        <!-- formerly Figure 55 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />
<br />




<!-- NEW PAGE -->

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 23. Datatype APIs</b> 
        <!-- formerly Table 24 --></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="50%"><b>Function</b></td>
        <td width="50%"><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>hid_t H5Topen (hid_t location, <br />const 
        char *name)</code></td>
        <td>A committed datatype can be opened by 
        calling this function, which returns a datatype identifier. The 
        identifier should eventually be released by calling 
        <code>H5Tclose()</code> to release resources. The committed 
        datatype returned by this function is read-only or a negative 
        value is returned for failure. The location is either a file or 
        group identifier.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Tcommit (hid_t location, 
        const char *name, hid_t type, H5P_DEFAULT, H5P_DEFAULT, 
        <br />H5P_DEFAULT)</code></td>
        <td>A transient datatype (not immutable) can 
        be written to a file and turned into a committed datatype by calling this 
        function. The location is either a file or group identifier and when 
        combined with name refers to a new committed datatype.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>htri_t H5Tcommitted 
        (hid_t type)</code></td>
        <td>A type can be queried to determine 
        if it is a committed type or a transient type. If this function returns a 
        positive value then the type is committed. Datasets which return committed 
        datatypes with <code>H5Dget_type()</code> are able to share the 
        datatype with other datasets in the same file.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />



<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="Dtransfer">
<div align=right>
<a href="#TOP"><font size="-1">(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>
<br />
<!-- NEW PAGE -->
<a name="Dtransfer">
<h3 class=pagebefore>6.9. Data Transfer: Datatype Conversion and Selection</h3>
</a>

  <p>When data is transferred (write or read), the storage layout of the data 
  elements may be different. For example, an integer might be stored on disk 
  in big-endian byte order and read into memory with little-endian byte order. 
  In this case, each data element will be transformed by the HDF5 Library 
  during the data transfer.</p>
  
  <p>The conversion of data elements is controlled by specifying the datatype 
  of 
  the source and specifying the intended datatype of the destination. 
  The storage format on disk is the datatype specified when the dataset 
  is created. The datatype of memory must be specified in the library call.</p>
  
  <p>In order to be convertible, the datatype of the source and destination 
  must have the same datatype class (with the exception of enumeration 
  type). Thus, integers can be converted to other integers, and floats to 
  other floats, but integers cannot (yet) be converted to floats. For 
  each atomic datatype class, the possible conversions are defined. An 
  enumeration datatype can be converted to an integer or a 
  floating-point number datatype.</p>
  
  <p>Basically, any datatype can be converted to another datatype of the same 
  datatype class. The HDF5 Library automatically converts all properties. 
  If the destination is too small to hold the source value then an overflow 
  or underflow exception occurs. If a handler is defined with the 
  <code>H5Pset_type_conv_cb</code> function, 
<!-- editingComment
  <span class="editingComment">[ [ [
  (see Chapter??) 
  ] ] ]</span>
-->
  it will be called. Otherwise, 
  a default action will be performed. The table below <!-- formerly Table 25-->
  summarizes the default actions.</p>
  

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Table 24. Default actions for datatype conversion exceptions</b>
        <!-- formerly Table 25 --></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td><b>Datatype Class</b></td>
        <td><b>Possible Exceptions</b></td>
        <td><b>Default Action</b></td>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Integer</td>
        <td>Size, offset, pad</td>
        <td>&nbsp;</td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Float</td>
        <td>Size, offset, pad, ebits</td>
        <td>&nbsp;</td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>String</td>
        <td>Size</td>
        <td>Truncates, zero terminate if required.</td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Enumeration</td>
        <td>No field</td>
        <td>All bits set</td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />




  <p>For example, when reading data from a dataset, the source datatype is the 
  datatype set when the dataset was created, and the destination datatype is 
  the description of the storage layout in memory. The destination datatype 
  must be specified in 
  the <code>H5Dread</code> call. The example below <!-- formerly Figure 56 --> 
  shows an example of reading a dataset 
  of 32-bit integers. The figure <!-- formerly Figure 57 -->below the example 
  shows the data transformation 
  that is performed.</p>
  


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  /* Stored as H5T_STD_BE32 */
  /* Use the native memory order in the destination */
  mem_type_id = H5Tcopy(H5T_NATIVE_INT);
  status = H5Dread(dataset_id, mem_type_id, mem_space_id, 
                  file_space_id,  xfer_plist_id,  buf );</pre> </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 43. Specify the destination datatype 
        with <code>H5Dread</code><!-- formerly Figure 56 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />
<br />



<!-- NEW PAGE -->

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
	  
	<table align="center" width="100%">
	  <tr><td>
	  
	  <table align="left">
	    <tr>
		  <td align="left">Source Datatype: <code>H5T_STD_BE32</code></td>
	      </tr>
	  </table>
	  
	  </td></tr>
	  <tr><td>
	  
	  <table align="left" border="1" width="100%">
	    <tr>
		  <td valign="middle" align="center" width="25%"><code>Byte 0</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 1</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 2</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 3</code></td>
	      </tr>
		<tr>
		  <td valign="middle" align="center"><code>aaaaaaaa</code></td>
		  <td valign="middle" align="center"><code>bbbbbbbb</code></td>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		  <td valign="middle" align="center"><code>dddddddd</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>Byte 4</code></td>
		  <td valign="middle" align="center"><code>Byte 5</code></td>
		  <td valign="middle" align="center"><code>Byte 6</code></td>
		  <td valign="middle" align="center"><code>Byte 7</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>wwwwwwww</code></td>
		  <td valign="middle" align="center"><code>xxxxxxxx</code></td>
		  <td valign="middle" align="center"><code>yyyyyyyy</code></td>
		  <td valign="middle" align="center"><code>zzzzzzzz</code></td>
		</tr>
	  </table>
		
	  </td></tr>
	  <tr>
	    <td>.&nbsp;.&nbsp;.&nbsp;.</td>
	  </tr>
	  <tr><td>
	  
	  <table align="center" width="100%">
	    <tr>
		  <td width="45%">&nbsp;</td>
		  <td width="10%" align="center"><img src="Images/Dtypes_fig57_arrow.jpg"></td>
		  <td width="45%" align="left">Automatically byte swapped<br /> during the <code>H5Dread</code></td>
	      </tr>
	  </table>
	  
	  </td></tr>
	  <tr><td>
	  
      <table align="left">
	    <tr>
		  <td align="left">Destination Datatype: <code>H5T_STD_LE32</code></td>
	      </tr>
	  </table>
	  
      </td></tr>
	  <tr><td>
	  
	  <table align="left" border="1" width="100%">
	    <tr>
		  <td valign="middle" align="center" width="25%"><code>Byte 0</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 1</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 2</code></td>
		  <td valign="middle" align="center" width="25%"><code>Byte 3</code></td>
	      </tr>
		<tr>
		  <td valign="middle" align="center"><code>bbbbbbbb</code></td>
		  <td valign="middle" align="center"><code>aaaaaaaa</code></td>
		  <td valign="middle" align="center"><code>dddddddd</code></td>
		  <td valign="middle" align="center"><code>cccccccc</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>Byte 4</code></td>
		  <td valign="middle" align="center"><code>Byte 5</code></td>
		  <td valign="middle" align="center"><code>Byte 6</code></td>
		  <td valign="middle" align="center"><code>Byte 7</code></td>
		</tr>
		<tr>
		  <td valign="middle" align="center"><code>xxxxxxxx</code></td>
		  <td valign="middle" align="center"><code>wwwwwwww</code></td>
		  <td valign="middle" align="center"><code>zzzzzzzz</code></td>
		  <td valign="middle" align="center"><code>yyyyyyyy</code></td>
		</tr>
	  </table>
	  
      </td></tr>
	  <tr>
	    <td>.&nbsp;.&nbsp;.&nbsp;.</td>
	  </tr>
	  <tr><td>	  
	</table>
	
    </td></tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 27. Layout of a datatype conversion
        <!-- formerly Figure 57 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />




  <p>One thing to note in the example above <!-- formerly Figure 56 -->is the 
  use of the predefined native datatype <code>H5T_NATIVE_INT</code>. 
  Recall that in this example, the data was stored as a 4-bytes 
  in big-endian order. The application wants to read this data into an array 
  of integers in memory. Depending on the system, the storage layout of memory 
  might be either big or little-endian, so the data may need to be transformed 
  on some platforms and not on others.  The <code>H5T_NATIVE_INT</code> type 
  is set by the HDF5 Library to be the correct type to describe the storage 
  layout of the memory on the system. Thus, the code in the example above 
  <!-- Figure 56 -->will work correctly on any platform, performing a 
  transformation when needed.</p>
  
  <p>There are predefined native types for most atomic datatypes, and 
  these can be combined in composite datatypes. In general, the predefined 
  native datatypes should always be used for data stored in memory.</p>
  

<table align="center" width="300" >
    <tr >
        <td style="background-color:#E6F2E6">
        <hr color="green" size="3"/>
        <b>Storage Properties </b><br />
        <p>Predefined native datatypes describe the storage properties 
        of memory.</p>
        <hr color="green" size="3"/></td>
        </tr>
  </table>
<br />



  <p>For composite datatypes, the component atomic datatypes will be converted. 
  For a variable-length datatype, the source and destination must have 
  compatible base datatypes. For a fixed-size string datatype, the length 
  and padding of the strings will be converted. Variable-length strings 
  are converted as variable-length datatypes.</p>
  
  <p>For an array datatype, the source and destination must have the same rank 
  and dimensions, and the base datatype must be compatible.  For example an 
  array datatype of 4 x 3 32-bit big-endian integers can be transferred to an 
  array datatype of 4 x 3 little-endian integers, but not to a 3 x 4 array.</p>
  
  <p>For an enumeration datatype, data elements are converted by matching the 
  symbol names of the source and destination datatype. The figure below 
  <!-- formerly Figure 58 -->shows an example 
  of how two enumerations with the same names and different values would be 
  converted. The value &lsquo;2&rsquo; in the source dataset would be converted 
  to &lsquo;0x0004&rsquo; in the destination.</p>
  
  <p>If the source data stream contains values which are not in the domain of 
  the conversion map then an overflow exception is raised within the library.</p>
  

<table width="400" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
	
	<table border="0">
	  <tr>
	    <td width="%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">RED</td>
		<td width="%"><img src="Images/Dtypes_fig58_arrow.jpg"></td>
		<td align="right" width="%">RED</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">&nbsp;0x0001</td>
	  </tr>
	  <tr>
	    <td width="%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">GREEN&nbsp;&nbsp;</td>
		<td width="%"><img src="Images/Dtypes_fig58_arrow.jpg"></td>
		<td align="right" width="%">&nbsp;&nbsp;GREEN</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">&nbsp;0x0002</td>
	  </tr>
	  <tr>
	    <td width="%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">BLUE</td>
		<td width="%"><img src="Images/Dtypes_fig58_arrow.jpg"></td>
		<td align="right" width="%">BLUE</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">&nbsp;0x0004</td>
	  </tr>
	  <tr>
	    <td width="%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">WHITE</td>
		<td width="%"><img src="Images/Dtypes_fig58_arrow.jpg"></td>
		<td align="right" width="%">WHITE</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">&nbsp;0x0008</td>
	  </tr>
	  <tr>
	    <td width="%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">BLACK&nbsp;&nbsp;</td>
		<td width="%"><img src="Images/Dtypes_fig58_arrow.jpg"></td>
		<td align="right" width="%">&nbsp;&nbsp;BLACK</td>
		<td width="%">&nbsp;&nbsp;</td>
		<td width="%">&nbsp;0x0010</td>
	  </tr>
	</table>
    </td></tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 28. An enum datatype conversion
        <!-- formerly Figure 58 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>The library also allows conversion from enumeration to a numeric 
  datatype. A numeric datatype is either an integer or a floating-point 
  number. This conversion can simplify the application program because 
  the base type for an enumeration datatype is an integer datatype. The 
  application program can read the data from a dataset of enumeration 
  datatype in file into a memory buffer of numeric datatype. And it can 
  write enumeration data from memory into a dataset of numeric datatype 
  in file, too. </p>

  <p>For compound datatypes, each field of the source and destination 
  datatype is converted according to its type. The name of the fields 
  must be the same in the source and the destination in order for the 
  data to be converted. </p>
  
  <p>The example below <!-- formerly Figure 59 -->shows the compound 
  datatypes shows sample code to create a 
  compound datatype with the fields aligned on word boundaries (s1_tid) 
  and with the fields packed (s2_tid). The former is suitable as a description 
  of the storage layout in memory, the latter would give a more compact store 
  on disk. These types can be used for transferring data, with 
  <code>s2_tid</code> used to create the dataset, and 
  <code>s1_tid</code> used as the memory datatype.</p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  typedef struct s1_t {                
    int    a;         
    char  b;                  
    double c;          
  } s1_t;
          s1_tid = H5Tcreate (H5T_COMPOUND, sizeof(s1_t));
  H5Tinsert(s1_tid, &ldquo;a_name&rdquo;, HOFFSET(s1_t, a), H5T_NATIVE_INT);
  H5Tinsert(s1_tid, &ldquo;b_name&rdquo;, HOFFSET(s1_t, b), H5T_NATIVE_CHAR);
  H5Tinsert(s1_tid, &ldquo;c_name&rdquo;, HOFFSET(s1_t, c), H5T_NATIVE_DOUBLE);

  s2_tid = H5Tcopy(s1_tid);
  H5Tpack(s2_tid);</pre> </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 44. Create an aligned and packed compound datatype 
        <!-- formerly Figure 59 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>When the data is transferred, the fields within each data element will be 
  aligned according to the datatype specification. The figure below 
  <!-- formerly Figure 60 -->shows how one data 
  element would be aligned in memory and on disk. Note that the size and byte 
  order of the elements might also be converted during the transfer.</p>
  
  <p>It is also possible to transfer some of the fields of compound datatypes. 
  Based on the example above, <!-- formerly Figure 59 --> the example below 
  <!-- formerly Figure 61 -->shows a compound datatype 
  that selects the first and third fields of the <code>s1_tid</code>. 
  The second datatype can be used as the memory datatype, in which case data 
  is read from or written to these two fields, while skipping the middle field. 
  The second figure below <!-- formerly Figure 62 -->shows the layout for 
  two data elements.</p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dtypes_fig60.JPG" width="550">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 29. Alignment of a compound datatype 
        <!-- formerly Figure 60 --></b>
        <hr color="green" size="3"/></td>
  </tr>
</table>
<br />
<br />



<!-- NEW PAGE -->

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  typedef struct s1_t {                
    int    a;         
    char  b;                  
    double c;          
  } s1_t;

  typedef struct s2_t {   /* two fields from s1_t */             
     int    a;                           
     double c;          
  } s2_t;
 
        s1_tid = H5Tcreate (H5T_COMPOUND, sizeof(s1_t));
  H5Tinsert(s1_tid, &ldquo;a_name&rdquo;, HOFFSET(s1_t, a), H5T_NATIVE_INT);
  H5Tinsert(s1_tid, &ldquo;b_name&rdquo;, HOFFSET(s1_t, b), H5T_NATIVE_CHAR);
  H5Tinsert(s1_tid, &ldquo;c_name&rdquo;, HOFFSET(s1_t, c), H5T_NATIVE_DOUBLE);

  s2_tid = H5Tcreate (H5T_COMPOUND, sizeof(s2_t));
  H5Tinsert(s1_tid, &ldquo;a_name&rdquo;, HOFFSET(s2_t, a), H5T_NATIVE_INT);
  H5Tinsert(s1_tid, &ldquo;c_name&rdquo;, HOFFSET(s2_t, c), H5T_NATIVE_DOUBLE);
        </pre> </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 45. Transfer some fields of a compound datatype
        <!-- formerly Figure 61 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />
<br />



<!-- NEW PAGE -->


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dtypes_fig62.JPG" width="550">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 30. Layout when an element is skipped
        <!-- formerly Figure 62 --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />




<!-- NEW PAGE -->
<a name="TextDescriptions">
<h3 class=pagebefore>6.10. Text Descriptions of Datatypes: Conversion to 
and from</h3></a>

  <p>HDF5 provides a means for generating a portable and human-readable 
    text descripition of a datatype and 
    for generating a datatype from such a text description.
    This capability is particularly useful 
    for creating complex datatypes in a single step,
    for creating a text description of a datatype for debugging purposes, 
    and for creating a portable datatype definition that can then be used
    to recreate the datatype on many platforms or in other applications.</p>
    
  <p>These tasks are handled by two functions provided in the HDF5 high-level 
    library (<a href="../HL/RM_H5LT.html" target="ExtWin">H5HL</a>):</p>
    <div align="left">
    <table >
      <tr valign="top" align="left">
        <td><span class="codeText">H5LTtext_to_dtype</span>&nbsp;&nbsp;&nbsp;&nbsp;</td>
	<td>Creates an HDF5 datatype in a single step.</td>
      </tr><tr valign="top" align="left">
        <td><span class="codeText">H5LTdtype_to_text</span></td>
	<td>Translates an HDF5 datatype into a text description.</td>
      </tr>
    </table>
    </div>
  <p>Note that this functionality requires that the 
    HDF5 High-Level Library (H5LT) be installed. 
<!-- editingComment
    See 
    <span class="editingComment">&lt; &lt; Quick Start &gt; &gt;</span>.
-->
  <p>While <span class="codeText">H5LTtext_to_dtype</span> can be used to 
    generate any sort of datatype, it is particularly useful for 
    complex datatypes. </p>
    
  <p><span class="codeText">H5LTdtype_to_text</span> is most likely to be
    used in two sorts of situations: 
    when a datatype must be closely examined for debugging purpose 
    or to create a portable text description of the datatype
    that can then be used to recreate the datatype on other platforms 
    or in other applications.</p>

   <p>These two functions work for all valid HDF5 datatypes
     except time, bitfield, and reference datatypes.</p>

  <p>The currently supported text format used by 
    <span class="codeText">H5LTtext_to_dtype</span> and 
    <span class="codeText">H5LTdtype_to_text</span> is the
    data description language (DDL) and conforms to the 
    <a href="../ddl.html" target="ExtWin"><cite>HDF5 DDL</cite></a>.  
    The portion of the <cite>HDF5 DDL</cite> that defines HDF5 datatypes  
    appears below.
  </p>


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  &lt;datatype&gt; ::= &lt;atomic_type&gt; | &lt;compound_type&gt; | &lt;array_type&gt; |
          &lt;variable_length_type&gt;

  &lt;atomic_type&gt; ::= &lt;integer&gt;  | &lt;float&gt;  | &lt;time&gt;      | &lt;string&gt; |
                    &lt;bitfield&gt; | &lt;opaque&gt; | &lt;reference&gt; | &lt;enum&gt;

  &lt;integer&gt; ::=  H5T_STD_I8BE     | H5T_STD_I8LE      |
                 H5T_STD_I16BE    | H5T_STD_I16LE     |
                 H5T_STD_I32BE    | H5T_STD_I32LE     |
                 H5T_STD_I64BE    | H5T_STD_I64LE     |
                 H5T_STD_U8BE     | H5T_STD_U8LE      |
                 H5T_STD_U16BE    | H5T_STD_U16LE     |
                 H5T_STD_U32BE    | H5T_STD_U32LE     |
                 H5T_STD_U64BE    | H5T_STD_U64LE     |
                 H5T_NATIVE_CHAR  | H5T_NATIVE_UCHAR  |
                 H5T_NATIVE_SHORT | H5T_NATIVE_USHORT |
                 H5T_NATIVE_INT   | H5T_NATIVE_UINT   |
                 H5T_NATIVE_LONG  | H5T_NATIVE_ULONG  |
                 H5T_NATIVE_LLONG | H5T_NATIVE_ULLONG

  &lt;float&gt; ::= H5T_IEEE_F32BE   | H5T_IEEE_F32LE     |
              H5T_IEEE_F64BE   | H5T_IEEE_F64LE     |
              H5T_NATIVE_FLOAT | H5T_NATIVE_DOUBLE  |
              H5T_NATIVE_LDOUBLE

  &lt;time&gt; ::= TBD

  &lt;string&gt; ::= H5T_STRING { STRSIZE &lt;strsize&gt; ;
    STRPAD &lt;strpad&gt; ;
    CSET &lt;cset&gt; ;
    CTYPE &lt;ctype&gt; ;}
  
  &lt;strsize&gt; ::= &lt;int_value&gt; | H5T_VARIABLE
  &lt;strpad&gt; ::= H5T_STR_NULLTERM | H5T_STR_NULLPAD | H5T_STR_SPACEPAD
  &lt;cset&gt; ::= H5T_CSET_ASCII | H5T_CSET_UTF8
  &lt;ctype&gt; ::= H5T_C_S1 | H5T_FORTRAN_S1

  &lt;bitfield&gt; ::= TBD

  &lt;opaque&gt; ::= H5T_OPAQUE { OPQ_SIZE &lt;opq_size&gt;;
            OPQ_TAG &lt;opq_tag&gt;; }
  opq_size ::= &lt;int_value&gt;
  opq_tag ::= "&lt;string&gt;"

  &lt;reference&gt; ::= Not supported

  &lt;compound_type&gt; ::= H5T_COMPOUND { &lt;member_type_def&gt;+ }
  &lt;member_type_def&gt; ::= &lt;datatype&gt; &lt;field_name&gt; &lt;offset&gt;<font size=1.7>opt</font> ;
  &lt;field_name&gt; ::= "&lt;identifier&gt;"
  &lt;offset&gt; ::= : &lt;int_value&gt;

  &lt;variable_length_type&gt; ::= H5T_VLEN { &lt;datatype&gt; }

  &lt;array_type&gt; ::= H5T_ARRAY { &lt;dim_sizes&gt; &lt;datatype&gt; }
  &lt;dim_sizes&gt; ::= [&lt;dimsize&gt;] | [&lt;dimsize&gt;] &lt;dim_sizes&gt;
  &lt;dimsize&gt; ::= &lt;int_value&gt;

  &lt;enum&gt; ::= H5T_ENUM { &lt;enum_base_type&gt;; &lt;enum_def&gt;+ }
  &lt;enum_base_type&gt; ::= &lt;integer&gt;
  // Currently enums can only hold integer type data, but they may be 
  //expanded in the future to hold any datatype
  &lt;enum_def&gt; ::= &lt;enum_symbol&gt; &lt;enum_val&gt;;
  &lt;enum_symbol&gt; ::= "&lt;identifier&gt;"
  &lt;enum_val&gt; ::= &lt;int_value&gt;
        </pre>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 46. The definition of HDF5 datatypes from the 
        <!-- formerly Figure 63: -->
        <a href="../ddl.html" target="ExtWin"><cite>HDF5 DDL</cite></a></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>The definitions of opaque and compound datatype above are  
    revised for HDF5 Release 1.8.  In Release 1.6.5. and earlier, 
    they were were defined as follows:
  </p>


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  &lt;opaque&gt; ::= H5T_OPAQUE { &lt;identifier&gt; }


  &lt;compound_type&gt; ::= H5T_COMPOUND { &lt;member_type_def&gt;+ }
  &lt;member_type_def&gt; ::= &lt;datatype&gt; &lt;field_name&gt; ;
  &lt;field_name&gt; ::= &lt;identifier&gt;</pre>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 47. 
        <!-- formerly Figure 64: -->
        Old definitions of the opaque and compound datatypes</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />




<h4><em>Examples</em></h4>

  <p>The code sample below illustrates the use of
    <span class="codeText">H5LTtext_to_dtype</span> to generate a
    variable-length string datatype.
  </p>


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  hid_t   dtype;
  if((dtype = H5LTtext_to_dtype(&ldquo;H5T_STRING { 
                                             STRSIZE H5T_VARIABLE; 
                                             STRPAD H5T_STR_NULLPAD; 
                                             CSET H5T_CSET_ASCII; 
                                             CTYPE H5T_C_S1; 
                                            }&rdquo;, H5LT_DDL))&lt;0)
          goto out;</pre>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 48. Creating a variable-length string datatype from 
        a text description<!-- formerly Figure 65: --></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>The code sample below illustrates the use of
    <span class="codeText">H5LTtext_to_dtype</span> to generate a
    complex array datatype.
  </p>



<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
        <pre>
  hid_t   dtype;
  if((dtype = H5LTtext_to_dtype(&ldquo;H5T_ARRAY { [5][7][13] H5T_ARRAY 
                                             { [17][19] H5T_COMPOUND
                                               {                 
                                                        H5T_STD_I8BE 
                                                          \&ldquo;arr_compound_1\&rdquo;; 
                                                        H5T_STD_I32BE 
                                                          \&ldquo;arr_compound_2\&rdquo;; 
                                               } 
                                             } 
                                           }&rdquo;, H5LT_DDL))<0)
          goto out;</pre>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 49. <!-- formerly Figure 66: -->
        Creating a complex array datatype from a text description</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />
<br />
<br />

<!-- NEW PAGE -->
</body>
</html> 


