gXMLBuffer ="<?xml version=\"1.0\" encoding=\"utf-8\" ?><data>   <entry name=\"hyperslab\" value=\"The more general case of a hyperslab&#160;can also be a regular pattern of points or blocks within the dataspace. Four parameters are required to describe a general hyperslab: the starting coordinates, the block size, the stride or space between blocks, and the number of blocks. These parameters are each expressed as a one-dimensional array with length equal to the rank of the dataspace and are described in the table below.\" />   <entry name=\"incremental allocation\" value=\"Incremental allocation (chunks only) is done at the time of the first write to the chunk. Chunks that have never been written are not allocated in the file. In a sparsely populated dataset, this option allocates chunks only where data is actually written.\" />   <entry name=\"late allocation\" value=\"Late allocation is done at the time of the first write to dataset. Space for the whole dataset is allocated at the first write.\" />   <entry name=\"link\" value=\"A link is, in effect, a path by which the target object can be accessed; it therefore has a name which func­tions as a single path component. A link can be removed with an H5Ldelete&#160;call, effectively removing the target object from the group that contained the link (assuming, of course, that the removed link was the only link to the target object in the group).\" />   <entry name=\"major message\" value=\"In the example above, we can see that an error record&#160;has a major message and a minor message. A major message&#160;generally indicates where the error happens. The location can be a dataset or a dataspace, for example. A minor message&#160;explains further details of the error. An example is “unable to open file”. Another specific detail about the error can be found at the end of the first line of each error record. This error description&#160;is usually added by the library designer to tell what exactly goes wrong. In the example above, the “predefined datatype” is an error description.\" />   <entry name=\"memory datatype\" value=\"The memory layout of a single data element is specified by the memory datatype. This specifies the size, alignment, and byte order of the element as well as the datatype class. Note that the memory datatype must be the same datatype class as the file, but may have different byte order and other properties. The HDF5 Library automatically transforms data elements between the source and destination layouts. For more information, see &quot;HDF5 Datatypes&quot; on page&#160;173.\" />   <entry name=\"memory space\" value=\"The calling program must allocate sufficient memory to store the data elements to be transferred. For a write (from memory to the file), the memory must be initialized with the data to be written to the file. For a read, the memory must be large enough to store the elements that will be read. The amount of storage needed can be computed from the memory datatype (which defines the size of each data element) and the number of elements in the selection.\" />   <entry name=\"minor message\" value=\"In the example above, we can see that an error record&#160;has a major message and a minor message. A major message&#160;generally indicates where the error happens. The location can be a dataset or a dataspace, for example. A minor message&#160;explains further details of the error. An example is “unable to open file”. Another specific detail about the error can be found at the end of the first line of each error record. This error description&#160;is usually added by the library designer to tell what exactly goes wrong. In the example above, the “predefined datatype” is an error description.\" />   <entry name=\"n-bit datatype\" value=\"An n-bit datatype&#160;is a datatype of n&#160;significant bits. Unless it is packed, an n-bit datatype is presented as an n-bit bitfield within a larger-sized value. For example, a 12-bit datatype might be presented as a 12-bit field in a 16-bit, or 2-byte, value.\" />   <entry name=\"n-bit filter\" value=\"When data of an n-bit datatype is stored on disk using the n-bit filter, the filter packs&#160;the data by stripping off the padding bits; only the significant bits are retained and stored. The values on disk will appear as fol­lows:\" />   <entry name=\"named datatype\" value=\"A datatype can be shared by more than one dataset in the file if the datatype is saved to the file with a name. This shareable datatype is known as a committed datatype. In the past, this kind of datatype was called a named datatype.\" />   <entry name=\"no-op datatype\" value=\"At present, the n-bit filter supports all datatypes. For datatypes of class time, string, opaque, reference, ENUM, and variable-length, the n-bit filter acts as a no-op which is short for no operation. For conve­nience, the rest of this section refers to such datatypes as no-op datatypes.\" />   <entry name=\"null dataspace\" value=\"A null dataspace, H5S_NULL, contains no data elements. Note that no selections can be applied to a null dataset as there is nothing to select.\" />   <entry name=\"primary data object\" value=\"An HDF5 attribute&#160;is a small metadata object describing the nature and/or intended usage of a primary data object. A primary data object may be a dataset, group, or committed datatype.\" />   <entry name=\"scalar dataspace\" value=\"A scalar dataspace, H5S_SCALAR, represents just one element, a scalar. Note that the datatype of this one element may be very complex; example would be a compound structure with members being of any allowed HDF5 datatype, including multidimensional arrays, strings, and nested compound structures. By convention, the rank of a scalar dataspace is always 0 (zero); think of it geometrically as a single, dimen­sionless point, though that point may be complex.\" />   <entry name=\"selections\" value=\"The previous section described writing or reading an entire dataset. HDF5 also supports access to portions of a dataset. These parts of datasets are known as selections.\" />   <entry name=\"self-describing\" value=\"The structure of an HDF5 file is self-describing, meaning that an application can navigate an HDF5 file to discover and understand all the objects it contains. This is an iterative process wherein the structure is tra­versed as a graph, starting at one node and recursively visiting linked nodes. To explore the entire file, the traversal should start at the root group.\" />   <entry name=\"simple dataspace\" value=\"A simple dataspace, H5S_SIMPLE, is a multidimensional array of elements. The dimensionality of the dataspace (or the rank of the array) is fixed and is defined at creation time. The size of each dimension can grow during the life time of the dataspace from the current size&#160;up to the maximum size. Both the current size and the maximum size are specified at creation time. The sizes of dimensions at any particular time in the life of a dataspace are called the current dimensions, or the dataspace extent. They can be queried along with the maximum sizes.\" />   <entry name=\"simple hyperslab\" value=\"The simplest type of selection is a simple hyperslab. This is an n-dimensional rectangular sub-set of a dataset where n is equal to the dataset’s rank. Other available selections include a more complex hyper­slab with user-defined stride and block size, a list of independent points, or the union of any of these.\" />   <entry name=\"storage properties\" value=\"Storage properties of the dataset are set when it is created. The required inputs table below shows the categories of storage properties. The storage properties cannot be changed after the dataset is created.\" />   <entry name=\"symbolic link\" value=\"Symbolic links&#160;are objects that assign a name in a group to a path. Notably, the target object is determined only when the symbolic link is accessed, and may, in fact, not exist. Symbolic links are not reference counted, so there may be zero, one, or more symbolic links to an object.\" />  </data>";