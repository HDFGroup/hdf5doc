<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<head>
<title>Chapter 2: The HDF5 Library and Programming Model</title>

<!--(Meta)==========================================================-->

<!--(Links)=========================================================-->

<!--( Begin styles definition )=====================================-->
<link href="ed_styles/NewUGelect.css" rel="stylesheet" type="text/css">
<!--( End styles definition )=======================================-->

</head> 

<body>

<!-- #BeginLibraryItem "/ed_libs/styles_UG.lbi" -->
<!--
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  * Copyright by The HDF Group.                                               *
  * Copyright by the Board of Trustees of the University of Illinois.         *
  * All rights reserved.                                                      *
  *                                                                           *
  * This file is part of HDF5.  The full HDF5 copyright notice, including     *
  * terms governing use, modification, and redistribution, is contained in    *
  * the files COPYING and Copyright.html.  COPYING can be found at the root   *
  * of the source code distribution tree; Copyright.html can be found at the  *
  * root level of an installed copy of the electronic HDF5 document set and   *
  * is linked from the top-level documents page.  It can also be found at     *
  * http://hdfgroup.org/HDF5/doc/Copyright.html.  If you do not have          *
  * access to either file, you may request a copy from help@hdfgroup.org.     *
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 -->
<!-- #EndLibraryItem --><!--( TOC )=========================================================-->
<SCRIPT language="JavaScript">
<!--
document.writeln (' \
<table x-use-null-cells\
                align="right"\
		width="240"\
		cellspacing="0"\
		class="tocTable">\
  <tr valign="top"> \
    <td class="tocTableHeaderCell" colspan="2"> \
        <span class="TableHead">Chapter Contents</span></td>\
  </tr>\
-->
<!-- Table Version 3 -->\
<!--
  <tr valign="top"> \
    <td class="tocTableContentCell2"> \
      <a href="#Intro">1.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#Intro">Introduction</a></td> \
  </tr>\
  <tr valign="top"> \
    <td class="tocTableContentCell2"> \
      <a href="#ProgModel">2.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#ProgModel">Programming Model</a><br />\
    <font size="-1">\
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
    <a href="#CreateFile">Create file</a>\
    <br /> \
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
    <a href="#CreateDataset">Create dataset</a>\
    <br /> \
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
    <a href="#CloseObject">Close objects</a>\
    <br /> \
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
    <a href="#WriteRead">Write and read</a>\
    <br /> \
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
    <a href="#PartialWR">Partial write/read</a>\
    <br /> \
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
    <a href="#GetInfo">Get information</a>\
    <br /> \
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
    <a href="#CreateCDType">Create compound</a>\
    <br /> \
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
    <a href="#CreateCDType">datatype</a>\
    <br /> \
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
    <a href="#ExtendChunked">Create extendable or</a>\
    <br /> \
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
    <a href="#ExtendChunked">chunked dataset</a>\
	  </td>\
  </tr>\
\
  <tr valign="top"> \
    <td class="tocTableContentCell"> \
-->
<!-- editingComment -- "tocTableContentCell" and "tocTableContentCell4" \
-->\
<!-- are the table-closing cell class.\
    <td class="tocTableContentCell2"> \
-->\
<!--
      <a href="#IOPipeline">3.</a></td>\
    <td class="tocTableContentCell4">\
	  <a href="#IOPipeline">Data Transfer Pipeline</a>\
-->
<!-- editingComment -- This section not currently complete or validated.\
  </tr><tr valign="top"> \
    <td class="tocTableContentCell"> \
    <a href="#Appendix">10</a></td>\
    <td class="tocTableContentCell4"><a href="#Appendix">Appendix</a></td>\
-->\
<!--
  </td></tr>\
</table>\
')
-->
</SCRIPT>
<!--(End TOC 1)=====================================================-->

<!--( TOC 2 )=======================================================-->
<!--
<table x-use-null-cells
                align="right"
		width="240"
		cellspacing="0"
		class="tocTable">
  <tr valign="top"> 
    <td class="tocTableHeaderCell"> 
    <span class="TableHead">Chapter Contents</span></td>
  </tr>
  <tr valign="top"> 
    <td class="tocTableContentCell"> 
    <a href="#Intro">1. Introduction</a>
    <br /> 
    <a href="#AbstractDMod">2. Abstract Data Model</a>
    <br /> 
    <a href="#SModel">3. HDF5 Storage Model</a> 
    <br /> 
    <a href="#LibPModel">4. Library and</a>
    <br /> 
    &nbsp;&nbsp;&nbsp;&nbsp;<a href="#LibPModel">Programming Model</a>
    <br /> 
    <a href="#IOPipeline">3. Data Transfer Pipeline</a> 
    <br /> 
    &nbsp;&nbsp;&nbsp;&nbsp;<a href="#Structure">HDF5 File</a>
    </td>
  </tr>
</table>
-->
<!--(End TOC 2)=====================================================-->

<div align="center">
<a name="TOP">
<h2>Chapter 2<br /><font size="6">The HDF5 Library and Programming Model</font></h2>
</a>
</div>


<!-- editingComment
  <span class="editingComment">[ [ [
  ] ] ]</span>
-->

<!-- HEADER LEFT " " -->
<!-- HEADER RIGHT " " -->

<!-- HEADER LEFT "HDF5 User's Guide" -->
<!-- HEADER RIGHT "HDF5 Library and Programming Model" -->


<a name="Intro">
<h3>2.1. Introduction</h3>
</a>








<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="LibPModel">
<div align="right">
<a href="#TOP"><font size="-1">(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>
  

  <p>The HDF5 Library implements the HDF5 abstract data model and storage 
  model. These models were described in the preceding chapter, 
  &ldquo;<a href="03_DataModel.html">The HDF5 Data Model</a>&rdquo;. </p>

  <p>Two major objectives of the HDF5 products are to provide tools 
  that can be used on as many computational platforms as possible 
  (portability), and to provide a reasonably object-oriented data model
  and programming interface. </p>

<!-- editingComment
  <span class="editingComment">[ [ [
  Explain?  E.g., Java is portable, 
  but there are many platforms on which it does not run. 
  ] ] ]</span>
-->
  
  <p>To be as portable as possible, the HDF5 Library is implemented in 
  portable C. C is not an object-oriented language, but the library uses 
  several mechanisms and conventions to implement an object model.</p>
  
  <p>One mechanism the HDF5 library uses is to implement the objects 
  as data structures. To refer to an object, the HDF5 library implements 
  its own pointers. These pointers are called identifiers. 
  An identifier is then used to invoke operations on a specific instance 
  of an object. For example, when a group is opened,  
  the API returns a group identifier. This identifier is a reference to that 
  specific group and will be used to invoke future operations on that group. 
  The identifier is valid only within the context it is created 
  and remains valid until it is closed or the file is closed.
  This mechanism is essentially the same as the mechanism that C++ or 
  other object-oriented languages use to refer to objects except that the 
  syntax is C. </p>

  <p>Similarly, object-oriented languages collect all the methods for 
  an object in a single name space. An example is the methods of a C++ class. 
  The C language does not have any such mechanism, 
  but the HDF5 Library simulates this through its API naming convention. 
  API function names begin with a common prefix that is related to the 
  class of objects that the function operates on. 
  The table below lists the HDF5 objects and the standard prefixes 
  used by the corresponding HDF5 APIs. 
  For example, functions that operate on datatype objects all have names 
  beginning with H5T.</p>

<!-- NEW PAGE -->
<table width="300" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 1. The HDF5 API naming scheme</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top">
        <td>
        <b>Prefix&nbsp;</b></td>
        <td>
        <b>Operates on&nbsp;&nbsp;</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>H5A</td>
        <td>Attributes </td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>H5D</td>
        <td>Datasets </td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>H5E</td>
        <td>Error reports</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>H5F</td>
        <td>Files</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>H5G</td>
        <td>Groups</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>H5I</td>
        <td>Identifiers</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>H5L</td>
        <td>Links</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>H5O</td>
        <td>Objects</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>H5P</td>
        <td>Property lists</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>H5R</td>
        <td>References</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>H5S</td>
        <td>Dataspaces</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>H5T</td>
        <td>Datatypes</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td>H5Z</td>
        <td>Filters</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />

 

<!-- NEW PAGE -->
<a name="ProgModel">
<h3>2.2. The HDF5 Programming Model</h3>
</a>

  <p>In this section we introduce the HDF5 
  <span class="termDefinition">programming model</span> by means of 
  a series of short code samples. These samples illustrate a broad 
  selection of common HDF5 tasks. More details are provided in the 
  following chapters and in the 
  <a href="../RM/RM_H5Front.html" TARGET="H5DocWin"> 
  <cite>HDF5 Reference Manual</cite></a></p>

<!-- editingComment
  <span class="editingComment"><p>[ [ [
  The following is based on text from the old "Intro to HDF5"  
  and presumably needs some technical verification.
  ] ] ]</span>
-->

<a name="CreateFile">
<h4>2.2.1. Creating an HDF5 File</h4></a>

  <p>Before an HDF5 file can be used or referred to in any manner, 
  it must be explicitly created or opened. When the need for access to 
  a file ends, the file must be closed. The example below provides a C 
  code fragment illustrating these steps. In this example, the values
  for the file creation property list and the file access property list
  are set to the defaults <code>H5P_DEFAULT</code>.</p>
  
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  hid_t       file;                 /* declare file identifier */
  /*
  * Create a new file using H5F_ACC_TRUNC 
  * to truncate and overwrite any file of the same name,
  * default file creation properties, and 
  * default file access properties.
  * Then close the file.
  */
  file = H5Fcreate(FILE, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
  status = H5Fclose(file); </pre></td>
    </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 1. Creating and closing an HDF5 file</b>
        <hr color="green" size="3"/></td>
        <!-- formerly Figure 1-->
        </tr>
</table>
<br />

  <p>Note: If there is a possibility that a file of the declared name
  already exists and you wish to open a new file regardless of that
  possibility, the flag <code>H5F_ACC_TRUNC</code> will cause the
  operation to overwrite the previous file. If the operation should
  fail in such a circumstance, use the flag <code>H5F_ACC_EXCL</code>
  instead.</p>
  



<a name="CreateDataset">
<h4>2.2.2. Creating and Initializing a Dataset</h4></a>
  
  <p>The essential objects within a dataset are datatype and dataspace. 
  These are independent objects and are created separately from any dataset 
  to which they may be attached. Hence, creating a dataset requires, 
  at a minimum, the following steps:</p>
  
  <ol> 
      <li>Create and initialize a dataspace for the dataset</li>
      <li>Define a datatype for the dataset</li>
      <li>Create and initialize the dataset</li>
  </ol>
  
<!-- NEW PAGE -->
  <p>The code in the example below illustrates the execution of these steps.</p>
  
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  hid_t    dataset, datatype, dataspace;  /* declare identifiers */
  
  /* 
   * Create a dataspace: Describe the size of the array and 
   * create the dataspace for a fixed-size dataset. 
   */
  dimsf[0] = NX;
  dimsf[1] = NY;
  dataspace = H5Screate_simple(RANK, dimsf, NULL); 
  /*
   * Define a datatype for the data in the dataset.
   * We will store little endian integers.
   */
  datatype = H5Tcopy(H5T_NATIVE_INT);
  status = H5Tset_order(datatype, H5T_ORDER_LE);
  /*
   * Create a new dataset within the file using the defined 
   * dataspace and datatype and default dataset creation
   * properties.
   * NOTE: H5T_NATIVE_INT can be used as the datatype if 
   * conversion to little endian is not needed.
   */
  dataset = H5Dcreate(file, DATASETNAME, datatype, dataspace,
              H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT); </pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 2. Create a dataset</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<a name="CloseObject">
<h4>2.2.3. Closing an Object </h4></a>
  
  <p>An application should close an object such as a datatype, dataspace, 
  or dataset once the object is no longer needed.
  Since each is an independent object, each must be released 
  (or closed) separately. This action is frequently referred to as 
  <span class="termDefinition">releasing the object&rsquo;s identifier</span>.
  The code in the example below <!-- formerly Figure 3 -->closes the 
  datatype, dataspace, and dataset that were created in the preceding 
  section.</p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  H5Tclose(datatype); 
  H5Dclose(dataset); 
  H5Sclose(dataspace);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 3. Close an object</b>
        <hr color="green" size="3"/></td>
        <!-- formerly Figure 3 -->
        </tr>
</table>
<br />

<p>There is a long list of HDF5 Library items that return a unique 
identifier when the item is created or opened. Each time that one of 
these items is opened, a unique identifier is returned. Closing a file 
does not mean that the groups, datasets, or other open items are also 
closed. Each opened item must be closed separately. </p>

<!-- FOR USE WITH ELECTRONIC VERSION --------------------------------->
<p>For more information, see 
<a href="../Advanced/UsingIdentifiers/index.html">&ldquo;Using Identifiers&rdquo;</a> 
in the &ldquo;Advanced Topics&rdquo; page.</p>

<!-- FOR USE WITH ELECTRONIC VERSION --------------------------------->


<!-- FOR USE WITH PRINT VERSION --------------------------------------
<p>For more information, see &ldquo;Using Identifiers&rdquo; in the 
&ldquo;Additional Resources&rdquo; chapter.</p>
<!-- FOR USE WITH PRINT VERSION -------------------------------------->


<a name="ClosingAFileNotes">
<h4>How Closing a File Effects Other Open Structural Elements</h4></a>
<p>Every structural element in an HDF5 file can be opened, and these 
elements can be opened more than once. Elements range in size from 
the entire file down to attributes. When an element is opened, the 
HDF5 Library returns a unique identifier to the application. Every 
element that is opened must be closed. If an element was opened more 
than once, each identifier that was returned to the application must 
be closed. For example, if a dataset was opened twice, both dataset 
identifiers must be released (closed) before the dataset can be 
considered closed. Suppose an application has opened a file, a group in 
the file, and two datasets in the group. In order for the file to be 
totally closed, the file, group, and datasets must each be closed. 
Closing the file before the group or the datasets will not effect the 
state of the group or datasets: the group and datasets will still be 
open.</p>

<p>There are several exceptions to the above general rule. One is when 
the <code>H5close</code> function is used. <code>H5close</code> causes a 
general shutdown of the library: all data is written to disk, all 
identifiers are closed, and all memory used by the library is 
cleaned up. Another exception occurs on parallel processing systems. 
Suppose on a parallel system an application has opened a file, a 
group in the file, and two datasets in the group. If the application 
uses the <code>H5Fclose</code> function to close the file, the call 
will fail with an error. The open group and datasets must be closed 
before the file can be closed. A third exception is when the file 
access property list includes the property <code>H5F_CLOSE_STRONG</code>. 
This property closes any open elements when the file is closed with 
<code>H5Fclose</code>. For more information, see the 
<a href="../RM/RM_H5P.html#Property-SetFcloseDegree">
<code>H5Pset_fclose_degree</code></a> function in the 
<cite>HDF5 Reference Manual</cite>.</p>

<a name="WriteRead">
<h4>2.2.4. Writing or Reading a Dataset to or from a File</h4></a>

  <p>Having created the dataset, the actual data can be written 
  with a call to <code>H5Dwrite</code>. See the example below.</p>

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  /*
  * Write the data to the dataset using default transfer
  * properties.
  */
  status = H5Dwrite(dataset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL,
            H5P_DEFAULT, data);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 4. Writing a dataset</b>
        <hr color="green" size="3"/></td>
        <!-- formerly Figure 4 -->
        </tr>
</table>
<br />

  <p>Note that the third and fourth <code>H5Dwrite</code> parameters in 
  the above example describe the dataspaces in memory and in the file, 
  respectively. For now, these are both set to <code>H5S_ALL</code> which 
  indicates that the entire dataset is to be written. 
  The selection of partial datasets and the use of differing dataspaces
  in memory and in storage will be discussed later in this chapter and 
  in more detail elsewhere in this guide.</p>
  
  <p>Reading the dataset from storage is similar to writing the dataset to 
  storage. To read an entire dataset, substitute <code>H5Dread</code> for 
  <code>H5Dwrite</code> in the above example.</p>


<a name="PartialWR">
<h4>2.2.5. Reading and Writing a Portion of a Dataset</h4>
</a>

  <p>The previous section described writing or reading an entire 
  dataset. HDF5 also supports access to portions of a dataset. These parts of
  datasets are known as <span class="termDefinition">selections</span>. 
  
  <p>The simplest type of selection is a 
  <span class="termDefinition">simple hyperslab</span>. This is 
  an <span class="codeVar">n</span>-dimensional rectangular sub-set of 
  a dataset where <span class="codeVar">n</span> is equal to the 
  dataset&rsquo;s rank. Other available selections include 
  a more complex hyperslab with user-defined stride and block size,
  a list of independent points, or the union of any of these.</p>

  <p>The figure below <!-- formerly Figure 5 -->shows several 
  sample selections.</p>
  
<!-- NEW PAGE -->

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Pmodel_fig5_a.jpg"><br />
        <img src="Images/Pmodel_fig5_b.jpg"><br />
        <img src="Images/Pmodel_fig5_c.jpg"><br />
        <img src="Images/Pmodel_fig5_d.jpg"><br />
        <img src="Images/Pmodel_fig5_e.jpg"><br />
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 1. Dataset selections</b><br />
        <!-- formerly Figure 5. -->
        Selections can take the form of a simple hyperslab, 
        a hyperslab with user-defined stride and block,
        a selection of points, or a union of any of these forms.
        <!--
            <span class="editingComment"><br />[ [ [ 
            Edit figures to retain... 
                upper left, 
                maybe a second simple hyperslab, 
                2nd left, 
                box on right (3-D point),
                and an interesting-looking union.
            None of the text in the JPEGs need be retained.
            Use new figure filenames as we are holding the current figure for possible reuse elsewhere.
            <br />
            If it's not already been done, remember that the original figure is to be used, in toto, 
            in the "Memory&lt;--&gt;Disk Data Transfer" discussion, with "Key" to add characters '(hyperslab)'
            immediately to the right of the hyperslab icon.
            ] ] ]</span>
            -->
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />


<!-- NEW PAGE -->
  <p>Selections and hyperslabs are portions of a dataset. 
  As described above, a <span class="termDefinition">simple hyperslab</span> 
  is a rectangular array of data elements with the same rank as the 
  dataset&rsquo;s dataspace. Thus, a simple hyperslab is a 
  logically contiguous collection of points within the dataset. </p>

  <p>The more general case of a <span class="termDefinition">hyperslab</span>
  can also be a regular pattern of points or blocks within the dataspace. 
  Four parameters are required to describe a general hyperslab: the 
  starting coordinates, the block size, the stride or space between 
  blocks, and the number of blocks. These parameters are each expressed 
  as a one-dimensional array with length equal to the rank of the dataspace 
  and are described in the table below 
  <!-- formerly table 2-->.</p>
  


<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 2. Hyperslab parameters</b>
        </td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td> 
        <b>Parameter&nbsp;&nbsp;</b></td>
        <td> 
        <b>Definition</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code><i>start</i></code></td>
        <td> 
        The coordinates of the starting location of the hyperslab 
        in the dataset&rsquo;s dataspace.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code><i>block</i></code></td>
        <td> 
        The size of each block to be selected from the dataspace. 
        If the <code>block</code> parameter is set to NULL, 
        the block size defaults to a single element in each dimension, 
        as if the block array was set to all <code>1</code>s (all ones).
        This will result in the selection of 
        a uniformly spaced set of <code>count</code> points 
        starting at <code>start</code> and 
        on the interval defined by <code>stride</code>.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code><i>stride</i></code></td>
        <td> 
        The number of elements separating the starting point of each element 
        or block to be selected. 
        If the <code>stride</code> parameter is set to NULL, 
        the stride size defaults to 1 (one) in each dimension 
        and no elements are skipped.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code><i>count</i></code></td>
        <td> 
        The number of elements or blocks to select along each dimension.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />

  <h4>Reading Data into a Differently Shaped Memory Block</h4>
  
  <p>For maximum flexibility in user applications, a selection in storage 
  can be mapped into a differently-shaped selection in memory. All that 
  is required is that the two selections contain the same number of data 
  elements. In this example, we will first define the selection to be 
  read from the dataset in storage, and then we will define the 
  selection as it will appear in application memory.</p>

  <p>Suppose we want to read a 3 x 4 hyperslab from a two-dimensional 
  dataset in a file beginning at the dataset element &lt;1,2&gt;. 
  The first task is to create the dataspace that describes the 
  overall rank and dimensions of the dataset in the file and to 
  specify the position and size of the in-file hyperslab that we 
  are extracting from that dataset. See the code below.  
  <!-- formerly Figure 6--></p>
    
<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  /* 
  * Define dataset dataspace in file.
  */
  dataspace = H5Dget_space(dataset);    /* dataspace identifier */
  rank      = H5Sget_simple_extent_ndims(dataspace);
  status_n  = H5Sget_simple_extent_dims(dataspace, dims_out, NULL);

  /* 
  * Define hyperslab in the dataset. 
  */
  offset[0] = 1;
  offset[1] = 2;
  count[0]  = 3;
  count[1]  = 4;
  status = H5Sselect_hyperslab(dataspace, H5S_SELECT_SET, offset, NULL, 
           count, NULL);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 5. Define the selection to be read from storage </b>
        <!-- formerly Figure 6.-->
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

  <p>The next task is to define a dataspace in memory. 
  Suppose that we have in memory a three-dimensional 7 x 7 x 3 array 
  into which we wish to read the two-dimensional 3 x 4 hyperslab 
  described above and that we want the memory selection to begin at 
  the element &lt;3,0,0&gt; and reside in the plane of the first two 
  dimensions of the array. Since the in-memory dataspace is 
  three-dimensional, we have to describe the in-memory selection as 
  three-dimensional. Since we are keeping the selection in the plane 
  of the first two dimensions of the in-memory dataset, the in-memory 
  selection will be a 3 x 4 x 1 array defined as &lt;3,4,1&gt;. </p>
  
<!-- NOT EDITED TO..... ----->
  <p>Notice that we must describe two things: the dimensions of the 
  in-memory array, and the size and position of the hyperslab that we 
  wish to read in. The code below <!--formerly Figure 7 -->illustrates 
  how this would be done.</p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  /*
  * Define memory dataspace.
  */
  dimsm[0] = 7;
  dimsm[1] = 7;
  dimsm[2] = 3;
  memspace = H5Screate_simple(RANK_OUT,dimsm,NULL);   

  /* 
  * Define memory hyperslab. 
  */
  offset_out[0] = 3;
  offset_out[1] = 0;
  offset_out[2] = 0;
  count_out[0]  = 3;
  count_out[1]  = 4;
  count_out[2]  = 1;
  status = H5Sselect_hyperslab(memspace, H5S_SELECT_SET, offset_out, NULL, 
           count_out, NULL);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 6. Define the memory dataspace and selection </b>
        <hr color="green" size="3"/></td>
        <!-- formerly Figure 7.-->
        </tr>
</table>
<br />

  <p>The hyperslab defined in the code above has the following parameters: 
  <code>start=(3,0,0)</code>, <code>count=(3,4,1)</code>, stride and 
  block size are <code>NULL</code>.</p>
<!-- .....TO HERE ----->  




  <h4>Writing Data into a Differently Shaped Disk Storage Block</h4>

  <p>Now let&rsquo;s consider the opposite process of 
  writing a selection from memory to a selection in a dataset in a file.
  Suppose that the source dataspace in memory is a 50-element, 
  one-dimensional array called <code>vector</code> 
  <!-- formerly Figure 8--> 
  and that the source selection is a 48-element simple hyperslab 
  that starts at the second element of <code>vector</code>. 
  See the figure below.</p>
  

<table width="400" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>

    <tr>
        <td align="center"><br />	  
        <table align="center" border="1">
            <tr valign="top" align="center">
                <td>&nbsp;&nbsp;<code>-1</code>&nbsp;&nbsp;</td>
                <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
                <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
                <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
                <td>&nbsp;&nbsp;<code>...</code>&nbsp;&nbsp;</td>
                <td>&nbsp;&nbsp;<code>49</code>&nbsp;&nbsp;</td>
                <td>&nbsp;&nbsp;<code>50</code>&nbsp;&nbsp;</td>
                <td>&nbsp;&nbsp;<code>-1</code>&nbsp;&nbsp;</td>
                </tr>
                </table>&nbsp;
            </td></tr>
        </td></tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 2. A one-dimensional array</b>
        <!-- formerly Figure 8-->
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<!-- NEW PAGE -->
  <p>Further suppose that we wish to write this data to the file as 
  a series of 3 x 2-element blocks in a two-dimensional dataset, 
  skipping one row and one column between blocks.
  Since the source selection contains 48 data elements and   
  each block in the destination selection contains 6 data elements, 
  we must define the destination selection with 8 blocks. 
  We will write 2 blocks in the first dimension and 4 in the second.
  The code below <!-- formerly Figure 9 --> shows how to achieve this 
  objective.</p>

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  /* Select the hyperslab for the dataset in the file, using 3 x 2 blocks, 
   * a (4,3) stride, a (2,4) count, and starting at the position (0,1).
   */
  start[0]  = 0; start[1]  = 1;
  stride[0] = 4; stride[1] = 3;
  count[0]  = 2; count[1]  = 4;    
  block[0]  = 3; block[1]  = 2;
  ret = H5Sselect_hyperslab(fid, H5S_SELECT_SET, start, stride, count, block);

  /*
   * Create dataspace for the first dataset.
   */
  mid1 = H5Screate_simple(MSPACE1_RANK, dim1, NULL);

  /*
  /*
   * Select hyperslab. 
   * We will use 48 elements of the vector buffer starting at the second element.
   * Selected elements are 1 2 3 . . . 48
   */
  start[0]  = 1;
  stride[0] = 1;
  count[0]  = 48;
  block[0]  = 1;
  ret = H5Sselect_hyperslab(mid1, H5S_SELECT_SET, start, stride, count, block);
 
  /*
   * Write selection from the vector buffer to the dataset in the file.
   *
  ret = H5Dwrite(dataset, H5T_NATIVE_INT, mid1, fid, H5P_DEFAULT, vector)</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 7. The destination selection
        <!-- formerly Figure 9--></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<!-- NEW PAGE -->
<a name="GetInfo">
<h4>2.2.6. Getting Information about a Dataset</h4>
</a>
  
  <p>Although reading is analogous to writing, it is often first necessary 
  to query a file to obtain information about the dataset to be read. 
  For instance, we often need to determine the datatype associated with a 
  dataset, or its dataspace (i.e., rank and dimensions). 
  As illustrated in the code example below <!--formerly Figure 10-->, 
  there are several <span class="termDefinition">get</span> routines for 
  obtaining this information.</p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  /*
  * Get datatype and dataspace identifiers,  
  * then query datatype class, order, and size, and 
  * then query dataspace rank and dimensions.
  */

   datatype = H5Dget_type (dataset);  /* datatype identifier */
   class = H5Tget_class (datatype);
   if (class == H5T_INTEGER) printf("Dataset has INTEGER type \n");
   order = H5Tget_order (datatype);
   if (order == H5T_ORDER_LE) printf("Little endian order \n");

   size = H5Tget_size (datatype);
   printf ("Size is %d \n", size);
   dataspace = H5Dget_space (dataset); /* dataspace identifier */

   /* Find rank and retrieve current and maximum dimension sizes */ 

   rank = H5Sget_simple_extent_dims (dataspace, dims, max_dims);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 8. Routines to get dataset parameters
        <!--formerly Figure 10--></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<a name="CreateCDType">
<h4>2.2.7. Creating and Defining Compound Datatypes</h4></a>
  
  <p>A <span class="termDefinition">compound datatype</span> is a 
  collection of one or more data elements. Each element might be an 
  atomic type, a small array, or another compound datatype. </p>
  
  <p>The provision for nested compound datatypes allows these structures 
  to become quite complex. An HDF5 compound datatype has some similarities 
  to a C struct or a Fortran common block. Though not originally designed 
  with databases in mind, HDF5 compound datatypes are sometimes used 
  in a way that is similar to a database record. Compound datatypes 
  can become either a powerful tool or a complex and difficult-to-debug 
  construct. Reasonable caution is advised.</p>

  <p>To create and use a compound datatype, 
  you need to create a datatype with class 
  <span class="termDefinition">compound</span> (<code>H5T_COMPOUND</code>) 
  and specify the total size of the data element in bytes. 
  A compound datatype consists of zero or more uniquely named members. 
  Members can be defined in any order but must occupy non-overlapping regions 
  within the datum. The table below <!-- formerly 
  Table 3 -->lists the properties of compound datatype members.</p>
  
<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 3. Compound datatype member properties</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="2" /></td></tr>
    <tr valign="top"> 
        <td width="20%"><b>Parameter</b></td>
        <td width="80%"><b>Definition</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Index</td>
        <td>An index number between zero and N-1, where N is the number of 
        members in the compound. The elements are indexed in the order of 
        their location in the array of bytes.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Name</td>
        <td>A string that must be unique within the members 
        of the same datatype.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Datatype</td>
        <td>An HDF5 datatype.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Offset</td>
        <td>A fixed byte offset which defines the location of the first 
        byte of that member in the compound datatype.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="2" /></td></tr>
</table>
<br />

  <p>Properties of the members of a compound datatype are 
  defined when the member is added to the compound type. These 
  properties cannot be modified later. </p>
  

<h4>Defining Compound Datatypes</h4> 
  
  <p>Compound datatypes must be built out of other datatypes. 
  To do this, you first create an empty compound datatype and specify 
  its total size. Members are then added to the compound datatype 
  in any order. </p>
  
  <p>Each member must have a descriptive name. This is the 
  key used to uniquely identify the member within the 
  compound datatype. A member name in an HDF5 datatype does 
  not necessarily have to be the same as the name of the 
  corresponding member in the C struct in memory although 
  this is often the case. You also do not need to define all the 
  members of the C struct in the HDF5 compound datatype 
  (or vice versa). </p>
  
  <p>Usually a C struct will be defined to hold a data 
  point in memory, and the offsets of the members in memory 
  will be the offsets of the struct members from the beginning 
  of an instance of the struct. The library defines the macro 
  that computes the offset of member <code>m</code> within a 
  struct variable <code>s</code>.: </p>
  
  <dir><code>HOFFSET(s,m)</code></dir>
  
  <p>The code below <!-- formerly Figure 11 -->shows an example in 
  which a compound datatype is created to describe complex numbers 
  whose type is defined by the <code>complex_t</code> struct.</p>
  
<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  Typedef struct {
     double re;   /*real part */
     double im;   /*imaginary part */
  } complex_t;

  complex_t tmp;  /*used only to compute offsets */
  hid_t complex_id = H5Tcreate (H5T_COMPOUND, sizeof tmp);
  H5Tinsert (complex_id, "real", HOFFSET(tmp,re),
            H5T_NATIVE_DOUBLE);
  H5Tinsert (complex_id, "imaginary", HOFFSET(tmp,im),
            H5T_NATIVE_DOUBLE);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 9. A compound datatype for complex numbers</b>
        <!-- formerly Figure 11-->
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<!-- editingComment
  <span class="editingComment">
  <p>For more information about Datatypes, see Chapter ???.
  </span>
-->


<a name="ExtendChunked">
<h4>2.2.8. Creating and Writing Extendable Datasets</h4>
</a>
  
  <p>An extendable dataset is one whose dimensions can grow. 
  One can define an HDF5 dataset to have certain initial 
  dimensions with the capacity to later increase the size 
  of any of the initial dimensions. For example, the figure below 
  <!-- formerly Figure 12 -->shows a  3 x 3 dataset (a) 
  which is later extended to be a 10 x 3 dataset by adding 7 
  rows (b), and further extended to be a 10 x 5 dataset by 
  adding two columns (c).</p>


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>

    <table width="80%" cellspacing="0" class="fullImgTable" align="center">
        <tr>
            <td align="center"><br />
    
    <table align="center">
      <tr>
        <td valign="middle" align="center" width="45%">
          
          <table align="center" border="1">
            <tr>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
            </tr>
          </table>
          a)&nbsp;Initially,&nbsp;3&nbsp;x&nbsp;3
          <br />&nbsp;<br />
          <table align="center" border="1">
            <tr>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
            </tr>
          </table>
          b)&nbsp;Extend&nbsp;to&nbsp;10&nbsp;x&nbsp;3

        </td>
        <td valign="middle" align="center" width="55%">
        <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>
        </td>
        <td valign="middle" align="center" width="55%">
        
          <table align="center" border="1">
            <tr>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>1</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
            </tr>
            <tr>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>2</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;<code>3</code>&nbsp;&nbsp;</td>
            </tr>
          </table>
          c)&nbsp;Extend&nbsp;to&nbsp;10&nbsp;x&nbsp;5
      </tr>
    </table>&nbsp;
    </td></tr>
    </table>
    </td></tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 3. Extending a dataset</b>
        <!-- formerly Figure 12-->
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

  <p>HDF5 requires the use of chunking when defining 
  extendable datasets. Chunking makes it possible to extend 
  datasets efficiently without having to reorganize contiguous 
  storage excessively. </p>
  
  <p>To summarize, an extendable dataset requires two conditions:</p>
  
  <ol> 
      <li>Define the dataspace of the dataset as unlimited in 
          all dimensions that might eventually be extended</li>
      <li>Enable chunking in the dataset creation properties</li>
  </ol>
  
  <p>For example, suppose we wish to create a dataset similar 
  to the one shown in the figure above<!-- formerly Figure 12-->. 
  We want to start with a 3 x 3 dataset, and then later we will 
  extend it. To do this, go through the steps below.</p>
  
  <p>First, declare the dataspace to have unlimited dimensions. See 
  the code shown below. Note the use of the predefined constant 
  <code>H5S_UNLIMITED</code> to specify that a dimension is 
  unlimited.</p>
  
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  Hsize_t dims[2] = {3, 3}; /* dataset dimensions
  at the creation time */ 
  hsize_t maxdims[2] = {H5S_UNLIMITED, H5S_UNLIMITED};
  /*
   * Create the data space with unlimited dimensions. 
   */
  dataspace = H5Screate_simple(RANK, dims, maxdims);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 10. Declaring a dataspace with unlimited dimensions</b>
        <!-- formerly Figure 13-->
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />


  <p>Next, set the dataset creation property list to 
  enable chunking. See the code below.</p> 


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  hid_t cparms; 
  hsize_t chunk_dims[2] ={2, 5};
  /* 
   * Modify dataset creation properties to enable chunking.
   */
  cparms = H5Pcreate (H5P_DATASET_CREATE);
  status = H5Pset_chunk(cparms, RANK, chunk_dims);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 11. Enable chunking
        <!-- formerly Figure 14--></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<!-- NEW PAGE -->

  <p>The next step is to create the dataset. See the code below.</p> 


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  /*
   * Create a new dataset within the file using cparms
   * creation properties.
   */
  dataset = H5Dcreate(file, DATASETNAME, H5T_NATIVE_INT, dataspace,
            H5P_DEFAULT, cparms, H5P_DEFAULT);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 12. Create a dataset 
        <!-- formerly Figure 15--></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

  <p>Finally, when the time comes to extend the size of 
  the dataset, invoke <code>H5Dextend</code>. Extending 
  the dataset along the first dimension by seven rows 
  leaves the dataset with new dimensions of &lt;10,3&gt;. See the 
  code below.</p> 


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  /*
   * Extend the dataset. Dataset becomes 10 x 3.
   */
  dims[0] = dims[0] + 7;
  size[0] = dims[0]; 
  size[1] = dims[1]; 
  status = H5Dextend (dataset, size);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 13. Extend the dataset by seven rows</b>
        <!-- formerly Figure 16-->
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<a name="Groups">
<h4>2.2.9. Creating and Working with Groups</h4>
</a>
  
  <p>Groups provide a mechanism for organizing meaningful 
  and extendable sets of datasets within an HDF5 file. The H5G 
  API provides several routines for working with groups. </p>

<h4>Creating a Group</h4>
  
  <p>With no datatype, dataspace, or storage layout to define, 
  creating a group is considerably simpler than creating a 
  dataset. For example, the following code creates a group 
  called <code>Data</code> in the root group of 
  <code>file</code>.</p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  /*
   *  Create a group in the file.
   */
  grp = H5Gcreate(file, "/Data", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 14. Create a group</b>
        <!-- formerly Figure 17-->
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<!-- NEW PAGE -->
  <p>A group may be created within another group by providing 
  the absolute name of the group to the <code>H5Gcreate</code> function 
  or by specifying its location. For example, to create the 
  group <code>Data_new</code> in the group <code>Data</code>, you might use 
  the sequence of calls shown below.</p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
   /*
    * Create group "Data_new" in the group "Data" by specifying
    * absolute name of the group.
    */
   grp_new = H5Gcreate(file, "/Data/Data_new", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);

  or 

   /*
    * Create group "Data_new" in the "Data" group.
    */
   grp_new = H5Gcreate(grp, "Data_new", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 15. Create a group within a group</b> 
        <!-- formerly Figure 18-->
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

  <p>This first parameter of <code>H5Gcreate</code> is a location 
  identifier. <code>file</code> in the first example specifies only 
  the file. <code>grp</code> in the second example specifies 
  a particular group in a particular file. Note that in 
  this instance, the group identifier <code>grp</code> is 
  used as the first parameter in the <code>H5Gcreate</code> 
  call so that the relative name of <code>Data_new</code> 
  can be used.</p>
  
  <p>The third parameter of <code>H5Gcreate</code> optionally specifies 
  how much file space to reserve to store the names of objects that 
  will be created in this group. If a non-positive value is supplied, 
  the library provides a default size.</p> 
  
  <p>Use <code>H5Gclose</code> to close the group and release 
  the group identifier. </p>
  
<!-- NEW PAGE -->
  <h4>Creating a Dataset within a Group</h4> 
  
  <p>As with groups, a dataset can be created in a particular group 
  by specifying either its absolute name in the file or its relative 
  name with respect to that group. The next code excerpt 
  uses the absolute name.</p> 

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  /*
   * Create the dataset "Compressed_Data" in the group Data using the 
   * absolute name. The dataset creation property list is modified 
   * to use GZIP compression with the compression effort set to 6.
   * Note that compression can be used only when the dataset is 
   * chunked.
   */
  dims[0] = 1000;
  dims[1] = 20;
  cdims[0] = 20;
  cdims[1] = 20;
  dataspace = H5Screate_simple(RANK, dims, NULL);
  plist     = H5Pcreate(H5P_DATASET_CREATE);
            H5Pset_chunk(plist, 2, cdims);
            H5Pset_deflate(plist, 6);
  dataset = H5Dcreate(file, "/Data/Compressed_Data", 
            H5T_NATIVE_INT, dataspace, H5P_DEFAULT, plist, H5P_DEFAULT);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 16. Create a dataset within 
        a group using an absolute name </b> 
        <!-- formerly Figure 19-->
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />


  <p>Alternatively, you can first obtain an identifier for 
  the group in which the dataset is to be created, and then 
  create the dataset with a relative name.</p> 

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  /* 
   * Open the group.
   */
  grp = H5Gopen(file, "Data", H5P_DEFAULT);

  /*
   * Create the dataset "Compressed_Data" in the "Data" group
   * by providing a group identifier and a relative dataset 
   * name as parameters to the H5Dcreate function.
   */
  dataset = H5Dcreate(grp, "Compressed_Data", H5T_NATIVE_INT,
                dataspace, H5P_DEFAULT, plist, H5P_DEFAULT);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 17. Create a dataset within a group using a relative name</b>
        <!-- formerly Figure 20-->
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<!-- NEW PAGE -->

  <h4>Accessing an Object in a Group</h4>
  
  <p>Any object in a group 
  can be accessed by its absolute or relative name. The 
  first code snippet below illustrates the use of the absolute 
  name to access the dataset <code>Compressed_Data</code> in 
  the group <code>Data</code> created in the examples above. 
  The second code snippet illustrates the use of the 
  relative name.</p>


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  /*
   * Open the dataset "Compressed_Data" in the "Data" group. 
   */
  dataset = H5Dopen(file, "/Data/Compressed_Data", H5P_DEFAULT);
    </pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 18. Accessing a group using its absolute name</b>
        <!-- formerly Figure 21--> 
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />
<br />


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  /*
   * Open the group "data" in the file.
   */
  grp  = H5Gopen(file, "Data", H5P_DEFAULT);
 
  /*
   * Access the "Compressed_Data" dataset in the group.
   */
  dataset = H5Dopen(grp, "Compressed_Data", H5P_DEFAULT);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 19. Accessing a group using its relative name</b>
        <!-- formerly Figure 22-->
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<!-- NEW PAGE -->
<a name="Attrs">
<h4>2.2.10. Working with Attributes</h4>
</a>
  
  <p>An attribute is a small dataset that is attached to 
  a normal dataset or group. Attributes share many of the 
  characteristics of datasets, so the programming model for 
  working with attributes is similar in many ways to the 
  model for working with datasets. The primary differences 
  are that an attribute must be attached to a dataset or a 
  group and sub-setting operations cannot be performed on 
  attributes. </p>
  
  <p>To create an attribute belonging to a particular 
  dataset or group, first create a dataspace for the attribute 
  with the call to <code>H5Screate</code>, and then create the 
  attribute using <code>H5Acreate</code>. For example, the 
  code shown below creates an attribute called 
  <code>Integer_attribute</code> that is a member of a dataset 
  whose identifier is <code>dataset</code>. The attribute identifier is 
  <code>attr2</code>. <code>H5Awrite</code> then sets the value of 
  the attribute of that of the integer variable point. 
  <code>H5Aclose</code> then releases the attribute 
  identifier.</p>



<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  Int point = 1;                         /* Value of the scalar attribute */ 

  /*
   * Create scalar attribute.
   */
  aid2  = H5Screate(H5S_SCALAR);
  attr2 = H5Acreate(dataset, "Integer attribute", H5T_NATIVE_INT, aid2,
                H5P_DEFAULT, H5P_DEFAULT);

  /*
   * Write scalar attribute.
   */
   ret = H5Awrite(attr2, H5T_NATIVE_INT, &amp;point); 

  /*
   * Close attribute dataspace.
   */
  ret = H5Sclose(aid2); 

  /*
   * Close attribute.
   */
  ret = H5Aclose(attr2); </pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 20. Create an attribute</b>
        <!-- formerly Figure 23--> 
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

  <p>To read a scalar attribute whose name and datatype 
  are known, first open the attribute using 
  <code>H5Aopen_by_name</code>, and then use <code>H5Aread</code> 
  to get its value. For example, the code shown below reads a scalar 
  attribute called <code>Integer_attribute</code> whose 
  datatype is a native integer and whose parent dataset 
  has the identifier <code>dataset</code>.</p> 

<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  /*
   * Attach to the scalar attribute using attribute name, then read and 
   * display its value.
   */
  attr = H5Aopen_by_name(file_id, dataset_name, "Integer attribute",
                    H5P_DEFAULT, H5P_DEFAULT);
  ret  = H5Aread(attr, H5T_NATIVE_INT, &amp;point_out);
  printf("The value of the attribute \"Integer attribute\" is %d \n", point_out); 
  ret =  H5Aclose(attr);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 21. Read a known attribute</b>
        <!-- formerly Figure 24--> 
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />


  <p>To read an attribute whose characteristics are 
  not known, go through these steps. First, query the file to 
  obtain information about the attribute such as its name, 
  datatype, rank, and dimensions, and then read the attribute. The 
  following code opens an attribute by its index value using 
  <code>H5Aopen_by_idx</code>, and then it reads in information about 
  the datatype with <code>H5Aread</code>.</p> 


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  /*
   * Attach to the string attribute using its index, then read and display the value.
   */
  attr =  H5Aopen_by_idx(file_id, dataset_name, index_type, iter_order, 2,
                    H5P_DEFAULT, H5P_DEFAULT);
  atype = H5Tcopy(H5T_C_S1);
          H5Tset_size(atype, 4);
  ret   = H5Aread(attr, atype, string_out);
  printf("The value of the attribute with the index 2 is %s \n", string_out);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 22. Read an unknown attribute
        <!-- formerly Figure 25--></b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

  <p>In practice, if the characteristics of attributes 
  are not known, the code involved in accessing and processing 
  the attribute can be quite complex. For this reason, HDF5 
  includes a function called <code>H5Aiterate</code>. This function 
  applies a user-supplied function to each of a set of attributes. 
  The user-supplied function can contain the code that 
  interprets, accesses, and processes each attribute.</p> 

<!-- NEW PAGE -->
<a name="IOPipeline">
<h3>2.3. The Data Transfer Pipeline</h3>
</a>
  
<!-- editingComment
  <span class="editingComment">[ [ [
  This section needs to be reviewed in detail by QAK and others.
  ] ] ]<
  br><br />
  [ [ [
  There probably should be a whole chapter on data transfer, 
  selection, transformation, etc.}</em>
  ] ] ]</span>
-->

  <p>The HDF5 Library implements data transfers between 
  different storage locations. At the lowest levels, the 
  HDF5 Library reads and writes blocks of bytes to and from 
  storage using calls to the virtual file layer (VFL) drivers. 
  In addition to this, the HDF5 Library manages caches of metadata 
  and a data I/O pipeline. The data I/O pipeline applies compression 
  to data blocks, transforms data elements, and implements selections.  </p>
  
  <p>A substantial portion of the HDF5 Library&rsquo;s work is in 
  transferring data from one environment or media to another. This 
  most often involves a transfer between system memory and a storage 
  medium. Data transfers are affected by compression, encryption, 
  machine-dependent differences in numerical representation, and other 
  features. So, the bit-by-bit arrangement of a given dataset is 
  often substantially different in the two environments.</p>
  
  <p>Consider the representation on disk of a compressed and 
  encrypted little-endian array as compared to the same array 
  after it has been read from disk, decrypted, decompressed, and loaded 
  into memory on a big-endian system. HDF5 performs all of the 
  operations necessary to make that transition during the I/O 
  process with many of the operations being handled by the VFL 
  and the data transfer pipeline.</p>
  
  <p>The figure below <!-- formerly Figure 26 -->provides a simplified 
  view of a sample data transfer with four stages. Note that the 
  modules are used only when needed. For example, if the data is 
  not compressed, the compression stage is omitted.</p>
<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Pmodel_fig26.JPG" height="75%" width="95%">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 4. A data transfer from storage to memory</b>
        <!-- formerly Figure 26-->
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />


  <p>For a given I/O request, different combinations of 
  actions may be performed by the pipeline. The library 
  automatically sets up the pipeline and passes data through 
  the processing steps. For example, for a <em>read</em> request 
  (from disk to memory), the library must determine which 
  logical blocks contain the requested data elements and fetch 
  each block into the library&rsquo;s cache. If the data needs to be 
  decompressed, then the compression algorithm is applied to 
  the block after it is read from disk. If the data is a selection, 
  the selected elements are extracted from the data block after it 
  is decompressed. If the data needs to be transformed (for example, 
  byte swapped), then the data elements are transformed after 
  decompression and selection.</p>
  
  <p>While an application must sometimes set up some elements 
  of the pipeline, use of the pipeline is normally transparent to 
  the user program. The library determines what must be done 
  based on the metadata for the file, the object, and the 
  specific request. An example of when an application might be required 
  to set up some elements in the pipeline is if the application used 
  a custom error-checking algorithm. </p>
<!-- editingComment
  <span class="editingComment">
  For more details of the pipeline, see [citeit].</p>
  </span>
-->
  
  <p>In some cases, it is necessary to pass parameters to 
  and from modules in the pipeline or among other parts 
  of the library that are not directly called through the 
  programming API. This is accomplished through the use of 
  dataset transfer and data access property lists. </p>
  
  <p>The VFL provides an interface whereby user applications 
  can add custom modules to the data transfer pipeline. For example, 
  a custom compression algorithm can be used with the HDF5 Library 
  by linking an appropriate module into the pipeline through the 
  VFL. This requires creating an appropriate wrapper for the 
  compression module 
<!-- editingComment
  <span class="editingComment">[ [ [
  [cite filter doc and ref manual] 
  ] ] ]</span>
-->
  and registering it with the library with <code>H5Zregister</code>.
  The algorithm can then be applied to a dataset with an 
  <code>H5Pset_filter</code> call which will add the algorithm to the 
  selected dataset&rsquo;s transfer property list.</p>
  

<SCRIPT language="JavaScript">
<!--
document.writeln ("
<div align="right">
<a href="#TOP"><font size="-1">(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<br /><br /><br />
<br /><br /><br />


</body>
</html>
