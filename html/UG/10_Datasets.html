<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>

<title>HDF5 User's Guide: Datasets</title>

<!--(Meta)==========================================================-->

<!--(Links)=========================================================-->

<!--( Begin styles definition )=====================================-->
<link href="ed_styles/NewUGelect.css" rel="stylesheet" type="text/css">
<!--( End styles definition )=======================================-->

</head> 

<body>

<!-- #BeginLibraryItem "/ed_libs/styles_UG.lbi" -->
<!--
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  * Copyright by The HDF Group.                                               *
  * Copyright by the Board of Trustees of the University of Illinois.         *
  * All rights reserved.                                                      *
  *                                                                           *
  * This file is part of HDF5.  The full HDF5 copyright notice, including     *
  * terms governing use, modification, and redistribution, is contained in    *
  * the files COPYING and Copyright.html.  COPYING can be found at the root   *
  * of the source code distribution tree; Copyright.html can be found at the  *
  * root level of an installed copy of the electronic HDF5 document set and   *
  * is linked from the top-level documents page.  It can also be found at     *
  * http://hdfgroup.org/HDF5/doc/Copyright.html.  If you do not have          *
  * access to either file, you may request a copy from help@hdfgroup.org.     *
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 -->
<!-- #EndLibraryItem --><!-- HEADER LEFT "HDF5 User's Guide" -->
<!-- HEADER RIGHT "HDF5 Datasets" -->

<!--( TOC )=========================================================-->
<!--<SCRIPT language="JavaScript">-->
<!--
document.writeln ('\
<table x-use-null-cells\
                align=right\
		width=240\
		cellspacing=0\
		class="tocTable">\
-->
<!-- Table Version 3 --><!-- \ -->
<!--
  <tr valign=top> \
    <td class="tocTableHeaderCell" colspan="2"> \
        <span class=TableHead>Chapter Contents</span></td>\
  </tr>\
  <tr valign=top> \
    <td class="tocTableContentCell2"> \
      <a href="#Intro">1.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#Intro">Introduction</a></td> \
  </tr>\
  <tr valign=top> \
    <td class="tocTableContentCell2"> \
      <a href="#FileFunctSums">2.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#FileFunctSums">Dataset (H5D) Function Summaries</a></td>\
  </tr>\
  <tr valign=top> \
    <td class="tocTableContentCell2"> \
      <a href="#PModel">3.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#PModel">Programming Model</a></td> \
  </tr>\
  <tr valign=top> \
    <td class="tocTableContentCell2"> \
      <a href="#DTransfer">4.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#DTransfer">Data Transfer</a></td>\
  </tr>\
  <tr valign=top> \
    <td class="tocTableContentCell2"> \
      <a href="#Allocation">5.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#Allocation">Allocation of Space</a></td>\
  </tr>\
  <tr valign=top> \
    <td class="tocTableContentCell"> \
      <a href="#UseFilters">6.</a></td>\
    <td class="tocTableContentCell4">\
	  <a href="#UseFilters">Specialized Filters</a>\
          <br>&nbsp;&nbsp;&nbsp;&nbsp;\
	  <a href="#N-Bit">N-bit</a>\
          <br>&nbsp;&nbsp;&nbsp;&nbsp;\
	  <a href="#ScaleOffset">Scale-offset</a></td>\
  </tr>\
  </td></tr>\
</table>\
')
-->
<!--</SCRIPT>-->
<!--(End TOC)=======================================================-->

<!-- editingComment
  <span class="editingComment">[ [ [
  ] ] ]</span>
-->

<!-- editingComment
-->

<div align="center">
<a name="TOP">
<h2>Chapter 5<br><font size="7">HDF5 Datasets</font></h2>
</a>
</div>

<!-- editingComment
  <span class="editingComment">[ [ [
  Original title.  Which is proper?
  <h2>10. Datasets I/O</h2>
  ] ] ]</span>
-->
<br />
<a name="Intro">
<h3>1. Introduction</h3>
</a>

  <p>An HDF5 dataset is an object composed of a collection of data elements, 
  or raw data, and metadata that stores a description of the data elements, 
  data layout, and all other information necessary to write, read, and interpret 
  the stored data. From the viewpoint of the application the raw data is stored 
  as a one-dimensional or multi-dimensional array of elements (the <em>raw data</em>), 
  those elements can be any of several numerical or character types, small arrays, 
  or even compound types similar to C structs. The dataset object may have attribute 
  objects. See the figure below.</p>
  
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig1.JPG">
    </td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
        <span class=figurenumber>Figure 1. Application view of a dataset</span></td>
  </tr>
</table>

<!-- editingComment
  <span class="editingComment">
  <p>Datatypes are described in  [ [ [ "Datatypes" ] ] ]. and in the [ [ [ "HDF5 
  Datatypes" chapter in this guide ] ] ], Dataspace objects are described in 
  [ [ [ Dataspace ] ] ], and Attributes are described in [ [ [ Attributes ] ] ].
  </span>
-->

  <p>A dataset object is stored in a file in two parts: a header and a data array. 
  The header contains information that is needed to interpret the array portion of 
  the dataset, as well as metadata (or pointers to metadata) that describes or 
  annotates the dataset. Header information includes the name of the object, its 
  dimensionality, its number-type, information about how the data itself is stored 
  on disk (the <em>storage layout</em>), and other information used by the library 
  to speed up access to the dataset or maintain the file's integrity. 

  <p>The HDF5 dataset interface, comprising the H5D functions, provides a mechanism 
  for managing HDF5 datasets including the transfer of data between memory and 
  disk and the description of dataset properties. 

  <p>A dataset is used by other HDF5 APIs, either by name or by a handle (e.g., 
  returned by H5Dopen).

<!-- NEW PAGE -->
<h4><em>Link/Unlink</em></h4>

  <p>A dataset can be added to a group with one of the H5Lcreate calls, and deleted from a 
  group with H5Ldelete. The link and unlink operations use the name of an object, 
  which may be a dataset. The dataset does not have to open to be linked or unlinked.

<h4><em>Object reference</em></h4>

  <p>A dataset may be the target of an object reference.  The object reference is 
  created by H5Rcreate with the name of an object which may be a dataset and the 
  reference type H5R_OBJECT. The dataset does not have to be open to create a 
  reference to it.

  <p>An object reference may also refer to a region (selection) of a dataset. 
  The reference is created with H5Rcreate and a reference type of 
  H5R_DATASET_REGION.

  <p>An object reference can be accessed by a call to H5Rdereference. When the 
  reference is to a dataset or dataset region, the H5Rdeference call returns a 
  handle to the dataset just as if H5open has been called.

<h4><em>Adding attributes</em></h4>

  <p>A dataset may have user-defined attributes which are created with H5Acreate 
  and accessed through the H5A API. To create an attribute for a dataset, the 
  dataset must be open, and the handle is passed to H5Acreate. The attributes of 
  a dataset are discovered and opened using H5Aopen_name, H5Aopen_idx, or H5Aiterate; 
  these functions use the handle of the dataset. An attribute can be deleted with H5Adelete 
  which also uses the handle of the dataset.

<!-- editingComment
  <span class="editingComment">
  <p>The remaining sections of this chapter discuss... [To be written last.]</p>
  </span>
-->

<br>

<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="FileFunctSums">
<div align=right>
<a href="#TOP"><font size=-1>(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>
<br />
<!-- NEW PAGE -->
<a name="FileFunctSums">
<h3 class=pagebefore>2. Dataset Function Summaries</h3>
</a>
<p>Functions that can be used with datasets (H5D functions) and property 
list functions that can used with datasets (H5P functions) are listed below.
<br>
<br />
<br />
<table x-use-null-cells
		class="functTable"
		width=600
		cellspacing=0
	        align="center">
  <tr valign="bottom">
    <td colspan="2" align="left" valign="bottom"><b>Function Listing 1. Dataset functions (H5D)</b></td>
  </tr>
  <tr valign=top> 
    <td class="functTableLeftHdr">
        <span class=TableHead>C Function<br>F90 Function</span>
    </td>
    <td class="functTableRightHdr">
        <span class=TableHead>Purpose</span>
    </td>
  </tr>
  <tr valign=top> 
    <td colspan=1
	rowspan=1
	class="functTableCell">
	<code>H5Dcreate<br>h5dcreate_f</code> 
    </td>
    <td colspan=1
	rowspan=1
	class="functTableCell">
	Creates a dataset at the specified location. The C function is a 
        macro: see <a href="../RM/APICompatMacros.html">&ldquo;API 
        Compatibility Macros in HDF5.&rdquo;</a>
	
    </td>
  </tr>
  <tr valign=top> 
    <td colspan=1
	rowspan=1
	class="functTableCell">
	<code>H5Dcreate_anon<br>h5dcreate_anon_f</code> 
    </td>
    <td colspan=1
	rowspan=1
	class="functTableCell">
	Creates a dataset in a file without linking it into the file structure. 
    </td>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dopen<br>h5dopen_f</code> 
    </td>
    <td class="functTableCell">
	Opens an existing dataset. The C function is a 
        macro: see <a href="../RM/APICompatMacros.html">&ldquo;API 
        Compatibility Macros in HDF5.&rdquo;</a>
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dclose<br>h5dclose_f</code> 
    </td>
    <td class="functTableCell">
	Closes the specified dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dget_space<br>h5dget_space_f</code> 
    </td>
    <td class="functTableCell">
	Returns an identifier for a copy of the dataspace for a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dget_space_status<br>h5dget_space_status_f</code> 
    </td>
    <td class="functTableCell">
	Determines whether space has been allocated for a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dget_type<br>h5dget_type_f</code> 
    </td>
    <td class="functTableCell">
	Returns an identifier for a copy of the datatype for a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dget_create_plist<br>h5dget_create_plist_f</code> 
    </td>
    <td class="functTableCell">
	Returns an identifier for a copy of the dataset creation property list for a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dget_access_plist<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Returns the dataset access property list associated with a dataset. 
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dget_offset<br>h5dget_offset_f</code> 
    </td>
    <td class="functTableCell">
	Returns the dataset address in a file.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dget_storage_size<br>h5dget_storage_size_f</code> 
    </td>
    <td class="functTableCell">
	Returns the amount of storage required for a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dvlen_get_buf_size<br>h5dvlen_get_max_len_f</code> 
    </td>
    <td class="functTableCell">
	Determines the number of bytes required to store variable-length (VL) 
        data.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dvlen_reclaim<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Reclaims VL datatype memory buffers.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dread<br>h5dread_f</code> 
    </td>
    <td class="functTableCell">
	Reads raw data from a dataset into a buffer.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dwrite<br>h5dwrite_f</code> 
    </td>
    <td class="functTableCell">
	Writes raw data from a buffer to a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Diterate<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Iterates over all selected elements in a dataspace.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dfill<br>h5dfill_f</code> 
    </td>
    <td class="functTableCell">
	Fills dataspace elements with a fill value in a memory buffer.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableBottom">
	<code>H5Dset_extent<br>h5dset_extent_f</code> 
    </td>
    <td class="functTableBottom">
	Changes the sizes of a dataset’s dimensions. 
    </td>
  </tr>
</table>

<br />
<!-- NEW PAGE -->
<br />
<table x-use-null-cells 
		class="functTable"
		width=100%
		cellspacing=0
	        align="center">
  <tr valign="bottom">
    <td colspan="2" align="left" valign="bottom"><b>Function Listing 2. 
    Dataset creation property list functions (H5P)</b></td>
  </tr>
  <tr valign=top> 
    <td class="functTableLeftHdr">
        <span class=TableHead>C Function<br>F90 Function</span>
    </td>
    <td class="functTableRightHdr">
        <span class=TableHead>Purpose</span>
    </td>
  </tr>
  <tr valign=top> 
    <td colspan=1
	rowspan=1
	class="functTableCell">
	<code>H5Pset_layout<br>h5pset_layout_f</code> 
    </td>
    <td colspan=1
	rowspan=1
	class="functTableCell">
	Sets the type of storage used to store the raw data for a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_layout<br>h5pget_layout_f</code> 
    </td>
    <td class="functTableCell">
	Returns the layout of the raw data for a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_chunk<br>h5pset_chunk_f</code> 
    </td>
    <td class="functTableCell">
	Sets the size of the chunks used to store a chunked layout dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_chunk<br>h5pget_chunk_f</code> 
    </td>
    <td class="functTableCell">
	Retrieves the size of chunks for the raw data of a chunked layout 
        dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_chunk_cache<br>h5pset_chunk_cache_f</code> 
    </td>
    <td class="functTableCell">
	Sets the raw data chunk cache parameters.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_chunk_cache<br>h5pget_chunk_cache_f</code> 
    </td>
    <td class="functTableCell">
	Retrieves the raw data chunk cache parameters. 
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_deflate<br>h5pset_deflate_f</code> 
    </td>
    <td class="functTableCell">
	Sets compression method and compression level.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_fill_value<br>h5pset_fill_value_f</code> 
    </td>
    <td class="functTableCell">
	Sets the fill value for a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_fill_value<br>h5pget_fill_value_f</code> 
    </td>
    <td class="functTableCell">
	Retrieves a dataset fill value.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pfill_value_defined<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Determines whether the fill value is defined.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_fill_time<br>h5pset_fill_time_f</code> 
    </td>
    <td class="functTableCell">
	Sets the time when fill values are written to a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_fill_time<br>h5pget_fill_time_f</code> 
    </td>
    <td class="functTableCell">
	Retrieves the time when fill value are written to a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_alloc_time<br>h5pset_alloc_time_f</code> 
    </td>
    <td class="functTableCell">
	Sets the timing for storage space allocation.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_alloc_time<br>h5pget_alloc_time_f</code> 
    </td>
    <td class="functTableCell">
	Retrieves the timing for storage space allocation.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_filter<br>h5pset_filter_f</code> 
    </td>
    <td class="functTableCell">
	Adds a filter to the filter pipeline.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pall_filters_avail<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Verifies that all required filters are available.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_nfilters<br>h5pget_nfilters_f</code> 
    </td>
    <td class="functTableCell">
	Returns the number of filters in the pipeline.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_filter<br>h5pget_filter_f</code> 
    </td>
    <td class="functTableCell">
	Returns information about a filter in a pipeline. The C function is a 
        macro: see <a href="../RM/APICompatMacros.html">&ldquo;API 
        Compatibility Macros in HDF5.&rdquo;</a>
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_filter_by_id<br>h5pget_filter_by_id_f</code> 
    </td>
    <td class="functTableCell">
	Returns information about the specified filter. The C function is a 
        macro: see <a href="../RM/APICompatMacros.html">&ldquo;API 
        Compatibility Macros in HDF5.&rdquo;</a>
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pmodify_filter<br>h5pmodify_filter_f</code> 
    </td>
    <td class="functTableCell">
	Modifies a filter in the filter pipeline.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Premove_filter<br>h5premove_filter_f</code> 
    </td>
    <td class="functTableCell">
	Deletes one or more filters in the filter pipeline.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_fletcher32<br>h5pset_fletcher32_f</code> 
    </td>
    <td class="functTableCell">
	Sets up use of the Fletcher32 checksum filter.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_nbit<br>h5pset_nbit_f</code> 
    </td>
    <td class="functTableCell">
	Sets up use of the n-bit filter.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_scaleoffset<br>h5pset_scaleoffset_f</code> 
    </td>
    <td class="functTableCell">
	Sets up use of the scale-offset filter.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_shuffle<br>h5pset_shuffle_f</code> 
    </td>
    <td class="functTableCell">
	Sets up use of the shuffle filter.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_szip<br>h5pset_szip_f</code> 
    </td>
    <td class="functTableCell">
	Sets up use of the Szip compression filter.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_external<br>h5pset_external_f</code> 
    </td>
    <td class="functTableCell">
	Adds an external file to the list of external files.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_external_count<br>h5pget_external_count_f</code> 
    </td>
    <td class="functTableCell">
	Returns the number of external files for a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_external<br>h5pget_external_f</code> 
    </td>
    <td class="functTableCell">
	Returns information about an external file.
    </td>
  </tr>
  <tr valign=top> 
    <td colspan=1
	rowspan=1
	class="functTableCell">
	<code>H5Pset_char_encoding<br>h5pset_char_encoding_f</code> 
    </td>
    <td colspan=1
	rowspan=1
	class="functTableCell">
	Sets the character encoding used to encode a string. 
        Use to set ASCII or UTF-8 character encoding for object names.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableBottom">
	<code>H5Pget_char_encoding<br>h5pget_char_encoding_f</code> 
    </td>
    <td class="functTableBottom">
	Retrieves the character encoding used to create a string. 
    </td>
  </tr>
</table>
<br />
<br>

<table x-use-null-cells 
		class="functTable"
		width=100%
		cellspacing=0
	        align="center">
  <tr valign="bottom">
    <td colspan="2" align="left" valign="bottom"><b>Function Listing 3. 
    Dataset access property list functions (H5P)</b></td>
  </tr>
  <tr valign=top> 
    <td class="functTableLeftHdr">
        <span class=TableHead>C Function<br>F90 Function</span>
    </td>
    <td class="functTableRightHdr">
        <span class=TableHead>Purpose</span>
    </td>
  </tr>
  <tr valign=top> 
    <td colspan=1
	rowspan=1
	class="functTableCell">
	<code>H5Pset_buffer<br>h5pset_buffer_f</code> 
    </td>
    <td colspan=1
	rowspan=1
	class="functTableCell">
	Sets type conversion and background buffers.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_buffer<br>h5pget_buffer_f</code> 
    </td>
    <td class="functTableCell">
	Reads buffer settings.
    </td>
  </tr>
<!-- 8.10.10, MEE: I removed two dataset access property list functions: 
                   H5Pset_preserve and H5Pget_preserve. -->
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_edc_check<br>h5pset_edc_check_f</code> 
    </td>
    <td class="functTableCell">
	Sets whether to enable error-detection when reading a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_edc_check<br>h5pget_edc_check_f</code> 
    </td>
    <td class="functTableCell">
	Determines whether error-detection is enabled for dataset reads.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_filter_callback<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Sets user-defined filter callback function.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_data_transform<br>h5pset_data_transform_f</code> 
    </td>
    <td class="functTableCell">
	Sets a data transform expression.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_data_transform<br>h5pget_data_transform_f</code> 
    </td>
    <td class="functTableCell">
	Retrieves a data transform expression.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_type_conv_cb<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Sets user-defined datatype conversion callback function.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_type_conv_cb<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Gets user-defined datatype conversion callback function.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_hyper_vector_size<br>h5pset_hyper_vector_size_f</code> 
    </td>
    <td class="functTableCell">
	Sets number of I/O vectors to be read/written in hyperslab I/O.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_hyper_vector_size<br>h5pget_hyper_vector_size_f</code> 
    </td>
    <td class="functTableCell">
	Retrieves number of I/O vectors to be read/written in hyperslab I/O.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_btree_ratios<br>h5pset_btree_ratios_f</code> 
    </td>
    <td class="functTableCell">
	Sets B-tree split ratios for a dataset transfer property list.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_btree_ratios<br>h5pget_btree_ratios_f</code> 
    </td>
    <td class="functTableCell">
	Gets B-tree split ratios for a dataset transfer property list.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_vlen_mem_manager<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Sets the memory manager for variable-length datatype allocation in 
	<code>H5Dread</code> and <code>H5Dvlen_reclaim</code>.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_vlen_mem_manager<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Gets the memory manager for variable-length datatype allocation in 
	<code>H5Dread</code> and <code>H5Dvlen_reclaim</code>.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_dxpl_mpio<br>h5pset_dxpl_mpio_f</code> 
    </td>
    <td class="functTableCell">
	Sets data transfer mode.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_dxpl_mpio<br>h5pget_dxpl_mpio_f</code> 
    </td>
    <td class="functTableCell">
	Returns the data transfer mode.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_dxpl_mpio_chunk_opt<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Sets a flag specifying linked-chunk I/O or multi-chunk I/O.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_dxpl_mpio_chunk_opt_num<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Sets a numeric threshold for linked-chunk I/O.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_dxpl_mpio_chunk_opt_ratio<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Sets a ratio threshold for collective I/O.
    </td>
  </tr>
    <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_dxpl_mpio_collective_opt<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Sets a flag governing the use of independent versus collective I/O. 
    </td>
  </tr>

  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_dxpl_multi<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Sets the data transfer property list for the multi-file driver.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_dxpl_multi<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Returns multi-file data transfer property list information.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_multi_type<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Sets the type of data property for the MULTI driver.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_multi_type<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Retrieves the type of data property for the MULTI driver.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_small_data_block_size<br>h5pset_small_data_block_size_f</code> 
    </td>
    <td class="functTableCell">
	Sets the size of a contiguous block reserved for small data.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableBottom">
	<code>H5Pget_small_data_block_size<br>h5pget_small_data_block_size_f</code> 
    </td>
    <td class="functTableBottom">
	Retrieves the current small data block size setting.
    </td>
  </tr>
</table>
<br />
<br>

<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="PModel">
<div align=right>
<a href="#TOP"><font size=-1>(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<!-- NEW PAGE -->
<a name="PModel">
<h3 class=pagebefore>3. Programming Model</h3>
</a>

  <p>This section explains the programming model for datasets.
<br />
<br />
<h4>3.1 General Model</h4>

  <p>The programming model for using a dataset has three main phases:
  
  <ul>
    <li>Obtain access to the dataset </li>
    <li>Operate on the dataset using the dataset handle returned above </li>
    <li>Release the dataset</li>
  </ul>
  <p>These three phases or steps are described in more detail below the 
  figure.</p>
  
  <p>A dataset may be opened several times and 
  operations performed with several different handles to the same dataset. All the 
  operations affect the dataset, although the calling program must synchronize if 
  necessary to serialize accesses.

  <p>Note that the dataset remains open until the last handle is closed. 
  The figure below shows the basic sequence of operations.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig2.JPG">
    </td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
        <span class=figurenumber>Figure 2. Dataset programming sequence</span></td>
  </tr>
</table>
<br />
  <p>Creation and data access operations may have optional parameters which are set 
  with property lists.  The general programming model is:

  <ul>
      <li>Create property list of appropriate class (dataset create, 
          dataset transfer)
      <li>Set properties as needed; each type of property has its own 
          format and datatype
      <li>Pass the property list as a parameter of the API call
  </ul>
<br />
  <p>The steps below describe the programming phases or steps for using a 
  dataset.</p>

<h4><em>Step 1. Obtain Access</em></h4>

  <p>A new dataset is created by a call to H5Dcreate. If successful, the call 
  returns a handle for the newly created dataset.

  <p>Access to an existing dataset is obtained by a call to H5Dopen. This call 
  returns a handle for the existing dataset.

  <p>An object reference 
<!-- editingComment
  <span class="editingComment">[ [ [
  (Chapter ???) 
  ] ] ]</span>
-->
  may be dereferenced to obtain a handle to 
  the dataset it points to.
  
  <p>In each of these cases, the successful call returns a handle to the dataset. 
  The handle is used in subsequent operations until the dataset is closed.

<h4><em>Step 2. Operate on the Dataset</em></h4>

  <p>The dataset handle can be used to write and read data to the dataset, to query 
  and set properties, and to perform other operations such as adding attributes, 
  linking in groups, and creating references.

  <p>The dataset handle can be used for any number of 
  operations until the dataset is closed.

<h4><em>Step 3. Close the Dataset</em></h4>

  <p>When all operations are completed, the dataset handle should be closed. 
  This releases the dataset. 
<!-- editingComment
  <span class="editingComment">[ [ [
  { and writes all metadata to the file? }
  ] ] ]</span>
-->

  <p>After the handle is closed, it cannot be used for further operations.
<br />
<br />
<h4>3.2 Create Dataset</h4>

  <p>A dataset is created and initialized with a call to H5Dcreate. The dataset 
  create operation sets permanent properties of the dataset:</p>

  <ul>
      <li>Name
      <li>Dataspace
      <li>Datatype
      <li>Storage properties
  </ul>

  <p>These properties cannot be changed for the life of the dataset, although the 
  dataspace may be expanded up to its maximum dimensions.

<h4><em>Name</em></h4>

  <p>A dataset name is a sequence of alphanumeric ASCII characters. The full name 
  would include a tracing of the group hierarchy from the root group of the file, 
  e.g., /rootGroup/groupA/subgroup23/dataset1. The local name or relative name 
  within the lowest-level group containing the dataset would include none of the 
  group hierarchy. e.g., Dataset1. 
<!-- editingComment
  <span class="editingComment">[ [ [
  [[See ??]]
  ] ] ]</span>
-->

<!-- NEW PAGE -->
<h4><em>Dataspace</em></h4>

  <p>The dataspace of a dataset defines the number of dimensions and the size of 
  each dimension. 
<!-- editingComment
  <span class="editingComment">[ [ [
  [[Dataspace]]. 
  ] ] ]</span>
-->
  The dataspace defines the number of dimensions, 
  and the maximum dimension sizes and current size of each dimension. 
  The maximum dimension size can be a fixed value or the constant 
  <code>H5D_UNLIMITED</code>, in which case the actual dimension size 
  can be changed with calls to <code>H5Dset_extent</code>, up to the 
  maximum set with the <code>maxdims</code> parameter in the 
  <a href="../RM/RM_H5S.html#Dataspace-CreateSimple" target=RMwindow>
  <code>H5Screate_simple</code></a> call that established the 
  dataset&rsquo;s original dimensions. The maximum dimension size is set 
  when the dataset is created and cannot be changed.

<h4><em>Datatype</em></h4>

  <p>Raw data has a datatype which describes the layout of the raw data stored in 
  the file. 
<!-- editingComment
  <span class="editingComment">[ [ [
  (See [[Datatype]]. 
  ] ] ]</span>
-->
  The datatype is set when the dataset is created 
  and can never be changed. When data is transferred to and from the dataset, 
  the HDF5 Library will assure that the data is transformed to and 
  from the stored format.

<h4><em>Storage Properties</em></h4>

  <p>Storage properties of the dataset are set when it is created. The 
  required inputs table 
  below shows the categories of storage properties. The storage properties 
  cannot be changed after the dataset is created. 
<!-- editingComment
  <span class="editingComment">[ [ [
  in [[storage properties]]
  ] ] ]</span>
-->

<h4><em>Filters</em></h4>

  <p>When a dataset is created, optional filters are specified. The filters are 
  added to the data transfer pipeline when data is read or written. The standard 
  library includes filters to implement compression, data shuffling, and error 
  detection code.  Additional user-defined filters may also be used. 
<!-- editingComment
  <span class="editingComment">[ [ [
  See [[[filter]]].
  ] ] ]</span>
-->

  <p>The required filters are stored as part of the dataset, and the list may 
  not be changed after the dataset is created. The HDF5 Library automatically 
  applies the filters whenever data is transferred.

<h4><em>Summary</em></h4>

  <p>A newly created dataset has no attributes and no data values. The dimensions, 
  datatype, storage properties, and selected filters are set. 
  The table below lists the required inputs, and the second table below lists 
  the optional inputs.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="left" valign="bottom"><b>Table 1. Required inputs</b></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Required Inputs</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Dataspace</td>
    <td class="ColumnRightCell"> <p>The shape of the array.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Datatype</td>
    <td class="ColumnRightCell"> <p>The layout of the stored elements.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Name</td>
    <td class="ColumnRightBottom"> <p>The name of the dataset in the group.</td>
  </tr>
</table>
<br />
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="left" valign="bottom"><b>Table 2. Optional inputs</b></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Optional Inputs</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Storage Layout</td>
    <td class="ColumnRightCell"> 
        <p>How the data is organized in the file including chunking.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Fill Value</td>
    <td class="ColumnRightCell"> 
        <p>The behavior and value for uninitialized data.</td>
  </tr>
    <tr valign=top> 
    <td class="ColumnLeftCell"> <p>External Storage</td>
    <td class="ColumnRightCell"> 
        <p>Option to store the raw data in an external file.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Folders</td>
    <td class="ColumnRightBottom"> 
        <p>Select optional filters to be applied, e.g., compression.</td>
  </tr>
</table>

<!-- NEW PAGE -->
<h4><em>Example</em></h4>

  <p>To create a new dataset</p>

<dir>
  Set dataset characteristics. (Optional where default settings are acceptable)
<br> 
<dir>               
  Datatype
<br> 
  Dataspace
<br> 
  Dataset creation property list
</dir> 
  Create the dataset.
<br> 
  Close the datatype, dataspace, and property list (as necessary).
<br> 
  Close the dataset.
</dir>

  <p>Example 1 below shows example code to create an empty dataset. The 
  dataspace is 7 x 8, and the datatype is a big-endian integer. The dataset is 
  created with the name "dset1" and is a member of the root group, "/".</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
    <pre><code>
    hid_t    dataset, datatype, dataspace;   

     /* 
      * Create dataspace: Describe the size of the array and 
      * create the dataspace for fixed-size dataset. 
     */
     dimsf[0] = 7;
     dimsf[1] = 8;
     dataspace = H5Screate_simple(2, dimsf, NULL); 
     /*
      * Define datatype for the data in the file.
      * For this example, store little-endian integer numbers.
      */
     datatype = H5Tcopy(H5T_NATIVE_INT);
     status = H5Tset_order(datatype, H5T_ORDER_LE);
     /*
      * Create a new dataset within the file using defined 
      * dataspace and datatype. No properties are set.
      */
     dataset = H5Dcreate(file, "/dset", datatype, dataspace, H5P_DEFAULT);

     H5Dclose(dataset);
     H5Sclose(dataspace);
     H5Tclose(datatype);
    </code></pre></td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Example 1. Create an empty dataset</span></td>
  </tr>
</table>
<br />
<!-- NEW PAGE -->
  <p>Example 2 below shows example code to create a similar dataset with a 
  fill value of '-1'. 
  This code has the same steps as in the example above, but uses a non-default 
  property list. 
  A file creation property list is created, and then the fill value is set 
  to the 
  desired value. Then the property list is passed to the H5Dcreate call.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
    <pre><code>
    hid_t    dataset, datatype, dataspace;
     hid_t plist;  /* property list */
     int fillval = -1;
     dimsf[0] = 7;
     dimsf[1] = 8;
     dataspace = H5Screate_simple(2, dimsf, NULL); 
     
     datatype = H5Tcopy(H5T_NATIVE_INT);
     status = H5Tset_order(datatype, H5T_ORDER_LE);

     /*
      * Example of Dataset Creation property list: set fill value to '-1'
      */
     plist = H5Pcreate((H5P_DATASET_CREATE);
     status = H5Pset_fill_value(plist,datatype, &fillval);

    /* Same as above, but use the property list */
     dataset = H5Dcreate(file, "/dset", datatype, dataspace, plist);

     H5Dclose(dataset);
     H5Sclose(dataspace);
     H5Tclose(datatype);
     H5Pclose(plist);
    </code></pre></td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Example 2. Create a dataset with fill value set 
    to -1</span></td>
  </tr>
</table>
<br />
  <p>After this code is executed, the dataset has been created and written to 
  the file. The data array is uninitialized.  Depending on the storage 
  strategy and fill value options that have been selected, some or all of the 
  space may be allocated in the file, and fill values may be written in the 
  file.
<!-- editingComment
  <span class="editingComment">[ [ [
  See &lt;&lt;below&gt;&gt;.
  ] ] ]</span>
-->

<h4>3.3 Data Transfer Operations on a Dataset</h4>

  <p>Data is transferred between memory and the raw data array of the dataset 
  through H5Dwrite and H5Dread operations. A data transfer has the 
  following basic steps:</p>
  
  <ol>
      <li>Allocate and initialize memory space as needed
      <li>Define the datatype of the memory elements
      <li>Define the elements to be transferred (a selection, or all the elements)
      <li>Set data transfer properties (including parameters for filters or 
          file drivers) as needed
      <li>Call the H5D API
  </ol>

  <p>Note that the location of the data in the file, the datatype of the data in 
  the file, the storage properties, and the filters do not need to be specified 
  because these are stored as a permanent part of the dataset. A selection of 
  elements from the dataspace is specified; the selected elements may be the 
  whole dataspace.

<!-- NEW PAGE -->
  <p>The figure below shows a diagram of a write operation which transfers a 
  data array from memory to a dataset in the file (usually on disk). A read 
  operation has similar parameters with the data flowing the other direction.</p>
  
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig5.JPG" width="670">
    </td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
        <span class=figurenumber>Figure 3. A write operation</span></td>
  </tr>
</table>

<h4><em>Memory Space</em></h4>

  <p>The calling program must allocate sufficient memory to store the data elements 
  to be transferred. For a write (from memory to the file), the memory must be 
  initialized with the data to be written to the file.  For a read, the memory must 
  be large enough to store the elements that will be read. The amount of storage 
  needed can be computed from the memory datatype (which defines the size of each 
  data element) and the number of elements in the selection.

<!-- NEW PAGE -->
<h4><em>Memory Datatype</em></h4>

  <p>The memory layout of a single data element is specified by the memory datatype. 
  This specifies the size, alignment, and byte order of the element as well as the 
  datatype class. Note that the memory datatype must be the same datatype class 
  as the file, but may have different byte order and other properties.  The HDF5 
  Library automatically transforms data elements between the source and destination 
  layouts. See the chapter "<a href="11_Datatypes.html">HDF5 Datatypes</a>" 
  for more details.

  <p>For a write, the memory datatype defines the layout of the data to be written; 
  an example is IEEE floating-point numbers in native byte order. If the file 
  datatype (defined 
  when the dataset is created) is different but compatible, the HDF5 Library will 
  transform each data element when it is written. For example, if the file byte 
  order is different than the native byte order, the HDF5 Library 
  will swap the bytes.

  <p>For a read, the memory datatype defines the desired layout of the data to be read. 
  This must be compatible with the file datatype, but should generally use native 
  formats, e.g., byte orders. The HDF5 Library will transform each data 
  element as it is read.

<h4><em>Selection</em></h4>

  <p>The data transfer will transfer some or all of the elements of the dataset 
  depending on the dataspace selection. The selection has two dataspace objects: 
  one for the source, and one for the destination. These objects describe 
  which elements 
  of the dataspace to be transferred. Some (partial I/O) or all of the data 
  may be transferred. Partial I/O is defined by defining hyperslabs or lists 
  of elements in a dataspace object.

  <p>The dataspace selection for the source defines the indices of the elements 
  to be read or written. The two selections must define the same number of 
  points, but the order and layout may be different.  The HDF5 Library 
  automatically selects and distributes the elements according to the 
  selections. It might, for example, perform a scatter-gather or 
  sub-set of the data. 
<!-- editingComment
  <span class="editingComment">[ [ [
  See [[Selections]].
  ] ] ]</span>
-->

<h4><em>Data Transfer Properties</em></h4>

  <p>For some data transfers, additional parameters should be set using the 
  transfer property list. The table below lists the categories of transfer 
  properties. These properties set parameters for the HDF5 Library and may 
  be used to pass parameters for optional filters and file drivers. For 
  example, transfer properties are used to select independent or collective 
  operation when using MPI-I/O.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="left" valign="bottom"><b>Table 3. Categories of 
    transfer properties</b></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Properties</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Library parameters</td>
    <td class="ColumnRightCell"> <p>Internal caches, buffers, B-Trees, etc.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Memory management</td>
    <td class="ColumnRightCell"> 
        <p>Variable-length memory management, data overwrite</td>
  </tr>
    <tr valign=top> 
    <td class="ColumnLeftCell"> <p>File driver management</td>
    <td class="ColumnRightCell"> <p>Parameters for file drivers</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Filter management</td>
    <td class="ColumnRightBottom"> <p>Parameters for filters</td>
  </tr>
</table>

<h4><em>Data Transfer Operation (Read or Write)</em></h4>

  <p>The data transfer is done by calling H5Dread or H5Dwrite with the parameters 
  described above. The HDF5 Library constructs the required pipeline, 
  which will scatter-gather, transform datatypes, apply the requested filters, 
  and use the correct file driver.

  <p>During the data transfer, the transformations and filters are applied to 
  each element of the data in the required order until all the 
  data is transferred.

<!-- editingComment
  <span class="editingComment">[ [ [
  <p>[[See Data Transfer Below]]
  ] ] ]</span>
-->

<h4><em>Summary</em></h4>

  <p>To perform a data transfer, it is necessary to allocate and initialize memory, 
  describe the source and destination, set required and optional transfer properties, 
  and call the H5D API. 

<h4><em>Examples</em></h4>

  <p>The basic procedure to <b>write</b> to a dataset is the following:</p>

<dir>
  Open the dataset.<br>
  Set the dataset dataspace for the write (optional if dataspace is H5S_SELECT_ALL).<br>
  Write data.<br>
  Close the datatype, dataspace, and property list (as necessary).<br>
  Close the dataset.<br>
</dir> 

  <p>Example 3 below shows example code to write a 4 x 6 array of integers. 
  In the example, 
  the data is initialized in the memory array dset_data.  The dataset has already 
  been created in the file, so it is opened with H5Dopen.

  <p>The data is written with H5Dwrite. The arguments are the dataset handle, the memory 
  datatype (H5T_NATIVE_INT), the memory and file selections (H5S_ALL in this case: 
  the whole array), and the default (empty) property list. The last argument is 
  the data to be transferred.</p>
  
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
    <pre><code>
   hid_t       file_id, dataset_id;  /* identifiers */
   herr_t      status;
   int         i, j, dset_data[4][6];

   /* Initialize the dataset. */
   for (i = 0; i < 4; i++)
      for (j = 0; j < 6; j++)
         dset_data[i][j] = i * 6 + j + 1;

   /* Open an existing file. */
   file_id = H5Fopen("dset.h5", H5F_ACC_RDWR, H5P_DEFAULT);

   /* Open an existing dataset. */
   dataset_id = H5Dopen(file_id, "/dset");

   /* Write the entire dataset, using 'dset_data': 
         memory type is 'native int'
         write the entire dataspace to the entire dataspace,
         no transfer properties,
    */
   status = H5Dwrite(dataset_id, H5T_NATIVE_INT, H5S_ALL, 
           H5S_ALL, H5P_DEFAULT, dset_data);


   status = H5Dclose(dataset_id);
    </code></pre></td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Example 3. Write an array of integers</span></td>
  </tr>
</table>
<br />
<!-- NEW PAGE -->
  <p>Example 4 below shows a similar write except for setting a non-default 
  value for the transfer buffer. 
<!-- editingComment
  <span class="editingComment">[ [ [
  &lt;&lt;explain what this does&gt;&gt;.  
  ] ] ]</span>
-->
  The code is the same as Example 3, but a transfer 
  property list is created, and the desired buffer size is set. The H5Dwrite 
  function has the same arguments, but uses the property list to set the 
  buffer.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
    <pre><code>
   hid_t       file_id, dataset_id;  
   hid_t  xferplist;
   herr_t      status;
   int         i, j, dset_data[4][6];

   file_id = H5Fopen("dset.h5", H5F_ACC_RDWR, H5P_DEFAULT);

   dataset_id = H5Dopen(file_id, "/dset");

   /*
     * Example: set type conversion buffer to 64MB
     */
    xferplist = H5Pcreate(H5P_DTASET_XFER);
    status = H5Pset_buffer( xferplist, 64 * 1024 *1024, NULL, NULL);

   /* Write the entire dataset, using 'dset_data': 
         memory type is 'native int'
         write the entire dataspace to the entire dataspace,
         set the buffer size with the property list,
    */
   status = H5Dwrite(dataset_id, H5T_NATIVE_INT, H5S_ALL, 
           H5S_ALL, plist, dset_data);


   status = H5Dclose(dataset_id);
    </code></pre></td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Example 4. Write an array using a property list</span></td>
  </tr>
</table>
<br />
<!-- editingComment
  <span class="editingComment">[ [ [
  <p>Partial writes (i.e., of selected data elements, such as a hyperslab) 
  are explained below [[partial I/O]]
  ] ] ]</span>
-->

  <p>The basic procedure to <b>read</b> from a dataset is the 
  following:</p>

<dir>
  Define the memory dataspace of the read (optional if dataspace is 
  H5S_SELECT_ALL).<br> 
  Open the dataset.<br> 
  Get the dataset dataspace (if using H5S_SELECT_ALL above).<br> 

<dir>Else define dataset dataspace of read.</dir> 
  Define the memory datatype (optional).<br> 
  Define the memory buffer.<br> 
  Open the dataset.<br> 
  Read data.<br> 
  Close the datatype, dataspace, and property list (as necessary).<br> 
  Close the dataset.
</dir>
  
<!-- NEW PAGE -->
  <p>The example below shows code that reads a 4 x 6 array of integers from 
  a dataset called "dset1". First, the dataset is opened. 
  The H5Dread call has parameters:</p>
  
  <ul>
      <li>The dataset handle (from H5Dopen)
      <li>The memory datatype (H5T_NATVE_INT)
      <li>The memory and file dataspace (H5S_ALL, the whole array)
      <li>A default (empty) property list
      <li>The memory to be filled
  </ul>
  
<br>  
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
    <pre><code>
   hid_t       file_id, dataset_id;  
   herr_t      status;
   int         i, j, dset_data[4][6];


   /* Open an existing file. */
   file_id = H5Fopen("dset.h5", H5F_ACC_RDWR, H5P_DEFAULT);

   /* Open an existing dataset. */
   dataset_id = H5Dopen(file_id, "/dset");

   /* read the entire dataset, into 'dset_data': 
         memory type is 'native int'
         read the entire dataspace to the entire dataspace,
         no transfer properties,
    */
   status = H5Dread(dataset_id, H5T_NATIVE_INT, H5S_ALL, 
           H5S_ALL, H5P_DEFAULT, dset_data);

   status = H5Dclose(dataset_id);
    </code></pre></td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Example 5. Read an array from a dataset</span></td>
  </tr>
</table>
<br />
<h4>3.4 Retrieve the Properties of a Dataset</h4>

  <p>
  The functions listed below allow the user to retrieve 
  information regarding a dataset including the datatype, 
  the dataspace, the dataset creation property list, 
  and the total stored size of the data.

  <p>
<table x-use-null-cells
		class="functTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="left valign="bottom"><b>Function Listing 4. 
    Retrieve dataset information</b></td>
  </tr>
  <tr valign=top> 
    <td class="functTableLeftHdr"> 
        <p><span class=TableHead>Query Function</span></td>
    <td class="functTableRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="functTableCell"> <p>H5Dget_space</td>
    <td class="functTableCell"> <p>Retrieve the dataspace of the dataset 
         as stored in the file.</td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell"> <p>H5Dget_type</td>
    <td class="functTableCell"> <p>Retrieve the datatype of the dataset 
         as stored in the file.</td>
  </tr>
    <tr valign=top> 
    <td class="functTableCell"> <p>H5Dget_create_plist</td>
    <td class="functTableCell"> <p>Retrieve the 
        dataset creation properties.</td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell"> <p>H5Dget_storage_size</td>
    <td class="functTableCell"> 
        <p>Retrieve the total bytes for all the data of the dataset.</td>
  </tr>
  <tr valign=top> 
    <td class="functTableBottom"> <p>H5Dvlen_get_buf_size</td>
    <td class="functTableBottom"> 
        <p>Retrieve the total bytes for all the variable-length 
	data of the dataset.</td>
  </tr>
</table>
<br />
<!-- NEW PAGE -->

<p>The example below illustrates how to retrieve dataset information.
<br />
<br />
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell"> 
    <pre><code>
   hid_t       file_id, dataset_id;
   hid_t    dspace_id, dtype_id, plist_id; 
   herr_t      status;

   /* Open an existing file. */
   file_id = H5Fopen("dset.h5", H5F_ACC_RDWR, H5P_DEFAULT);

   /* Open an existing dataset. */
   dataset_id = H5Dopen(file_id, "/dset");

   dspace_id = H5Dget_space(dataset_id);
   dtype_id = H5Dget_type(dataset_id);
   plist_id = H5Dget_create_plist(dataset_id);

   /* use the objects to discover the properties of the dataset */

   status = H5Dclose(dataset_id);
    </code></pre>
    </td>
  </tr>
<!-- 8.12.10, i added this table row with the figurenumber class -->
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Example 6. Retrieve dataset information</span></td>
  </tr>
</table>
<br />
<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="DTransfer">
<div align=right>
<a href="#TOP"><font size=-1>(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<!-- NEW PAGE -->
<a name="DTransfer">
<h3 class=pagebefore>4. Data Transfer. Raw data I/O</h3>
</a>

  <p>The HDF5 Library implements data transfers through a pipeline which implements 
  data transformations (according to the datatype and selections), chunking (as 
  requested), and I/O operations using different mechanisms (file drivers). 
  The pipeline is automatically configured by the HDF5 Library. Metadata is 
  stored in the file so that the correct pipeline can be constructed to retrieve 
  the data. In addition, optional filters such as compression may be 
  added to the standard pipeline. 

  <p>The figure below illustrates data layouts for different layers of an 
  application using HDF5. 
  The application data is organized as a multidimensional array of elements. 
  The HDF5 format specification
<!-- editingComment
  <span class="editingComment">[ [ [
   [[cite it]] 
  ] ] ]</span>
-->
  defines the stored layout of the data 
  and metadata.  The storage layout properties define the organization of the 
  abstract data. This data is written and read to and from some storage medium.</p>
  
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="left">
    <img src="Images/Dsets_fig9.JPG" width="700">
    </td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
        <span class=figurenumber>Figure 4. Data layouts in an application</span></td>
  </tr>
</table>
<br />
<!-- NEW PAGE -->
  <p>The last stage of a write (and first stage of a read) is managed by an HDF5 
  file driver module.  The virtual file layer of the HDF5 Library implements a 
  standard interface to alternative I/O methods, including memory (AKA "core") files, 
  single serial file I/O, multiple file I/O, and parallel I/O. The file driver maps 
  a simple abstract HDF5 file to the specific access methods.

  <p>The raw data of an HDF5 dataset is conceived to be a multi-dimensional array of 
  data elements. This array may be stored in the file according to 
  several storage strategies:</p> 

  <ul>
      <li>Contiguous
      <li>Chunked
      <li>Compact
  </ul>

  <p>The storage strategy does not affect data access methods except that certain 
  operations may be more or less efficient depending on the storage strategy 
  and the access patterns.

  <p>Overall, the data transfer operations (H5Dread and H5Dwrite) work identically 
  for any storage method, for any file driver, and for any filters and transformations. 
  The HDF5 Library automatically manages the data transfer process. In some cases, 
  transfer properties should or must be used to pass additional parameters such as 
  MPI/IO directives when used the parallel file driver.

<h4>4.1 The Data Pipeline</h4>

  <p>When data is written or read to or from an HDF5 file, the HDF5 Library passes 
  the data through a sequence of processing steps which are known as the HDF5 
  data pipeline. This data 
  pipeline performs operations on the data in memory such as byte swapping, alignment, 
  scatter-gather, and hyperslab selections. The HDF5 Library automatically determines 
  which operations are needed and manages the organization of memory operations 
  such as extracting selected elements from a data block. The data pipeline modules 
  operate on data buffers: each module processes a buffer and passes the 
  transformed buffer to the next stage.

  <p>The table below lists the stages of the data pipeline. The figure below 
  the table shows the order of processing 
  during a read or write.</p>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="left valign="bottom"><b>Table 4. Stages of the data pipeline</b></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Layers</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>I/O initiation</td>
    <td class="ColumnRightCell"> 
        <p>Initiation of HDF5 I/O activities (H5Dwrite and H5Dread) in a 
        user's application program. </td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Memory hyperslab operation</td>
    <td class="ColumnRightCell"> 
        <p>Data is scattered to (for read), or gathered from (for write) the 
        application's 
	memory buffer (bypassed if no datatype conversion is needed).</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Datatype conversion</td>
    <td class="ColumnRightCell"> 
        <p>Datatype is converted if it is different between memory and storage 
	(bypassed if no datatype conversion is needed).</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>File hyperslab operation</td>
    <td class="ColumnRightCell"> 
        <p>Data is gathered from (for read), or scattered to (for write) to 
	file space in memory (bypassed if no datatype conversion is needed).</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Filter pipeline</td>
    <td class="ColumnRightCell"> 
        <p>Data is processed by filters when it passes.  Data can be modified and 
	restored here (bypassed if no datatype conversion is needed, no filter is 
	enabled, or dataset is not chunked).</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Virtual File Layer</td>
    <td class="ColumnRightCell"> 
        <p>Facilitate easy plug-in file drivers such as MPIO or POSIX I/O.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Actual I/O</td>
    <td class="ColumnRightBottom"> 
        <p>Actual file driver used by the library such as MPIO or STDIO.</td>
  </tr>
</table>

<br>
<br />

<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig10.JPG"><br>
    </td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
        <span class=figurenumber>Figure 5. The processing order in the data pipeline</span></td>
  </tr>
</table>

  <br>
  <p>The HDF5 Library automatically applies the stages as needed.  

  <p>When the memory dataspace selection is other than the whole dataspace, the memory 
  hyperslab stage scatters/gathers the data elements between the application 
  memory (described by the selection) and a contiguous memory buffer for the pipeline. 
  On a write, this is a gather operation; on a read, this is a scatter operation.

  <p>When the memory datatype is different from the file datatype, the datatype 
  conversion stage transforms each data element. For example, if data is written 
  from 32-bit big-endian memory, and the file datatype is 32-bit little-endian, 
  the datatype conversion stage will swap the bytes of every elements.  Similarly, 
  when data is read from the file to native memory, byte swapping will be 
  applied automatically when needed.

  <p>The file hyperslab stage is similar to the memory hyperslab stage, 
  but is managing the arrangement of the elements according to the 
  dataspace selection. When data is read, data elements are gathered from 
  the data blocks from the file to fill the contiguous buffers which are then 
  processed by the pipeline. When data is read, the elements from a buffer 
  are scattered to the data blocks of the file.

<h4>4.2 Data Pipeline Filters</h4>

  <p>In addition to the standard pipeline, optional stages, called filters, 
  can be inserted in the pipeline. 
<!-- editingComment
  <span class="editingComment">[ [ [
  see [[chunked]]) 
  ] ] ]</span>
-->
  The standard distribution includes optional filters to 
  implement compression and error checking. User applications may 
  add custom filters as well.

  <p>The HDF5 Library distribution includes or employs 
  several optional filters. These are listed in the table below. 
  The filters are applied in the pipeline between the virtual file layer and 
  the file hyperslab operation. See the figure above. The application can 
  use any number of filters in any order.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="left valign="bottom"><b>Table 5. Data pipeline filters</b></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Filter</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>gzip compression</td>
    <td class="ColumnRightCell"> <p>Data compression using 
      <code>zlib</code>.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Szip&nbsp;compression&nbsp;</td>
    <td class="ColumnRightCell"> <p>Data compression using the 
      Szip library. See The HDF Group website for more information regarding 
      the <a href="http://www.hdfgroup.org/doc_resource/SZIP/" target="Ext1">Szip</a> filter.
</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>N-bit compression</td>
    <td class="ColumnRightCell"> <p>Data compression using an algorithm 
      specialized for n-bit datatypes.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Scale-offset compression</td>
    <td class="ColumnRightCell"> <p>Data compression using using a 
      &ldquo;scale and offset&rdquo; algorithm.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Shuffling</td>
    <td class="ColumnRightCell"> 
        <p>To improve compression performance, data is regrouped by 
	its byte position in the data unit.  
	In other words, the 1<sup><font size="-1">st</font></sup>, 
	2<sup><font size="-1">nd</font></sup>, 
	3<sup><font size="-1">rd</font></sup>, and 
	4<sup><font size="-1">th</font></sup> bytes of integers are 
	stored together respectively.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Fletcher32</td>
    <td class="ColumnRightBottom"> 
        <p>Fletcher32 checksum for error-detection.</td>
  </tr>
</table>
<br />
  <p>Filters may be used only for chunked data and are applied to chunks of 
  data between the file hyperslab stage and the virtual file layer. At this 
  stage in the pipeline, the data is organized as fixed-size blocks of elements,
  and the filter stage processes each chunk separately.

  <p>Filters are selected by dataset creation properties, and some behavior may 
  be controlled by data transfer properties. The library determines what 
  filters must be applied and applies them in the order in which they were
  set by the application. That is, if an application calls
  <code>H5Pset_shuffle</code> and then <code>H5Pset_deflate</code> when 
  creating
  a dataset&rsquo;s creation property list, the library will apply the 
  shuffle filter first and then the deflate filter.
  
  <p>Information regarding the n-bit and scale-offset filters 
  can be found in <a href="#N-Bit">Using the N-bit Filter</a> 
  and <a href="#ScaleOffset">Using the Scale-offset Filter</a>,
  respectively.

<h4>4.3 File Drivers</h4>

  <p>I/O is performed by the HDF5 virtual file layer. The file driver interface 
  writes and reads blocks of data; each driver module implements the interface 
  using different I/O mechanisms. 
  The table below lists the file drivers currently supported. 
  Note that the I/O mechanisms are separated from the pipeline processing: 
  the pipeline and filter operations are identical no matter what 
  data access mechanism is used.</p>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="left valign="bottom"><b>Table 6. I/O file drivers</b></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>File Driver</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5FD_CORE</td>
    <td class="ColumnRightCell"> 
        <p>Store in memory (optional backing store to disk file).</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5FD_FAMILY</td>
    <td class="ColumnRightCell"> <p>Store in a set of files. 
<!-- editingComment
  <span class="editingComment">[ [ [
    (See [[??]])
  ] ] ]</span>
-->
    </td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5FD_LOG</td>
    <td class="ColumnRightCell"> <p>Store in logging file.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5FD_MPIO</td>
    <td class="ColumnRightCell"> <p>Store using MPI/IO. 
<!-- editingComment
  <span class="editingComment">[ [ [
    (See [[cite]])
  ] ] ]</span>
-->
    </td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5FD_MULTI</td>
    <td class="ColumnRightCell"> 
        <p>Store in multiple files. There are several options to control 
        layout.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5FD_SEC2</td>
    <td class="ColumnRightCell"> 
        <p>Serial I/O to file using Unix "section 2" functions.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5FD_STDIO</td>
    <td class="ColumnRightCell"> 
        <p>Serial I/O to file using Unix "stdio" functions.</td>
  </tr>
<!-- 8.19.10, this driver is no longer used. it's possible it might be used at some point in the future.
  <tr valign=top>
    <td class="ColumnLeftBottom"> <p>H5FD_STREAM</td>
    <td class="ColumnRightBottom"> <p>I/O to socket.</td>
  </tr> -->
</table>

  <p>Each file driver writes/reads contiguous blocks of bytes from a logically 
  contiguous address space. The file driver is responsible for managing the 
  details of the different physical storage methods.

  <p>In serial environments, everything above the virtual file layer tends 
  to work identically no matter what storage method is used. </p>
  
  <p>Some options may have 
  substantially different performance depending on the file driver that is used. 
  In particular, multi-file and parallel I/O may perform considerably differently 
  from serial drivers depending on chunking and other settings.</p>

<h4>4.4 Data Transfer Properties to Manage the Pipeline</h4>

  <p>Data transfer properties set optional parameters that control parts of the 
  data pipeline. The function listing below shows transfer properties 
  that control the behavior of the library.
  <br />
  <br />
<!-- editingComment
  <span class="editingComment">[ [ [
  &lt;&lt;Developers: explain what these do!&gt;&gt;</p>
  ] ] ]</span>
-->

<table x-use-null-cells
		class="functTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="left valign="bottom"><b>Function Listing 5. 
    Data transfer property list functions</b></td>
  </tr>
  <tr valign=top> 
    <td class="functTableLeftHdr"> 
        <p><span class=TableHead>Property</span></td>
    <td class="functTableRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="functTableCell"> <p>H5Pset_buffer</td>
    <td class="functTableCell"> 
        <p>Maximum size for the type conversion buffer and the background 
        buffer. May also  
	supply pointers to application-allocated buffers.</td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell"> <p>H5Pset_hyper_cache</td>
    <td class="functTableCell"> 
        <p>Whether to cache hyperslab blocks during I/O.</td>
  </tr>
  <tr valign=top> 
    <td class="functTableBottom"> <p>H5Pset_btree_ratios</td>
    <td class="functTableBottom"> 
        <p>Set the B-tree split ratios for a dataset transfer property list. 
	The split ratios determine what percent of children go in the 
	first node when a node splits.</td>
  </tr>
</table>
<br />
  <p>Some filters and file drivers require or use additional parameters from the 
  application program. These can be passed in the data transfer property list. 
  The table below shows file driver property list functions.</p>
  
<table x-use-null-cells
		class="functTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="left valign="bottom"><b>Function Listing 6. 
    File driver property list functions</b></td>
  </tr>
  <tr valign=top> 
    <td class="functTableLeftHdr"> 
        <p><span class=TableHead>Property</span></td>
    <td class="functTableRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="functTableCell"> <p>H5Pset_dxpl_mpio</td>
    <td class="functTableCell"> 
        <p>Control the MPI I/O transfer mode (independent or collective) 
	during data I/O operations.</td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell"> <p>H5Pset_dxpl_multi</td>
    <td class="functTableCell"> <p>Sets the data transfer property list for 
    the multi-file driver. </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell"> <p>H5Pset_small_data_block_size</td>
    <td class="functTableCell"> 
        <p>Reserves blocks of size bytes for the contiguous storage of the raw 
	data portion of small datasets. The HDF5 Library then writes the raw data 
	from small datasets to this reserved space which reduces unnecessary 
	discontinuities within blocks of metadata and 
	improves I/O performance.</td>
  </tr>
  <tr valign=top> 
    <td class="functTableBottom"> <p>H5Pset_edc_check</td>
    <td class="functTableBottom"> 
        <p>Disable/enable EDC checking for read. When selected, EDC 
	is always written.</td>
  </tr>
</table>

  <p>The transfer properties are set in a property list which is passed as a 
  parameter of the H5Dread or H5Dwrite call.  The transfer properties are 
  passed to each pipeline stage. Each stage may use or ignore any property in the 
  list. In short, there is one property list that contains all the properties.

<!-- NEW PAGE -->
<h4>4.5 Storage Strategies</h4>

  <p>The raw data is conceptually a multi-dimensional array of elements that is 
  stored as a contiguous array of bytes. The data may be physically stored 
  in the file in several ways. The table below lists the storage strategies 
  for a dataset.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="left valign="bottom"><b>Table 7. Dataset 
    storage strategies</b></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Storage Strategy</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Contiguous</td>
    <td class="ColumnRightCell"> 
        <p>The dataset is stored as one continuous array of bytes.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Chunked</td>
    <td class="ColumnRightCell"> 
        <p>The dataset is stored as fixed-size chunks.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Compact</td>
    <td class="ColumnRightBottom"> 
        <p>A small dataset is stored in the metadata header.</td>
  </tr>
</table>

  <p>The different storage strategies do not affect the data transfer operations of 
  the dataset: reads and writes work the same for any storage strategy.

<!-- editingComment
  <span class="editingComment">[ [ [
  <p>&lt;&lt;Relationship between storage strategies, and pipeline, filters, 
  and file drivers.??&gt;&gt;
  ] ] ]</span>
-->

  <p>These strategies are described in the following sections.

<h4><em>Contiguous</em></h4>

  <p>A contiguous dataset is stored in the file as a header and a single 
  continuous array of bytes. See the figure below. In the case of a 
  multi-dimensional array, the data is serialized in row major order. 
  By default, data is stored contiguously.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig12.JPG">
    </td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 6. Contiguous data storage</span></td>
  </tr>
</table>


  <p>Contiguous storage is the simplest model. It has several limitations. 
  First, the dataset must be a fixed-size: it is not possible to extend the 
  limit of dataset, or to have unlimited dimensions. Second, because data is 
  passed through the pipeline as fixed-size blocks, compression and other 
  filters cannot be used with contiguous data.

<h4><em>Chunked</em></h4>

  <p>The data of a dataset may be stored as fixed-size chunks. See the 
  figure below. 
  A chunk is a hyper-rectangle of any shape. 
  When a dataset is chunked, each chunk is read or written as a single I/O 
  operation, and individually passed from stage to stage of the data pipeline. 
  </p>


<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig13.JPG">
    </td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 7. Chunked data storage</span></td>
  </tr>
</table>
<br />

<!-- NEW PAGE -->
  <p>Chunks may be any size and shape that fits in the dataspace of the dataset.
  For example, a three dimensional dataspace can be chunked as 3-D cubes, 
  2-D planes, or 1-D lines. The chunks may extend beyond the size of the 
  dataspace. For example, a 3 x 3 dataset might by chunked in 2 x 2 chunks. 
  Sufficient chunks will be allocated to store the array, and any extra space 
  will not be accessible. So, to store the 3 x 3 array, four 2 x 2 chunks would 
  be allocated with 5 unused elements stored.

  <p>Chunked datasets can be unlimited in any direction 
  and can be compressed or filtered.

  <p>Since the data is read or written by chunks, chunking can have a dramatic 
  effect on performance by optimizing what is read and written.  Note, too, 
  that for specific access patterns such as parallel I/O, decomposition into 
  chunks can have a large impact on performance.

  <p>Two restrictions have been placed on chunk shape and size:
<table width=100%><tr align=left><td>
    <ul>
      <li>The rank of a chunk must be less than or equal to 
          the rank of the dataset
      <li>Chunk size cannot exceed the size of a fixed-size dataset; 
          for example, a dataset consisting of a 5 x 4 fixed-size array 
          cannot be defined with 10 x 10 chunks
    </ul>
</td></tr></table>



<h4><em>Compact</em></h4>

  <p>For contiguous and chunked storage, the dataset header information and data 
  are stored in two (or more) blocks. Therefore, at least two I/O operations 
  are required to access the data: one to access the header, and one (or more) 
  to access data. For a small dataset, this is considerable overhead.

  <p>A small dataset may be stored in a continuous array of bytes in the 
  header block using the compact storage option. This dataset can be read 
  entirely in one operation which retrieves the header and data.  
  The dataset must fit in the header. This may vary depending on the 
  metadata that is stored. In general, a compact dataset should be 
  approximately 30 KB or less total size.
  See the figure below.

<br />
<br />
<table x-use-null-cells
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig14.JPG">
    </td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 8. Compact data storage</span></td>
  </tr>
</table>
<br />

<!-- NEW PAGE -->
<h4>4.6 Partial I/O Sub-setting and Hyperslabs</h4>

  <p>Data transfers can write or read some of the data elements of the dataset. 
  This is controlled by specifying two selections: one for the source and one for 
  the destination. Selections are specified by creating a dataspace 
  with selections. 
<!-- editingComment
  <span class="editingComment">[ [ [
  (see [[dataspace chapter]])
  ] ] ]</span>
-->

  <p>Selections may be a union of hyperslabs or a list of points.
  A hyperslab is a contiguous 
  hyper-rectangle from the dataspace. 
  Selected fields of a compound datatype may be read or written. 
  In this case, the selection is controlled by the memory and file datatypes.

  <p>Summary of procedure:</p>
  
  <ol>
      <li>Open the dataset
      <li>Define the memory datatype
      <li>Define the memory dataspace selection and file dataspace selection
      <li>Transfer data (H5Dread or H5Dwrite)
  </ol>

  <p>For a detailed explanation of selections, see the chapter
  "<a href="12_Dataspaces.html">HDF5 Dataspaces and Partial I/O</a>."
  
<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="Allocation">
<div align=right>
<a href="#TOP"><font size=-1>(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>









<!-- NEW PAGE -->
<a name="Allocation">
<h3 class=pagebefore>5. Allocation of Space in the File</h3>
</a>

  <p>When a dataset is created, space is allocated in the file for its header and 
  initial data. The amount of space allocated when the dataset is created depends 
  on the storage properties. When the dataset is modified (data is written, 
  attributes added, or other changes), additional storage may be 
  allocated if necessary.</p>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="left valign="bottom"><b>Table 8. Initial dataset size</b></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Object</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Size</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Header</td>
    <td class="ColumnRightCell"> 
        <p>Variable, but typically around 256 bytes at the creation of 
        a simple dataset with a simple datatype.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Data</td>
    <td class="ColumnRightBottom"> 
        <p>Size of the data array (number of elements x size of element). 
	Space allocated in the file depends on the storage strategy 
	and the allocation strategy.</td>
  </tr>
</table>

<h4><em>Header</em></h4>

  <p>A dataset header consists of one or more header messages containing 
  persistent metadata describing various aspects of the dataset. 
  These records are defined in the <a href="../H5.format.html"><i>HDF5 File Format Specification</i></a>. 
<!-- editingComment
  <span class="editingComment">[ [ [
  [[cite format]]. 
  ] ] ]</span>
-->
  The amount of storage required for the metadata depends on the metadata 
  to be stored. The table below summarizes the metadata.</p>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="left valign="bottom"><b>Table 9. Metadata storage sizes</b></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr" width="33%"> 
        <p><span class=TableHead>Header Information</span></td>
    <td class="ColumnRightHdr" width="67%"> 
        <p><span class=TableHead>Approximate Storage Size</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Datatype (required)</td>
    <td class="ColumnRightCell"> <p>Bytes  or more. Depends on type.
<!-- editingComment
  <span class="editingComment">[ [ [
  Verify
  ] ] ]</span>
-->
    </td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Dataspace (required)</td>
    <td class="ColumnRightCell"> 
        <p>Bytes or more. Depends on number of dimensions and hsize_t.
<!-- editingComment
  <span class="editingComment">[ [ [
  Verify
  ] ] ]</span>
-->
	</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> 
        <p>Layout (required)</td>
    <td class="ColumnRightCell"> 
        <p>Points to the stored data. Bytes or more. Depends on hsize_t and 
        number of dimensions.
<!-- editingComment
  <span class="editingComment">[ [ [
  Verify
  ] ] ]</span>
-->
	</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Filters</td>
    <td class="ColumnRightBottom"> 
        <p>Depends on the number of filters. The size of the filter message depends on 
	the name and data that will be passed.</td>
  </tr>
</table>

  <p>The header blocks also store the name and values of attributes, so the total 
  storage depends on the number and size of the attributes.

  <p>In addition, the dataset must have at least one link, including a name, 
  which is stored in the file and in the group it is linked from.

  <p>The different storage strategies determine when and how much space is 
  allocated for the data array. See the discussion of fill values below
<!-- editingComment
  <span class="editingComment">[ [ [
  Link
  ] ] ]</span>
-->
  for a detailed explanation of the storage allocation.

<h4><em>Contiguous Storage</em></h4>

  <p>For a continuous storage option, the data is stored in a single, 
  contiguous block in the file.  The data is nominally a fixed-size, 
  (number of elements x size of element). The figure below shows an example 
  of a two 
  dimensional array stored as a contiguous dataset.

  <p>Depending on the fill value properties, the space may be allocated when the 
  dataset is created or when first written (default), and filled with fill values 
  if specified. For parallel I/O, by default the space is allocated 
  when the dataset is created.</p>
  
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig15.JPG">
    </td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 9. A two dimensional array stored as a 
    contiguous dataset</span></td>
  </tr>
</table>

<h4><em>Chunked</em></h4>

  <p>For chunked storage, the data is stored in one or more chunks.  Each chunk 
  is a continuous block in the file, but chunks are not necessarily stored 
  contiguously. Each chunk has the same size.  The data array has the same 
  nominal size as a contiguous array (number of elements x size of element), 
  but the storage is allocated in chunks, so the total size in the file can 
  be larger that the nominal size of the array. See the figure below.
  
  <p>If a fill value is defined, each chunk will be filled with the fill value. 
  Chunks must be allocated when data is written, but they may be allocated when 
  the file is created, as the file expands, or when data is written. 

  <p>For serial I/O, by default chunks are allocated incrementally, as data is 
  written to the chunk. For a sparse dataset, chunks are allocated only for the 
  parts of the dataset that are written. In this case, if the dataset is extended, 
  no storage is allocated.

  <p>For parallel I/O, by default chunks are allocated when the dataset is 
  created or extended with fill values written to the chunk.

  <p>In either case, the default can be changed using fill value properties.  
  For example, using serial I/O, the properties can select to allocate 
  chunks when the dataset is created.

  <p>
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig16.JPG">
    </td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 10. A two dimensional array stored in 
    chunks</span></td>
  </tr>
</table>

  
  <br />
<h4><em>Changing Dataset Dimensions</em></h4>  
  
  <p>H5Dset_extent is used to change the current dimensions of the dataset within 
  the limits of the dataspace.  Each dimension can be extended up to its maximum 
  or unlimited. Extending the dataspace may or may not allocate space in the file 
  and may or may not write fill values, if they are defined.  
  See the example code below.

  <p>The dimensions of the dataset can also reduced. If the sizes specified 
  are smaller than the dataset’s current dimension sizes, H5Dset_extent will 
  reduce the dataset’s dimension sizes to the specified values. 
  It is the user’s responsibility to ensure that valuable data is not 
  lost; H5Dset_extent does not check.
  <br>
  <br>
  
  
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
    <pre><code>
   hid_t       file_id, dataset_id;  
   Herr_t      status;
   size_t        newdims[2];


   /* Open an existing file. */
   file_id = H5Fopen("dset.h5", H5F_ACC_RDWR, H5P_DEFAULT);

   /* Open an existing dataset. */
   dataset_id = H5Dopen(file_id, "/dset");

   /* Example:  dataset is 2 x 3, each dimension is UNLIMITED */
   /* extend to 2 x 7 */
   newdims[0] = 2;
   newdims[1] = 7;

   status = H5Dset_extent(dataset_id, newdims);

   /* dataset is now 2 x 7 */

   status = H5Dclose(dataset_id);
    </code></pre></td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Example 7. Using H5Dset_extent to increase the 
    size of a dataset</span></td>
  </tr>
</table>
  <br />
<h4>5.1 Storage Allocation in the File: Early, Incremental, Late</h4>

  <p>The HDF5 Library implements several strategies for when storage is 
  allocated 
  if and when it is filled with fill values for elements not yet written by 
  the user. 
  Different strategies are recommended for different storage layouts and file 
  drivers. 
  In particular, a parallel program needs storage allocated during a 
  collective call 
  (for example, create or extend) while serial programs may benefit from 
  delaying the 
  allocation until the data is written.

  <p>Two file creation properties control when to allocate space, when to 
  write the fill value, and the actual fill value to write. 

  <h4><em>When to Allocate Space</em></h4>  

  <p>The table below shows the options for when data is allocated in the 
  file. "Early" 
  allocation is done during the dataset create call. Certain file drivers 
  (especially 
  MPI-I/O and MPI-POSIX) require space to be allocated when a dataset is created, 
  so all processors will have the correct view of the data.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="left valign="bottom"><b>Table 10. File storage allocation options</b></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Strategy</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Early</td>
    <td class="ColumnRightCell"> 
        <p>Allocate storage for the dataset immediately when the dataset 
	is created. </td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Late</td>
    <td class="ColumnRightCell"> 
        <p>Defer allocating space for storing the dataset until the 
	dataset is written.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Incremental</td>
    <td class="ColumnRightCell"> 
        <p>Defer allocating space for storing each chunk until 
	the chunk is written.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Default</td>
    <td class="ColumnRightBottom"> 
        <p>Use the strategy (Early, Late, or Incremental) for the storage method 
	and access method. This is the recommended strategy.</td>
  </tr>
</table>

  <p>"Late" allocation is done at the time of the first write to dataset. Space 
  for the whole dataset is allocated at the first write.

  <p>"Incremental" allocation (chunks only) is done at the time of the first 
  write to the chunk. Chunks that have never been written are not allocated 
  in the file. In a sparsely populated dataset, this option allocates chunks 
  only where data is actually written.

<!-- NEW PAGE -->
  <p>The "Default" property selects the option recommended as appropriate for 
  the storage method and access method. The defaults are shown in the table below. 
  Note that "Early" allocation is recommended for all Parallel I/O, while 
  other options are recommended as the default for serial I/O cases.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="3" align="left valign="bottom"><b>Table 11. Default storage options</b></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr" width="33%"> 
        <p><span class=TableHead>&nbsp;</span></td>
    <td class="ColumnLeftHdr" width="34%"> 
        <p><span class=TableHead>Serial I/O</span></td>
    <td class="ColumnRightHdr" width="33%"> 
        <p><span class=TableHead>Parallel I/O</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Contiguous Storage</td>
    <td class="ColumnCell"> <p>Late</td>
    <td class="ColumnRightCell"> <p>Early</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Chunked Storage</td>
    <td class="ColumnCell"> <p>Incremental</td>
    <td class="ColumnRightCell"> <p>Early</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Compact Storage</td>
    <td class="ColumnBottom"> <p>Early</td>
    <td class="ColumnRightBottom"> <p>Early</td>
  </tr>
</table>
 <br />
 
 <h4><em>When to Write the Fill Value</em></h4>  

  <p>The second property is when to write the fill value. The possible values 
  are "Never" and "Allocation". 
  The table below shows these options.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="left valign="bottom"><b>Table 12. When to write fill values</b></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>When</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Never</td>
    <td class="ColumnRightCell"> <p>Fill value will never be written.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Allocation</td>
    <td class="ColumnRightBottom"> 
        <p>Fill value is written when space is allocated. (Default for chunked 
	and contiguous data storage.)</td>
  </tr>
</table>
<br />

<h4><em>Fill Values</em></h4>  

  <p>The third property is the fill value to write. The table below shows the 
  values. By default, the data is filled with zeroes. The application may 
  choose no fill value (Undefined). In this case, uninitialized data may have 
  random values. The application may define a fill value of an 
  appropriate type. See the chapter "<a href="11_Datatypes.html">HDF5 
  Datatypes</a>" for more information regarding fill values.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="left valign="bottom"><b>Table 13. Fill values</b></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>What to Write</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Default</td>
    <td class="ColumnRightCell"> 
        <p>By default, the library fills allocated space with zeroes.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Undefined</td>
    <td class="ColumnRightCell"> 
        <p>Allocated space is filled with random values.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>User-defined</td>
    <td class="ColumnRightBottom"> 
        <p>The application specifies the fill value.</td>
  </tr>
</table>
<br />
<!-- NEW PAGE -->
  <p>Together these three properties control the library's behavior. 
  The table below summarizes the possibilities during the dataset 
  create-write-close cycle.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="4" align="left"><b>Table 14. Storage allocation and fill summary</b></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr" width="16.5%"> 
        <p align="left"><span class=TableHead>When to allocate space</span></td>
    <td class="ColumnHdr" width="16.5%"> 
        <p align="left"><span class=TableHead>When to write fill value</span></td>
    <td class="ColumnHdr" width="17%"> 
        <p align="left"><span class=TableHead>What fill value to write</span></td>
    <td class="ColumnRightHdr" width="50%"> 
        <p align="left">
	<span class=TableHead>Library create-write-close behavior</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Early</td>
    <td class="ColumnCell"> <p>Never</td>
    <td class="ColumnCell"> <p>-</td>
    <td class="ColumnRightCell"> 
        <p>Library allocates space when dataset is created, but never writes a fill 
	value to dataset. A read of unwritten data returns undefined values.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Late</td>
    <td class="ColumnCell"> <p>Never</td>
    <td class="ColumnCell"> <p>-</td>
    <td class="ColumnRightCell"> 
        <p>Library allocates space when dataset is written to, but never writes 
	a fill value to the dataset. A read of unwritten data returns 
	undefined values.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Incremental</td>
    <td class="ColumnCell"> <p>Never</td>
    <td class="ColumnCell"> <p>-</td>
    <td class="ColumnRightCell"> 
        <p>Library allocates space when a dataset or chunk (whichever is the 
        smallest 
	unit of space) is written to, but it never writes a fill value to a 
        dataset or a 
	chunk. A read of unwritten data returns undefined values.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>-</td>
    <td class="ColumnCell"> <p>Allocation</td>
    <td class="ColumnCell"> <p>Undefined</td>
    <td class="ColumnRightCell"> 
        <p><strong>Error</strong> on creating the dataset. The dataset is not 
        created.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Early</td>
    <td class="ColumnCell"> <p>Allocation</td>
    <td class="ColumnCell"> <p>Default or User-defined</td>
    <td class="ColumnRightCell"> 
        <p>Allocate space for the dataset when the dataset is created. Write 
        the fill value 
	(default or user-defined) to the entire dataset when the dataset is 
        created.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Late</td>
    <td class="ColumnCell"> <p>Allocation</td>
    <td class="ColumnCell"> <p>Default or User-defined</td>
    <td class="ColumnRightCell"> 
        <p>Allocate space for the dataset when the application first writes 
        data values 
	to the dataset. Write the fill value to the entire dataset before 
        writing 
	application data values.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Incremental</td>
    <td class="ColumnBottom"> <p>Allocation</td>
    <td class="ColumnBottom"> <p>Default or User-defined</td>
    <td class="ColumnRightBottom"> 
        <p>Allocate space for the dataset when the application first writes 
        data values 
	to the dataset or chunk (whichever is the smallest unit of space). 
	Write the fill value to the entire dataset or chunk before writing 
	application data values. </td>
  </tr>
</table>
<br />
<!-- NEW PAGE -->
  <p>During the H5Dread function call, the library behavior depends on whether 
  space has been allocated, whether the fill value has been written to 
  storage, 
  how the fill value is defined, and when to write the fill value. The table 
  below 
  summarizes the different behaviors.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="4" align="left"><b>Table 15. H5Dread summary</b></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr" width="16.5%"> 
        <p align="left">
	<span class=TableHead>Is space allocated in the file?</span></td>
    <td class="ColumnHdr" width="16.5%"> 
        <p align="left">
	<span class=TableHead>What is the fill value?</span></td>
    <td class="ColumnHdr" width="17%"> 
        <p align="left">
	<span class=TableHead>When to write fill value?</span></td>
    <td class="ColumnRightHdr" width="50%"> 
        <p align="left">
	<span class=TableHead>Library read behavior</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>No</td>
    <td class="ColumnCell"> <p>Undefined</td>
    <td class="ColumnCell"> <p>&lt;&lt;any&gt;&gt;</td>
    <td class="ColumnRightCell"> 
        <p><strong>Error</strong>. Cannot create this dataset.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>No</td>
    <td class="ColumnCell"> <p>Default or User-defined</td>
    <td class="ColumnCell"> <p>&lt;&lt;any&gt;&gt;</td>
    <td class="ColumnRightCell"> <p>Fill the memory buffer with the fill value.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Yes</td>
    <td class="ColumnCell"> <p>Undefined</td>
    <td class="ColumnCell"> <p>&lt;&lt;any&gt;&gt;</td>
    <td class="ColumnRightCell"> 
        <p>Return data from storage (dataset). Trash is possible if the 
        application has not 
	written data to the portion of the dataset being read.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Yes</td>
    <td class="ColumnCell"> <p>Default or User-defined</td>
    <td class="ColumnCell"> <p>Never</td>
    <td class="ColumnRightCell"> 
        <p>Return data from storage (dataset). Trash is possible if the 
        application has not written data to the portion of the dataset being 
        read.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Yes</td>
    <td class="ColumnBottom"> <p>Default or User-defined</td>
    <td class="ColumnBottom"> <p>Allocation</td>
    <td class="ColumnRightBottom"> <p>Return data from storage (dataset).</td>
  </tr>
</table>

  <p>There are two cases to consider depending on whether the space in the 
  file 
  has been allocated before the read or not. When space has not yet been 
  allocated and 
  if a fill value is defined, the memory buffer will be filled with the 
  fill values 
  and returned. In other words, no data has been read from the disk. 
  If space has been allocated, the values are returned from the stored 
  data. The unwritten elements will be filled according to the fill value.
  

<h4>5.2  Deleting a Dataset from a File and Reclaiming Space</h4>

  <p>HDF5 does not at this time provide an easy mechanism to remove a dataset 
  from a 
  file or to reclaim the storage space occupied by a deleted object. </p>
  
  <p>Removing a dataset and reclaiming the space it used can be done with 
  the H5Ldelete function and the <a href="../RM/Tools.html#Tools-Repack">
  h5repack</a> utility program.
  With the H5Ldelete function, links to a dataset can be removed from the 
  file structure. After all the 
  links have been removed, the dataset becomes inaccessible to any 
  application and is effectively removed from the file. 
  The way to recover the space occupied by an unlinked dataset is to write 
  all of the objects of the file 
  into a new file. Any unlinked object is inaccessible to the application and 
  will not be included in the new file. 
  Writing objects to a new file can be done with a custom program or with 
  the h5repack utility program. 

  <!-- 8.11.10, MEE: in the paragraph below, the link should be changed.
  Links are now done separately from groups, but there is no HDF5 Links 
  chapter yet. -->
  <p>See the chapter "<a href="09_Groups.html">HDF5 Groups</a>" for 
  further discussion of HDF5 file structures and the use of links. 

<h4>5.3 Releasing Memory Resources</h4>

  <p>The system resources required for HDF5 objects such as datasets, 
  datatypes, and dataspaces should be released once access to the object is 
  no longer needed. This is accomplished via the appropriate close function. 
  This is not unique to datasets but a general requirement when working 
  with the HDF5 Library; failure to close objects will result in resource leaks. 

  <p>In the case where a dataset is created or data has been transferred, 
  there are several objects that must be closed. These objects 
<!-- editingComment
<span class="editingComment">
   [ [ [ 
   (T? above) 
   originally appeared here.  On the full editorial pass, 
   see if there is any apparent reason for the question.
   ] ] ]
  </span>
-->
  include datasets, 
  datatypes, dataspaces, and property lists. 

  <p>The application program must free any memory variables and buffers it 
  allocates. When accessing data from the file, the amount of memory required 
  can be determined by calculating the size of the memory datatype and the 
  number of elements in the memory selection.

  <p>Variable-length data are organized in two or more areas of memory. 
  See "<a href="11_Datatypes.html">HDF5 Datatypes</a>" for more information.
  When writing data, the application 
  creates an array of vl_info_t which contains pointers to the elements. 
  The elements might be, for example, strings. In the file, the 
  variable-length data is stored in two parts: 
  a heap with the variable-length values of the data elements and an array 
  of vlinfo_t elements. When the data is read, the amount of memory required 
  for the heap can be determined with the H5Dget_vlen_buf_size call.

  <p>The data transfer property may be used to set a custom memory manager 
  for allocating variable-length data for a H5Dread. This is set with the 
  H5Pset_vlen_mem_manager call.

  <p>To free the memory for variable-length data, it is necessary to visit each 
  element, free the variable-length data, and reset the element. The application 
  must free the memory it has allocated. For memory allocated by the HDF5 Library 
  during a read, the H5Dvlen_reclaim function can be used to perform this operation.

<h4>5.4 External Storage Properties</h4>

  <p>The external storage format allows data to be stored across a set of 
  non-HDF5 files. A set of segments (offsets and sizes) in one or more files 
  is defined as an external file list, or EFL, and the contiguous logical 
  addresses of the data storage are mapped onto these segments. Currently, 
  only the H5D_CONTIGUOUS storage format allows external storage. External 
  storage is enabled by a dataset creation property. The table below shows 
  the API.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="left" valign="bottom"><b>Table 16. External storage API</b></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Function</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell" width="50%"> 
        <code>herr_t H5Pset_external (hid_t plist, const char *name, off_t offset, 
	hsize_t size)</code> 
</td>
    <td class="ColumnRightCell" width="50%"> 
        <p>This function adds a new segment to the end of the external file list 
	of the specified dataset creation property list. The segment begins a 
	byte offset of file name and continues for size bytes. The space 
	represented by this segment is adjacent to the space already represented 
	by the external file list. The last segment in a file list may have the 
	size H5F_UNLIMITED, in which case the external file may be of unlimited 
	size and no more files can be added to the external files list.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <code>int H5Pget_external_count (hid_t plist)</code></td>
    <td class="ColumnRightCell"> 
        <p>Calling this function returns the number of segments in an external 
	file list. If the dataset creation property list has no external 
	data, then zero is returned.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> 
        <code>herr_t H5Pget_external (hid_t plist, int idx, size_t name_size, 
	char *name, off_t *offset, hsize_t *size)</code></td>
    <td class="ColumnRightBottom"> 
        <p>This is the counterpart for the H5Pset_external() function. Given a 
	dataset creation property list and a zero-based index into that list, 
	the file name, byte offset, and segment size are returned through non-null 
	arguments. At most name_size characters are copied into the name argument 
	which is not null terminated if the file name is longer than the supplied 
	name buffer (this is similar to strncpy()). </td>
  </tr>
</table>

<!-- editingComment
  <span class="editingComment">[ [ [
  - - - The text and figures that 
  follow may not correspond properly - - -
  <br>
  (Made a quick pass today to sort it out -- FMB, 24 Jy '03.)
  ] ] ]</span>
-->

<!-- NEW PAGE -->
  <p>The figure below shows an example of how a contiguous, one-dimensional dataset is 
  partitioned into three parts and each of those parts is stored in a segment 
  of an external file. The top rectangle represents the logical address space 
  of the dataset while the bottom rectangle represents an external file.
  <br />
  <br />
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig19.JPG">
    </td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 11. External file storage</span></td>
  </tr>
</table>
  <br />
  <p>The example below shows code that defines the external storage for the 
  example. Note that 
  the segments are defined in order of the logical addresses they represent, 
  not their order within the external file. It would also have been possible 
  to put the segments in separate files. Care should be taken when setting up 
  segments in a single file since the library doesn't automatically check for 
  segments that overlap.</p>
  
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
    <pre><code>
 Plist = H5Pcreate (H5P_DATASET_CREATE);
  H5Pset_external (plist, "velocity.data", 3000, 1000);
  H5Pset_external (plist, "velocity.data", 0, 2500);
  H5Pset_external (plist, "velocity.data", 4500, 1500);</code></pre>
	</td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Example 8. External storage</span></td>
  </tr>
</table>
<br />
  <p>The figure below shows an example of how a contiguous, two-dimensional 
  dataset is 
  partitioned into three parts and each of those parts is stored in a separate 
  external file. The top rectangle represents the logical address space of the 
  dataset while the bottom rectangles represent external files.</p>
  
  <p>
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
	<img src="Images/Dsets_fig20.jpg">
    </td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 12. Partitioning a 2-D dataset for external storage</span></td>
  </tr>
</table>

<!-- NEW PAGE -->
  <br />
  <p>The example below shows code for the partitioning described above.
  In this example, the library maps the multi-dimensional array onto a linear 
  address space as defined by the HDF5 format specification, and then maps that 
  address space into the segments defined in the external file list. 

  <p>
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
    <pre><code>
 Plist = H5Pcreate (H5P_DATASET_CREATE);
  H5Pset_external (plist, "scan1.data", 0, 24);
  H5Pset_external (plist, "scan2.data", 0, 24);
  H5Pset_external (plist, "scan3.data", 0, 16);
    </code></pre></td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Example 9. Partitioning a 2-D dataset for external storage</span></td>
  </tr>
</table>

  <p>The segments of an external file can exist beyond the end of the (external) 
  file. The library reads that part of a segment as zeros. When writing to a 
  segment that exists beyond the end of a file, the external file is automatically 
  extended. Using this feature, one can create a segment (or set of segments) 
  which is larger than the current size of the dataset. This allows the dataset 
  to be extended at a future time (provided the dataspace also allows the 
  extension).

  <p>All referenced external data files must exist before performing raw data I/O 
  on the dataset. This is normally not a problem since those files are being managed 
  directly by the application or indirectly through some other library. However, 
  if the file is transferred from its original context, care must be taken to assure 
  that all the external files are accessible in the new location.</p>




<br />
<a name="UseFilters">
<h3 class=pagebefore>6. Using HDF5 Filters</h3>
</a>

<a name="N-Bit">
<h3>6.1. The N-bit Filter</h3>
</a>

<p>N-bit data has <i>n</i> significant bits,  
  where <i>n</i> may not correspond to a precise number of bytes.
  On the other hand, computing systems and applications universally, 
  or nearly so, run most efficiently when manipulating data as 
  whole bytes or multiple bytes.

<p>Consider the case of 12-bit integer data.  
  In memory, that data will be handled in at least 2 bytes, or 16 bits, 
  and on some platforms in 4 or even 8 bytes.
  The size of such a dataset can be significantly reduced when written 
  to disk if the unused bits are stripped out.
  
<p>The <i>n-bit filter</i> is provided for this purpose,  
  <i>packing</i> n-bit data on output by stripping off all unused bits 
  and <i>unpacking</i> on input, restoring the extra bits required
  by the computational processor.
  
<h4><em>N-bit Datatype</em></h4>

<p>An <i>n-bit datatype</i> is a datatype of <i>n</i> significant bits.
  Unless it is packed, an <i>n</i>-bit datatype is presented as an 
  <i>n</i>-bit bitfield within a larger-sized value.  
  For example, a 12-bit datatype might be presented as a 12-bit field 
  in a 16-bit, or 2-byte, value.

<p>Currently, the datatype classes of n-bit datatype or n-bit field of a 
  compound datatype or an array datatype are limited to integer or 
  floating-point.
  
<p>The HDF5 user can create an n-bit datatype through a series of
  of function calls.
  For example, the following calls create a 16-bit datatype 
  that is stored in a 32-bit value with a 4-bit offset:
<dir><pre>
hid_t nbit_datatype = H5Tcopy(H5T_STD_I32LE);
H5Tset_precision(nbit_datatype, 16);
H5Tset_offset(nbit_datatype, 4);
</pre></dir>
  
<p>In memory, one value of the above example n-bit datatype would be stored on 
  a little-endian machine as follows:
  
<dl>
      <dt>
        <table border="1" width="80%" align="center">
          <tr>
            <td width="25%" align="center">byte 3</td>
            <td width="25%" align="center">byte 2</td>
            <td width="25%" align="center">byte 1</td>
            <td width="25%" align="center">byte 0</td>
          </tr>
          <tr>
            <td width="25%" align="center"><code>????????</code></td>
            <td width="25%" align="center"><code>????SPPP</code></td>
            <td width="25%" align="center"><code>PPPPPPPP</code></td>
            <td width="25%" align="center"><code>PPPP????</code></td>
          </tr>
        </table>
        <table width="80%" border="0" align="center">
          <tr>
            <td colspan="4"><font size=-1>
              Key: 
                  <code>S</code> - sign bit, 
                  <code>P</code> - significant bit, 
                  <code>?</code> - padding bit 
              <br>
              Sign bit is included in signed integer datatype precision.
	    </font></td>
          </tr>
        </table>
        <br>
        
      </dt>
</dl>

<h4><em>N-bit Filter</em></h4>

<p>When data of an n-bit datatype is stored on disk using the 
  n-bit filter, the filter <i>packs</i> the data by stripping off the 
  padding bits; only the significant bits are retained and stored.  
  The values on disk will appear as follows:
  
<dl>
      <dt>
        <table border="1" width="80%" align="center">
          <tr>
            <td width="45%" align="center">1st value</td>
            <td width="45%" align="center">2nd value</td>
            <td width="10%" align="center">&nbsp;</td>
          </tr>
          <tr>
            <td width="45%" align="center"><code>SPPPPPPP&nbsp;PPPPPPPP</code></td>
            <td width="45%" align="center"><code>SPPPPPPP&nbsp;PPPPPPPP</code></td>
            <td width="10%" align="center">...</td>
          </tr>
        </table>
        <table width="80%" border="0" align="center">
          <tr>
            <td colspan="4"><font size=-1>
              Key: 
                  <code>S</code> - sign bit, 
                  <code>P</code> - significant bit, 
                  <code>?</code> - padding bit 
              <br>
              Sign bit is included in signed integer datatype precision.
	    </font></td>
          </tr>
        </table>
      </dt>
</dl>

<p>The n-bit filter can be used effectively for compressing data of an n-bit
  datatype, including arrays and the n-bit fields of compound datatypes. 
  The filter supports complex situations where a compound datatype 
  contains member(s) of a compound datatype or an array datatype has
  a compound datatype as the base type.

<p>At present, the n-bit filter supports all datatypes. 
  For datatypes of class time, string,
  opaque, reference, <small>ENUM</small>, and 
  variable-length, the n-bit filter acts as a no-op which is short for no 
  operation. 
  For convenience, the rest of this section refers to such datatypes 
  as <i>no-op datatypes</i>.

<p>As is the case with all HDF5 filters, an application using 
  the n-bit filter must store data with chunked storage.
  
<h4><em>How Does the N-bit Filter Work?</em></h4>

<p>The n-bit filter always compresses and decompresses according to
  dataset properties supplied by the HDF5 Library in the 
  datatype, dataspace, or dataset creation property list.

<p>The dataset datatype refers to how data is stored in an HDF5 file while 
  the memory datatype refers to how data is stored in memory.
  The HDF5 Library will do datatype conversion when writing data 
  in memory to the dataset or reading data from the dataset to memory if 
  the memory datatype differs from the dataset datatype. 
  Datatype conversion is performed by HDF5 Library before n-bit compression 
  and after n-bit decompression.
  
<p>The following subsections examine the common cases:
  <ul>
    <li>N-bit integer conversions
    <li>N-bit floating-point conversions
  </ul>

<h5><em>N-bit Integer Conversions</em></h5>

<p>Integer data with a dataset of integer datatype of less than 
  full precision and a memory datatype of <code>H5T_NATIVE_INT</code>,
  provides the simplest application of the n-bit filter.

<p>The precision of <code>H5T_NATIVE_INT</code> is 8 muliplied by 
  <code>sizeof(int)</code>. 
  This value, the size of an <code>int</code> in bytes, differs from 
  platform to platform; we assume a value of <code>4</code> 
  for the following illustration.
  We further assume the memory byte order to be little-endian.

<p>In memory, therefore, the precision of <code>H5T_NATIVE_INT</code> 
  is 32 and the offset is 0. 
  One value of <code>H5T_NATIVE_INT</code> is laid out in memory 
  as follows:
 
<table border="0" width="80%" align="center">
  <tr>
    <td>
<pre>
| byte 3 | byte 2 | byte 1 | byte 0 |
                                
|SPPPPPPP|PPPPPPPP|PPPPPPPP|PPPPPPPP|

</pre>
    </td>
  </tr>
  <tr>
    <td colspan="4"><font size=-1>
      Key: 
        <code>S</code> - sign bit, 
        <code>P</code> - significant bit, 
        <code>?</code> - padding bit 
      <br>
      Sign bit is included in signed integer datatype precision.
      </font></td>
  </tr>
</table>
  
<p>Suppose the dataset datatype has a precision of 16 and an offset of 4. 
  After HDF5 converts values from the memory datatype to the dataset datatype, 
  it passes something like the following to the n-bit filter for compression:

<table border="0" width="80%" align="center">
  <tr>
    <td>
<pre>
| byte 3 |  byte 2 | byte 1 |  byte 0 |
               |                 |
|????????|????S|PPP|PPPPPPPP|PPPP|????|
               |_________________|
                 truncated bits
</pre>
    </td>
  </tr>
  <tr>
    <td colspan="4"><font size=-1>
      Key: 
        <code>S</code> - sign bit, 
        <code>P</code> - significant bit, 
        <code>?</code> - padding bit 
      <br>
      Sign bit is included in signed integer datatype precision.
      </font></td>
  </tr>
</table>
  
<p>Notice that only the specified 16 bits (15 significant bits and the 
  sign bit) are retained in the conversion.  All other significant bits 
  of the memory datatype are discarded because the dataset datatype 
  calls for only 16 bits of precision. 
  After n-bit compression, none of these discarded bits, known as 
  <i>padding bits</i> will be stored on disk.
  
<h5><em>N-bit Floating-point Conversions</em></h5>

<p>Things get more complicated in the case of a floating-point dataset 
  datatype class.  This sub-section provides an example that 
  illustrates the conversion from a memory datatype of 
  <code>H5T_NATIVE_FLOAT</code> to a dataset datatype of class 
  floating-point.

<!-- NEW PAGE --> 
<p>As before, let the <code>H5T_NATIVE_FLOAT</code> be 4 bytes long, 
  and let the memory byte order be little-endian. 
  Per the IEEE standard, one value of <code>H5T_NATIVE_FLOAT</code> 
  is laid out in memory as follows:
  
<table border="0" width="80%" align="center">
  <tr>
    <td>
<pre>
| byte 3 | byte 2 | byte 1 | byte 0 |
                         
|SEEEEEEE|EMMMMMMM|MMMMMMMM|MMMMMMMM|

</pre>
  </td></tr>
  <tr>
    <td colspan="4"><font size=-1>
      Key: 
        <code>S</code> - sign bit, 
        <code>E</code> - exponent bit, 
        <code>M</code> - mantissa bit, 
        <code>?</code> - padding bit 
      <br>
      Sign bit is included in floating-point datatype precision.
      </font></td>
  </tr>
</table>
 
  <br>
  
<p>Suppose the dataset datatype has a precision of 20, offset of 7, 
  mantissa size of 13, mantissa position of 7, 
  exponent size of 6, exponent position of 20, 
  and sign position of 26. 
  (See &ldquo;Definition of Datatypes,&rdquo; section 4.3 of the 
  &ldquo;<a href="UG_frame11Datatypes.html">Datatypes</a>&rdquo; chapter in the
  <a href="index.html"><cite>HDF5 User&rsquo;s Guide</cite></a> 
  for a discussion of creating and modifying datatypes.)
  
<p>After HDF5 converts values from the memory datatype to the dataset datatype, 
  it passes something like the following to the n-bit filter for compression:
  
<table border="0" width="80%" align="center">
  <tr>
    <td>
<pre>
| byte 3 | byte 2  | byte 1 | byte 0  |
              |               |
|?????SEE|EEEE|MMMM|MMMMMMMM|M|???????|
              |_______________|
              truncated mantissa
</pre>
  </td></tr>
  <tr>
    <td colspan="4"><font size=-1>
      Key: 
        <code>S</code> - sign bit, 
        <code>E</code> - exponent bit, 
        <code>M</code> - mantissa bit, 
        <code>?</code> - padding bit 
      <br>
      Sign bit is included in floating-point datatype precision.
      </font></td>
  </tr>
</table>
  
<p>The sign bit and truncated mantissa bits are not changed during 
  datatype conversion by the HDF5 Library. On the other hand,
  the conversion of the 8-bit exponent to a 6-bit exponent
  is a little tricky:
  
<dir>
  The bias for the new exponent in the n-bit datatype is: 
<!--      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;2&#094;(n-1)-1 
-->      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<code>2<sup>(n-1)</sup>-1</code> 
      <br>
  <p>The following formula is used for this exponent conversion:
  
<!--      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;exp8 - (2&#094;(8-1)-1) = exp6 - (2&#094;(6-1)-1) = actual exponent value 
-->
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;
      <code>exp8 - (2<sup>(8-1)</sup>-1)</code> = 
      <code>exp6 - (2<sup>(6-1)</sup>-1)</code> = 
      <i>actual exponent value</i> 

      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      where <code>exp8</code> is the stored decimal value 
      as represented by the 8-bit exponent
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      and <code>exp6</code> is the stored decimal value 
      as represented by the 6-bit exponent
</dir>

<p>In this example, caution must be taken to ensure that, 
  after conversion, the actual exponent value is 
  within the range that can be represented by a 6-bit exponent. 
  For example, 
  an 8-bit exponent can represent values  from -127 to 128 while 
  a 6-bit exponent can represent values only from -31 to 32.
  
<a name="Design">
<h4><em>N-bit Filter Behavior</em></h4>
</a>

<p>The n-bit filter was designed to treat the incoming data byte by byte at 
  the lowest level. The purpose was to make the n-bit filter as generic as 
  possible so that no pointer cast related to the datatype is needed.

<p>Bitwise operations are employed for packing and unpacking at the byte level.

<p>Recursive function calls are used to treat compound and array datatypes.

<h5><em>N-bit Compression</em></h5>

  The main idea of n-bit compression is to use a loop to compress each  
  data element in a chunk. Depending on the datatype of each element, 
  the n-bit filter will call one of four functions.  Each of these functions
  performs one of the following tasks:  

    <ul>
      <li>Compress a data element of a no-op datatype
      <li>Compress a data element of an atomic datatype
      <li>Compress a data element of a compound datatype
      <li>Compress a data element of an array datatype
    </ul> 


<p><b>No-op datatypes:</b>
  The n-bit filter does not actually compress no-op datatypes.  
  Rather, it copies the data buffer of the no-op datatype from the 
  noncompressed buffer to the proper location in the compressed buffer; 
  the compressed buffer has no holes. 
  The term "compress" is used here simply to distinguish this function  
  from the function that performs the reverse operation during decompression.
  

<p><b>Atomic datatypes:</b>
  The n-bit filter will find the bytes where significant bits are 
  located and try to compress these bytes, one byte at a time, using a loop. 
  At this level, the filter needs the following information:
  <ul>
    <li>The byte offset of the beginning of the current data element with 
        respect to the beginning of the input data buffer
    <li>Datatype size, precision, offset, and byte order  
  </ul>

<p>The n-bit filter compresses from the most significant byte containing 
  significant bits to the least significant byte.  
  For big-endian data, therefore, the loop index progresses from smaller
  to larger while for little-endian, the loop index progresses from larger
  to smaller.

<p>In the extreme case of when the n-bit datatype has full precision,
  this function copies the content of the entire noncompressed datatype 
  to the compressed output buffer.


<p><b>Compound datatypes:</b>
  The n-bit filter will compress each data member of the compound datatype. 
  If the member datatype is of an integer or floating-point datatype, 
  the n-bit filter will call the function described above<!-- in section 2.1.2-->. 
  If the member datatype is of a no-op datatype, 
  the filter will call the function described above<!-- in section 2.1.1-->. 
  If the member datatype is of a compound datatype, the filter will make a 
  recursive call to itself. 
<!--
  (i.e., to the function described in this section, 2.1.3). 
-->
  If the member datatype is of an array datatype, the filter will call the 
  function described below<!-- in section 2.1.4.-->


<p><b>Array datatypes:</b>
  The n-bit filter will use a loop to compress each array element in 
  the array. If the base datatype of array element is of an integer or 
  floating-point datatype, the n-bit filter will call the function described 
  above<!-- in section 2.1.2.--> 
  If the base datatype is of a no-op datatype, the filter will call the
  function described above<!-- in section 2.1.1.--> 
  If the base datatype is of a compound datatype, the filter will call the
  function described above<!-- in section 2.1.3-->. 
  If the member datatype is of an array datatype, the filter will make a 
  recursive call of itself.
<!--
  (i.e., to the function described in this section, 2.1.4).
-->
  
<h5><em>N-bit Decompression</em></h5>

<p>The n-bit decompression algorithm is very similar to n-bit compression. 
  The only difference is that at the byte level, compression packs out all 
  padding bits and stores only significant bits into a continous buffer 
  (unsigned char) while decompression unpacks significant bits and inserts 
  padding bits (zeros) at the proper positions to recover the data bytes 
  as they existed before compression.
  
<h5><em>Storing N-bit Parameters to Array</em> <code>cd_value[]</code></h5>

<p>All of the information, or parameters, required by the n-bit filter 
  are gathered and stored in the array <code>cd_values[]</code> by the 
  private function <code>H5Z_set_local_nbit</code> and are passed 
  to another private function, 
  <code>H5Z_filter_nbit</code>, by the HDF5 Library. 
  
<p>These parameters are as follows:
  <ol>
    <li>Parameters related to the datatype
    <li>The number of elements within the chunk
    <li>A flag indicating whether compression is needed
  </ol>

<p>The first and second parameters can be obtained using the HDF5 dataspace
  and datatype interface calls. 
<!--
  The third parameter is set during the storing process as described 
  in section 3.2.
-->

<p>A compound datatype can have members of array or compound datatype. 
  An array datatype's base datatype can be a complex compound datatype. 
  Recursive calls are required to set parameters for these complex situations.

<p>Before setting the parameters, the number of parameters should be 
  calculated to dynamically allocate the array <code>cd_values[]</code>,
  which will be passed to the HDF5 Library. 
  This also requires recursive calls.
  
<p>For an atomic datatype (integer or floating-point), parameters that will 
  be stored 
  include the datatype's size, endianness, precision, and offset. 
  
<p>For a no-op datatype, only the size is required.

<p>For a compound datatype, parameters that will be stored include the 
  datatype's
  total size and number of members. 
  For each member, its member offset needs to be stored. 
  Other parameters for members will depends on the respective datatype class.

<p>For an array datatype, the total size parameter should be stored. 
  Other parameters for the array's base type depend on the base type's 
  datatype class. 
  
<p>Further, to correctly retrieve the parameter for use of n-bit 
  compression or decompression later, parameters for distinguishing  
  between datatype classes should be stored.
  
<a name="implementation">
<h4><em>Implementation</em></h4>
</a>

<p>Three filter callback functions were written for the n-bit filter:
  <br><code>&nbsp;&nbsp;&nbsp;&nbsp;H5Z_can_apply_nbit</code>
  <br><code>&nbsp;&nbsp;&nbsp;&nbsp;H5Z_set_local_nbit</code>
  <br><code>&nbsp;&nbsp;&nbsp;&nbsp;H5Z_filter_nbit</code> 
  <br>These functions are called internally by the HDF5 Library. 
  A number of utility functions were written for the function 
  <code>H5Z_set_local_nbit</code>. Compression and decompression functions 
  were written and are called by function <code>H5Z_filter_nbit</code>. 
  All these functions are included in the file <code>H5Znbit.c</code>.

<p>The public function <code>H5Pset_nbit</code> is called by 
  the application to set up the use of the n-bit filter. 
  This function is included in the file <code>H5Pdcpl.c</code>. 
  The application does not need to supply any parameters.
  
<h5><em>How N-bit Parameters are Stored</em></h5>

<p>A scheme of storing parameters required by the n-bit filter in the 
  array <code>cd_values[]</code> was developed utilizing recursive 
  function calls.


<p>Four private utility functions were written for storing the parameters 
  associated with atomic (integer or floating-point), no-op, array, and 
  compound datatypes:
  <br><code>&nbsp;&nbsp;&nbsp;&nbsp;H5Z_set_parms_atomic</code>
  <br><code>&nbsp;&nbsp;&nbsp;&nbsp;H5Z_set_parms_array</code>
  <br><code>&nbsp;&nbsp;&nbsp;&nbsp;H5Z_set_parms_nooptype</code>
  <br><code>&nbsp;&nbsp;&nbsp;&nbsp;H5Z_set_parms_compound</code> 

<!-- NEW PAGE -->
<p>The scheme is briefly described below.

<dir>

  First, assign a numeric code for datatype class atomic (integer or float), 
  no-op, array, and compound datatype. The code is stored before other 
  datatype related parameters are stored.
  
<dl>
  <dd>
  <dt>The first three parameters of <code>cd_values[]</code> are reserved for:
    <ol>
      <li>The number of valid entries in the array <code>cd_values[]</code>
      <li>A flag indicating whether compression is needed
      <li>The number of elements in the chunk
    </ol>
  
    
  <dt>Throughout the balance of this explanation, 
    <code>i</code> represents the index of <code>cd_values[]</code>.
    <br>&nbsp;

  <dt>In the function <code>H5Z_set_local_nbit</code>:
  <dd>
      <ol>
        <li><code>i</code> = 2
        <li>Get the number of elements in the chunk and store in
          <code>cd_value[i]</code>; increment <code>i</code>
        <li>Get the class of the datatype:
          <br>&nbsp;&nbsp;For an integer or floating-point datatype, call 
          <code>H5Z_set_parms_atomic</code>
          <br>&nbsp;&nbsp;For an array datatype, call 
            <code>H5Z_set_parms_array</code>
          <br>&nbsp;&nbsp;For a compound datatype, call 
            <code>H5Z_set_parms_compound</code>
          <br>&nbsp;&nbsp;For none of the above, call 
            <code>H5Z_set_parms_noopdatatype</code>
        <li>Store <code>i</code> in <code>cd_value[0]</code> and 
          flag in <code>cd_values[1]</code>
      </ol>
  </dd>
</dl>

<dl>
  <dt>In the function <code>H5Z_set_parms_atomic</code>:</dt>
    <dd>
      <ol>
        <li>Store the assigned numeric code for the atomic datatype in 
          <code>cd_value[i]</code>; increment <code>i</code>
        <li>Get the size of the atomic datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code>
        <li>Get the order of the atomic datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code>
        <li>Get the precision of the atomic datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code>
        <li>Get the offset of the atomic datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code>
        <li>Determine the need to do compression at this point
      </ol>
  </dd>
</dl>

<dl>
  <dt>In the function <code>H5Z_set_parms_nooptype</code>:
  <dd>
      <ol>
        <li>Store the assigned numeric code for the no-op datatype in 
          <code>cd_value[i]</code>; increment <code>i</code>
        <li>Get the size of the no-op datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code>
      </ol>
  </dd>
</dl>

<dl>
  <dt>In the function <code>H5Z_set_parms_array</code>:
  <dd>
      <ol>
        <li>Store the assigned numeric code for the array datatype in 
          <code>cd_value[i]</code>; increment <code>i</code>
        <li>Get the size of the array datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code>
        <li>Get the class of the array's base datatype.
          <br>&nbsp;&nbsp;For an integer or floating-point datatype, 
            call <code>H5Z_set_parms_atomic</code>
          <br>&nbsp;&nbsp;For an array datatype, call 
            <code>H5Z_set_parms_array</code>
          <br>&nbsp;&nbsp;For a compound datatype, call 
            <code>H5Z_set_parms_compound</code>
          <br>&nbsp;&nbsp;If none of the above, 
            call <code>H5Z_set_parms_noopdatatype</code>
      </ol>
  </dd>
</dl>

<dl>
  <dt>In the function <code>H5Z_set_parms_compound</code>:
  <dd>
      <ol>
        <li>Store the assigned numeric code for the compound datatype in 
          <code>cd_value[i]</code>; increment <code>i</code>
        <li>Get the size of the compound datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code>
        <li>Get the number of members and store in 
          <code>cd_values[i]</code>; increment <code>i</code>
        <li>For each member
          <br>&nbsp;&nbsp;Get the member offset and store in 
            <code>cd_values[i]</code>; increment <code>i</code>
          <br>&nbsp;&nbsp;Get the class of the member datatype
          <br>&nbsp;&nbsp;For an integer or floating-point datatype, 
            call <code>H5Z_set_parms_atomic</code>
          <br>&nbsp;&nbsp;For an array datatype, 
            call <code>H5Z_set_parms_array</code>
          <br>&nbsp;&nbsp;For a compound datatype, 
            call <code>H5Z_set_parms_compound</code>
          <br>&nbsp;&nbsp;If none of the above, 
            call <code>H5Z_set_parms_noopdatatype</code>
      </ol>
  </dd>
</dl>

</dir>

<h5><em>N-bit Compression and Decompression Functions</em></h5>

<p>The n-bit compression and decompression functions above are called 
  by the private HDF5 function <code>H5Z_filter_nbit</code>. 
  The compress and decompress functions retrieve the n-bit parameters
  from <code>cd_values[]</code> as it was passed by
  <code>H5Z_filter_nbit</code>. Parameters are retrieved in exactly the 
  same order in which they are stored and lower-level compression and 
  decompression functions for different datatype classes are called. 
<!--
  These functions are implementated according to the descriptions 
  in sections 2.1 and 2.2.
-->
  
<p>N-bit compression is not implemented in place. Due to the 
  difficulty of calculating actual output buffer size after compression, 
  the same space as that of the input buffer is allocated for the output 
  buffer as passed to the compression function. However, the size of the 
  output buffer passed by reference to the compression function will 
  be changed (smaller) after the compression is complete.
  
<a name="examples">
<h4><em>Usage Examples</em></h4>
</a>

<p>The following code example illustrates the use of the n-bit filter 
  for writing and reading n-bit integer data.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">

<pre>
#include "hdf5.h"
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#define H5FILE_NAME  "nbit_test_int.h5"
#define DATASET_NAME "nbit_int"
#define NX 200
#define NY 300
#define CH_NX 10
#define CH_NY 15

int main(void)
{
   hid_t   file, dataspace, dataset, datatype, mem_datatype, dset_create_props;
   hsize_t dims[2], chunk_size[2];
   int     orig_data[NX][NY];
   int     new_data[NX][NY];
   int     i, j;
   size_t  precision, offset;


   /* Define dataset datatype (integer), and set precision, offset */
   datatype = H5Tcopy(H5T_NATIVE_INT);
   precision = 17; /* precision includes sign bit */
   if(H5Tset_precision(datatype,precision)&lt;0) {
      printf("Error: fail to set precision\n");
      return -1;
   }
   offset = 4;
   if(H5Tset_offset(datatype,offset)&lt;0) {
      printf("Error: fail to set offset\n");
      return -1;
   }


   /* Copy to memory datatype */
   mem_datatype = H5Tcopy(datatype);


   /* Set order of dataset datatype */
   if(H5Tset_order(datatype, H5T_ORDER_BE)&lt;0) {
      printf("Error: fail to set endianness\n");
      return -1;
   }


  /* Initiliaze data buffer with random data within correct range
   * corresponding to the memory datatype's precision and offset.
   */
   for (i=0; i &lt; NX; i++)
       for (j=0; j &lt; NY; j++)
           orig_data[i][j] = rand() % (int)pow(2, precision-1) &lt;&lt;offset;


   /* Describe the size of the array. */
   dims[0] = NX;
   dims[1] = NY;
   if((dataspace = H5Screate_simple (2, dims, NULL))&lt;0) {
      printf("Error: fail to create dataspace\n");
      return -1;
   }


  /*
   * Create a new file using read/write access, default file
   * creation properties, and default file access properties.
   */
   if((file = H5Fcreate (H5FILE_NAME, H5F_ACC_TRUNC,
                         H5P_DEFAULT, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create file\n");
      return -1;
   }


  /*
   * Set the dataset creation property list to specify that
   * the raw data is to be partitioned into 10 x 15 element
   * chunks and that each chunk is to be compressed.
   */
   chunk_size[0] = CH_NX;
   chunk_size[1] = CH_NY;
   if((dset_create_props = H5Pcreate (H5P_DATASET_CREATE))&lt;0) {
      printf("Error: fail to create dataset property\n");
      return -1;
   }
   if(H5Pset_chunk (dset_create_props, 2, chunk_size)&lt;0) {
      printf("Error: fail to set chunk\n");
      return -1;
   }


</pre><!-- NEW PAGE -->
<pre>
  /*
   * Set parameters for n-bit compression; check the description of
   * the H5Pset_nbit function in the HDF5 Reference Manual for more
   * information.
   */
   if(H5Pset_nbit (dset_create_props)&lt;0) {
      printf("Error: fail to set nbit filter\n");
      return -1;
   }


  /*
   * Create a new dataset within the file.  The datatype
   * and dataspace describe the data on disk, which may
   * be different from the format used in the application's
   * memory.
   */
   if((dataset = H5Dcreate2 (file, DATASET_NAME, datatype,
                            dataspace, H5P_DEFAULT, 
                            dset_create_props, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create dataset\n");
      return -1;
   }


  /*
   * Write the array to the file. The datatype and dataspace
   * describe the format of the data in the 'orig_data' buffer.
   * The raw data is translated to the format required on disk,
   * as defined above. We use default raw data transfer properties.
   */
   if(H5Dwrite (dataset, mem_datatype, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, orig_data)&lt;0) {
      printf("Error: fail to write to dataset\n");
      return -1;
   }


   H5Dclose (dataset);


   if((dataset = H5Dopen2(file, DATASET_NAME, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to open dataset\n");
      return -1;
   }


  /*
   * Read the array. This is similar to writing data,
   * except the data flows in the opposite direction.
   * Note: Decompression is automatic.
   */
   if(H5Dread (dataset, mem_datatype, H5S_ALL, H5S_ALL,
               H5P_DEFAULT, new_data)&lt;0) {
      printf("Error: fail to read from dataset\n");
      return -1;
   }


</pre><!-- NEW PAGE -->
<pre>
   H5Tclose (datatype);
   H5Tclose (mem_datatype);
   H5Dclose (dataset);
   H5Sclose (dataspace);
   H5Pclose (dset_create_props);
   H5Fclose (file);


   return 0;
}
</pre>
    </td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Example 10. N-bit compression for integer data</span><br /> 
         Illustrates the use of the n-bit filter for writing and reading 
         n-bit integer data.</td>
  </tr>
</table>


<br><!-- NEW PAGE -->
<p>The following code example illustrates the use of the n-bit filter 
  for writing and reading n-bit floating-point data.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
<pre>
#include "hdf5.h"
#define H5FILE_NAME  "nbit_test_float.h5"
#define DATASET_NAME "nbit_float"
#define NX 2
#define NY 5
#define CH_NX 2
#define CH_NY 5


int main(void)
{
   hid_t   file, dataspace, dataset, datatype, dset_create_props;
   hsize_t dims[2], chunk_size[2];
  /* orig_data[] are initialized to be within the range that can be
   * represented by dataset datatype (no precision loss during
   * datatype conversion)
   */
   float   orig_data[NX][NY] = {{188384.00, 19.103516, -1.0831790e9,
   -84.242188, 5.2045898}, {-49140.000, 2350.2500, -3.2110596e-1,
   6.4998865e-5, -0.0000000}};
   float   new_data[NX][NY];
   size_t  precision, offset;


  /* Define single-precision floating-point type for dataset
   *-------------------------------------------------------------------
   * size=4 byte, precision=20 bits, offset=7 bits,
   * mantissa size=13 bits, mantissa position=7,
   * exponent size=6 bits, exponent position=20,
   * exponent bias=31.
   * It can be illustrated in little-endian order as:
   * (S - sign bit, E - exponent bit, M - mantissa bit,
   *  ? - padding bit)
   *
   *           3        2        1        0
   *       ?????SEE EEEEMMMM MMMMMMMM M???????
   *
   * To create a new floating-point type, the following
   * properties must be set in the order of
   *     set fields -> set offset -> set precision -> set size.
   * All these properties must be set before the type can function.
   * Other properties can be set anytime. Derived type size cannot
   * be expanded bigger than original size but can be decreased.
   * There should be no holes among the significant bits. Exponent
   * bias usually is set 2^(n-1)-1, where n is the exponent size.


*-------------------------------------------------------------------*/
   datatype = H5Tcopy(H5T_IEEE_F32BE);
   if(H5Tset_fields(datatype, 26, 20, 6, 7, 13)&lt;0) {
      printf("Error: fail to set fields\n");
      return -1;
   }
   offset = 7;
   if(H5Tset_offset(datatype,offset)&lt;0) {
      printf("Error: fail to set offset\n");
      return -1;
   }
   precision = 20;
   if(H5Tset_precision(datatype,precision)&lt;0) {
      printf("Error: fail to set precision\n");
      return -1;
   }
   if(H5Tset_size(datatype, 4)&lt;0) {
      printf("Error: fail to set size\n");
      return -1;
   }
   if(H5Tset_ebias(datatype, 31)&lt;0) {
      printf("Error: fail to set exponent bias\n");
      return -1;
   }


   /* Describe the size of the array. */
   dims[0] = NX;
   dims[1] = NY;
   if((dataspace = H5Screate_simple (2, dims, NULL))&lt;0) {
      printf("Error: fail to create dataspace\n");
      return -1;
   }


  /*
   * Create a new file using read/write access, default file
   * creation properties, and default file access properties.
   */
   if((file = H5Fcreate (H5FILE_NAME, H5F_ACC_TRUNC,
                         H5P_DEFAULT, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create file\n");
      return -1;
   }


  /*
   * Set the dataset creation property list to specify that
   * the raw data is to be partitioned into 2 x 5 element
   * chunks and that each chunk is to be compressed.
   */
   chunk_size[0] = CH_NX;
   chunk_size[1] = CH_NY;
   if((dset_create_props = H5Pcreate (H5P_DATASET_CREATE))&lt;0) {
      printf("Error: fail to create dataset property\n");
      return -1;
   }
   if(H5Pset_chunk (dset_create_props, 2, chunk_size)&lt;0) {
      printf("Error: fail to set chunk\n");
      return -1;
   }


  /*
   * Set parameters for n-bit compression; check the description
   * of the H5Pset_nbit function in the HDF5 Reference Manual
   * for more information.
   */
   if(H5Pset_nbit (dset_create_props)&lt;0) {
      printf("Error: fail to set nbit filter\n");
      return -1;
   }


  /*
   * Create a new dataset within the file.  The datatype
   * and dataspace describe the data on disk, which may
   * be different from the format used in the application's
   * memory.
   */
   if((dataset = H5Dcreate2 (file, DATASET_NAME, datatype,
                            dataspace, H5P_DEFAULT, 
                            dset_creat_plists, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create dataset\n");
      return -1;
   }


  /*
   * Write the array to the file. The datatype and dataspace
   * describe the format of the data in the 'orig_data' buffer.
   * The raw data is translated to the format required on disk,
   * as defined above. We use default raw data transfer properties.
   */
   if(H5Dwrite (dataset, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, orig_data)&lt;0) {
      printf("Error: fail to write to dataset\n");
      return -1;
   }


   H5Dclose (dataset);


   if((dataset = H5Dopen2(file, DATASET_NAME, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to open dataset\n");
      return -1;
   }


  /*
   * Read the array. This is similar to writing data,
   * except the data flows in the opposite direction.
   * Note: Decompression is automatic.
   */
   if(H5Dread (dataset, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
               H5P_DEFAULT, new_data)&lt;0) {
      printf("Error: fail to read from dataset\n");
      return -1;
   }


   H5Tclose (datatype);
   H5Dclose (dataset);
   H5Sclose (dataspace);
   H5Pclose (dset_create_props);
   H5Fclose (file);


   return 0;
}
</pre>
    </td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Example 11. N-bit compression for floating-point data</span><br /> 
          Illustrates the use of the n-bit filter for writing and reading 
          n-bit floating-point data.</td>
  </tr>
</table>

<a name="limitations">
<h4><em>Limitations</em></h4>
</a>

<p>Because the array <code>cd_values[]</code> has to fit into an object 
  header message of 64K, the n-bit filter has an upper limit on the number 
  of n-bit parameters that can be stored in it. To be conservative, a maximum 
  of 4K is allowed for the number of parameters.

<p>The n-bit filter currently only compresses n-bit datatypes or fields derived 
  from integer or floating-point datatypes. The n-bit filter assumes padding 
  bits of zero. This may not be true since the HDF5 user can set padding bit 
  to be zero, one, or leave the background alone. However, it is expected 
  the n-bit filter will be modified to adjust to such situations.

<p>The n-bit filter does not have a way to handle the situation where the  
  fill value of a dataset is defined and the fill value is not of an n-bit 
  datatype although the dataset datatype is.





<!-- NEW PAGE -->
<a name="ScaleOffset">
<h3>6.2. The Scale-offset Filter</h3>
</a> 

<p>Generally speaking, scale-offset compression performs a scale and/or 
  offset operation on each data value and truncates the resulting value 
  to a minimum number of bits (minimum-bits) before storing it. 

<p>The current scale-offset filter supports integer and floating-point 
  datatypes only. For the floating-point datatype, float and double are supported, 
  but long double is not supported.

<p>Integer data compression uses a straight-forward algorithm. Floating-point 
  data compression adopts the GRiB data packing mechanism which offers 
  two alternate methods: a fixed minimum-bits method, and a variable 
  minimum-bits method. Currently, only the variable minimum-bits method 
  is implemented. <!-- 9.3.10, MEE: according to Kent, the fixed minimum-bits 
  method has not yet been implemented, and they do not have any plans to 
  implement it. -->

<p>Like other I/O filters supported by the HDF5 Library, applications 
  using the scale-offset filter must store data with chunked storage.
  
<p>
<b><i>Integer type:</i></b>
  The minimum-bits of integer data can be determined by the filter. 
  For example, if the maximum value of data to be compressed is 7065 
  and the minimum value is 2970. Then the "span" of dataset values is 
  equal to (max-min+1), which is 4676. If no fill value is defined for the 
  dataset, the minimum-bits is: <code>ceiling(log2(span)) = 12</code>. With fill 
  value set, the minimum-bits is: <code>ceiling(log2(span+1)) = 13</code>.

<p>HDF5 users can also set the minimum-bits. However, if the user gives 
  a minimum-bits that is less than that calculated by the filter, 
  the compression will be lossy.

<p>
<b><i>Floating-point type:</i></b>
  The basic idea of the scale-offset filter for the floating-point type is 
  to transform the data by some kind of scaling to integer data, and 
  then to follow the procedure of the scale-offset filter for the integer 
  type to 
  do the data compression. Due to the data transformation from 
  floating-point to integer, the scale-offset filter is 
  lossy in nature. 

<p>Two methods of scaling the floating-point data are used: the so-called 
  D-scaling and E-scaling. D-scaling is more straightforward and easy to 
  understand. For HDF5 1.8 release, only the D-scaling method has been 
  implemented. <!-- 9.3.10, MEE: According to Kent, E-scaling has not yet 
  been implemented, and they have no plans to implement it in the future. -->
  
<h4><em>Design</em></h4>

<p>Before the filter does any real work, it needs to gather some information 
  from the HDF5 Library through API calls. The parameters the filter needs 
  are: 
  <ul>
    <li>The minimum-bits of the data value</li>
    <li>The number of data elements in the chunk</li>
    <li>The datatype class, size, sign (only for integer type), byte order, 
    and fill value 
    if defined</li> 
</ul>
  
<p>Size and sign are needed to determine what kind of pointer 
    cast to use when retrieving values from the data buffer.
<p>The pipeline of the filter can be divided into four parts: (1)pre-compression; 
  (2)compression; (3)decompression; (4)post-decompression.

<p>Depending on whether a fill value is defined or not, the filter will handle 
  pre-compression and post-decompression differently. 

<p>The scale-offset filter only needs the memory byte order, size of datatype, 
  and minimum-bits for compression and decompression.

<p>Since decompression has no access to the original data, the minimum-bits 
  and the minimum value need to be stored with the compressed data for 
  decompression and post-decompression.
  

<h5><em>Integer Type</em></h5>

<p><i>Pre-compression: </i>
  During pre-compression minimum-bits is calculated if it is not 
  set by the user. For more information on how minimum-bits are calculated, 
  see section 6.1. "The N-bit Filter." 
 
<p>If the fill value is defined, finding the maximum and minimum values 
  should ignore the data element whose value is equal to the fill value. 

<p>If no fill value is defined, the value of each data element is subtracted 
  by the minimum value during this stage.

<p>If the fill value is defined, the fill value is assigned to the maximum 
  value. 
  In this way minimum-bits can represent a data element whose value is equal 
  to the fill value and subtracts the minimum value from a data element whose 
  value is not equal to the fill value.
<!-- 8.19.10, MEE: the paragraph belowis is Frank's revision of my editing -->
<!-- 9.3.10, MEE: Kent reviewed the paragraph below and said it was clear. -->
<p>The fill value (if defined), the number of elements in a chunk, the class of 
  the datatype, the size of the datatype, the memory order of the datatype, 
  and other similar elements will be 
  stored in the HDF5 object header for the post-decompression usage.

<p>After pre-compression, all values are non-negative and are within the range 
  that can be stored by minimum-bits.
  


<p><i>Compression: </i>
  All modified data values after pre-compression are packed together 
  into the compressed data buffer. The number of bits for each data value 
  decreases from the number of bits of integer (32 for most platforms) to 
  minimum-bits. The value of minimum-bits and the minimum value are added to 
  the data buffer and the whole buffer is sent back to the library. In this 
  way, the number of bits for each modified value is no more than 
  the size of minimum-bits.
  

<p><i>Decompression: </i>
  In this stage, the number of bits for each data value is resumed from 
  minimum-bits to the number of bits of integer.


<p><i>Post-decompression: </i>
  For the post-decompression stage, the filter does the opposite 
  of what it does during pre-compression except that it does not calculate 
  the minimum-bits or the minimum value. 
  These values were saved during compression and can be retrieved through 
  the resumed data buffer. If no fill value is defined, the filter adds 
  the minimum value back to each data element.</p>

<p>If the fill value is defined, the filter assigns the fill value to the 
  data 
  element whose value is equal to the maximum value that minimum-bits can 
  represent and adds the minimum value back to each data element whose value 
  is not equal to the maximum value that minimum-bits can represent.

<a name="SO_FloatingPoint">&nbsp;</a>
  </p>

<h5><em>Floating-point Type</em></h5>

<p>The filter will do data transformation from floating-point type to 
  integer type and then handle the data by using the procedure for handling 
  the integer data inside the filter.  
  Insignificant bits of floating-point data will be cut off 
  during data transformation, so this filter is a lossy compression method.

<p>There are two scaling methods: D-scaling and E-scaling. 
  The HDF5 1.8 release only supports D-scaling. D-scaling is short for 
  decimal scaling. E-scaling should be similar conceptually. In order 
  to transform data from floating-point to 
  integer, a scale factor is introduced. The minimum value will be calculated. 
  Each data element value will subtract the minimum value. The modified data 
  will be multiplied by 10 (Decimal) to the power of <code>scale_factor</code>, 
  and only the integer part will be kept and manipulated through the routines 
  for the integer type of the filter during pre-compression and compression. 
  Integer data will be divided by 10 to the power of 
  <code>scale_factor</code> to transform back to floating-point data 
  during decompression and post-decompression.  
  Each data element value will then add the minimum value, and the 
  floating-point data are resumed. However, the resumed data will lose some 
  insignificant bits compared with the original value.

<p>For example, the following floating-point data are manipulated by the 
  filter, and the D-scaling factor is 2.
  
<p>{104.561, 99.459, 100.545, 105.644}

<p>The minimum value is 99.459, each data element subtracts 99.459, the 
  modified data is {5.102, 0, 1.086, 6.185}.

<p>Since the D-scaling factor is 2, all floating-point data will be 
  multiplied by 10^2 with this result: 

  {510.2, 0, 108.6, 618.5}.

<p>The digit after decimal point will be rounded off, and then the set looks 
  like: 
  {510 , 0, 109, 619}.

<p>After decompression, each value will be divided by 10^2 and will be added 
  to the offset 99.459.

<p>The floating-point data becomes {104.559, 99.459, 100.549, 105.649}.

<p>The relative error for each value should be no more than 
  5* (10^(D-scaling factor +1)). D-scaling sometimes is also referred 
  as a variable minimum-bits method since for different datasets the 
  minimum-bits to represent the same decimal precision will vary. The 
  data value is modified to 2 to power of <code>scale_factor</code> for 
  E-scaling. E-scaling is also called fixed-bits method since for different 
  datasets the minimum-bits will always be fixed to the scale factor of 
  E-scaling. 
  Currently HDF5 ONLY supports D-scaling (variable minimum-bits) method.
  
<h4><em>Implementation</em></h4>

<p>The scale-offset filter implementation was written and included in the file 
  <code>H5Zscaleoffset.c</code>. Function <code>H5Pset_scaleoffset</code> was 
  written and included in the file "<code>H5Pdcpl.c</code>". The HDF5 user can 
  supply minimum-bits by calling function <code>H5Pset_scaleoffset</code>.

<!-- NEW PAGE -->
<p>The scale-offset filter was implemented based on the design outlined in 
  this section. However, the following factors need to be considered:
  
<dl>
  <dd>
    <ol>
      <li>The filter needs the appropriate cast pointer whenever it needs 
        to retrieve data values.
      <li>The HDF5 Library passes to the filter the to-be-compressed data 
        in the format of the dataset datatype, and the filter passes back the 
        decompressed data in the same format. If a fill value is defined, 
        it is also in dataset datatype format. 
        For example, if the byte order of the dataset datatype is different 
        from that of the memory datatype of the platform, compression or 
        decompression performs an endianness conversion of data buffer. 
        Moreover, it should be aware that memory byte order can be different 
        during compression and decompression.
      <li>The difference of endianness and datatype between file and memory 
        should be considered when saving and retrieval of minimum-bits, 
        minimum value, and fill value.
      <li>If the user sets the minimum-bits to full precision of the datatype, 
        no operation is needed at the filter side. If the full precision is 
        a result of calculation by the filter, then the minimum-bits needs 
        to be saved for decompression but no compression or decompression 
        is needed (only a copy of the input buffer is needed).
      <li>If by calculation of the filter, the minimum-bits is equal to zero, 
        special handling is needed. Since it means all values are the same, 
        no compression or decompression is needed. But the minimum-bits 
        and minimum value still need to be saved during compression.
      <li>For floating-point data, the minimum value of the dataset should 
        be calculated at first. Each data element value will then subtract 
        the minimum value to obtain the "offset" data. 
        The offset data will then follow the steps outlined above in the
        discussion of <a href="#SO_FloatingPoint">floating-point types</a>
        to do data transformation to integer and rounding.
    </ol>
  </dd>
</dl>

<h4><em>Usage Examples</em></h4>

<p>The following code example illustrates the use of the scale-offset filter 
  for writing and reading integer data.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
<pre>
#include "hdf5.h"
#include &lt;stdlib.h&gt;
#define H5FILE_NAME  "scaleoffset_test_int.h5"
#define DATASET_NAME "scaleoffset_int"
#define NX 200
#define NY 300
#define CH_NX 10
#define CH_NY 15
</pre>

<pre>
int main(void)
{
   hid_t   file, dataspace, dataset, datatype, dset_create_props;
   hsize_t dims[2], chunk_size[2];
   int     orig_data[NX][NY];
   int     new_data[NX][NY];   
   int     i, j, fill_val;   

   /* Define dataset datatype */
   datatype = H5Tcopy(H5T_NATIVE_INT);   
   
   /* Initiliaze data buffer */
   for (i=0; i &lt; NX; i++) 
       for (j=0; j &lt; NY; j++)
           orig_data[i][j] = rand() % 10000;

   /* Describe the size of the array. */
   dims[0] = NX;
   dims[1] = NY;
   if((dataspace = H5Screate_simple (2, dims, NULL))&lt;0) {
      printf("Error: fail to create dataspace\n");
      return -1;
   }

  /*
   * Create a new file using read/write access, default file
   * creation properties, and default file access properties.
   */
   if((file = H5Fcreate (H5FILE_NAME, H5F_ACC_TRUNC, 
                         H5P_DEFAULT, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create file\n");
      return -1;
   }

  /*
   * Set the dataset creation property list to specify that
   * the raw data is to be partitioned into 10 x 15 element
   * chunks and that each chunk is to be compressed.
   */
   chunk_size[0] = CH_NX;
   chunk_size[1] = CH_NY;
   if((dset_create_props = H5Pcreate (H5P_DATASET_CREATE))&lt;0) {
      printf("Error: fail to create dataset property\n");
      return -1;
   }
   if(H5Pset_chunk (dset_create_props, 2, chunk_size)&lt;0) {
      printf("Error: fail to set chunk\n");
      return -1;
   }

   /* Set the fill value of dataset */
   fill_val = 10000;
   if (H5Pset_fill_value(dset_create_props, H5T_NATIVE_INT, 
       &fill_val)&lt;0) {
      printf("Error: can not set fill value for dataset\n");
      return -1;
   }

  /*
   * Set parameters for scale-offset compression. Check the 
   * description of the H5Pset_scaleoffset function in the 
   * HDF5 Reference Manual for more information [3].
   */
   if(H5Pset_scaleoffset (dset_create_props, H5Z_SO_INT, 
                          H5Z_SO_INT_MINIMUMBITS_DEFAULT)&lt;0) {
      printf("Error: fail to set scaleoffset filter\n");
      return -1;
   }

  /*
   * Create a new dataset within the file. The datatype
   * and dataspace describe the data on disk, which may
   * or may not be different from the format used in the 
   * application's memory.  The link creation and 
   * dataset access property list parameters are passed 
   * with default values.
   */
   if((dataset = H5Dcreate2 (file, DATASET_NAME, datatype,
                            dataspace, H5P_DEFAULT,
                            dset_create_props, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create dataset\n");
      return -1;
   }

  /*
   * Write the array to the file. The datatype and dataspace
   * describe the format of the data in the 'orig_data' buffer.
   * We use default raw data transfer properties.
   */
   if(H5Dwrite (dataset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, orig_data)&lt;0) {
      printf("Error: fail to write to dataset\n");
      return -1;
   }

   H5Dclose (dataset);

   if((dataset = H5Dopen2(file, DATASET_NAME, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to open dataset\n");
      return -1;
   }   

  /*
   * Read the array. This is similar to writing data,
   * except the data flows in the opposite direction.
   * Note: Decompression is automatic.
   */
   if(H5Dread (dataset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL,
               H5P_DEFAULT, new_data)&lt;0) {
      printf("Error: fail to read from dataset\n");
      return -1;
   }

   H5Tclose (datatype);
   H5Dclose (dataset);
   H5Sclose (dataspace);
   H5Pclose (dset_create_props);
   H5Fclose (file);

   return 0;
}
</pre>
    </td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Example 12. Scale-offset compression integer data</span><br />
          Illustrates the use of the scale-offset filter for writing 
          and reading integer data.</td>
  </tr>
</table>

<br><!-- NEW PAGE -->
<p>The following code example illustrates the use of the scale-offset filter 
  (set for variable minimum-bits method) 
  for writing and reading floating-point data.</p>
  
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
<pre>
#include "hdf5.h"
#include &lt;stdlib.h&gt;
#define H5FILE_NAME  "scaleoffset_test_float_Dscale.h5"
#define DATASET_NAME "scaleoffset_float_Dscale"
#define NX 200
#define NY 300
#define CH_NX 10
#define CH_NY 15
</pre>

<pre>
int main(void)
{
   hid_t   file, dataspace, dataset, datatype, dset_create_props;
   hsize_t dims[2], chunk_size[2];
   float   orig_data[NX][NY];
   float   new_data[NX][NY];
   float   fill_val;   
   int     i, j;   

   /* Define dataset datatype */
   datatype = H5Tcopy(H5T_NATIVE_FLOAT);   
   
   /* Initiliaze data buffer */
   for (i=0; i < NX; i++) 
       for (j=0; j < NY; j++)
           orig_data[i][j] = (rand() % 10000) / 1000.0;

   /* Describe the size of the array. */
   dims[0] = NX;
   dims[1] = NY;
   if((dataspace = H5Screate_simple (2, dims, NULL))&lt;0) {
      printf("Error: fail to create dataspace\n");
      return -1;
   }

  /*
   * Create a new file using read/write access, default file
   * creation properties, and default file access properties.
   */
   if((file = H5Fcreate (H5FILE_NAME, H5F_ACC_TRUNC, 
                         H5P_DEFAULT, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create file\n");
      return -1;
   }

  /*
   * Set the dataset creation property list to specify that
   * the raw data is to be partitioned into 10 x 15 element
   * chunks and that each chunk is to be compressed.
   */
   chunk_size[0] = CH_NX;
   chunk_size[1] = CH_NY;
   if((dset_create_props = H5Pcreate (H5P_DATASET_CREATE))&lt;0) {
      printf("Error: fail to create dataset property\n");
      return -1;
   }
   if(H5Pset_chunk (dset_create_props, 2, chunk_size)&lt;0) {
      printf("Error: fail to set chunk\n");
      return -1;
   }

   /* Set the fill value of dataset */
   fill_val = 10000.0;
   if (H5Pset_fill_value(dset_create_props, H5T_NATIVE_FLOAT, 
       &fill_val)<0) {
      printf("Error: can not set fill value for dataset\n");
      return -1;
   }

  /*
   * Set parameters for scale-offset compression; use variable
   * minimum-bits method, set decimal scale factor to 3. Check the 
   * description of the H5Pset_scaleoffset function in the HDF5 
   * Reference Manual for more information [3].
   */
   if(H5Pset_scaleoffset (dset_create_props, H5Z_SO_FLOAT_DSCALE, 3)&lt;0) {
      printf("Error: fail to set scaleoffset filter\n");
      return -1;
   }

  /*
   * Create a new dataset within the file. The datatype
   * and dataspace describe the data on disk, which may
   * or may not be different from the format used in the 
   * application's memory.
   */
   if((dataset = H5Dcreate2 (file, DATASET_NAME, datatype,
                            dataspace, H5P_DEFAULT, 
                            dset_create_props, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create dataset\n");
      return -1;
   }

  /*
   * Write the array to the file. The datatype and dataspace
   * describe the format of the data in the 'orig_data' buffer.
   * We use default raw data transfer properties.
   */
   if(H5Dwrite (dataset, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, orig_data)&lt;0) {
      printf("Error: fail to write to dataset\n");
      return -1;
   }

   H5Dclose (dataset);

   if((dataset = H5Dopen2(file, DATASET_NAME, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to open dataset\n");
      return -1;
   }   

  /*
   * Read the array. This is similar to writing data,
   * except the data flows in the opposite direction.
   * Note: Decompression is automatic.
   */
   if(H5Dread (dataset, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
               H5P_DEFAULT, new_data)&lt;0) {
      printf("Error: fail to read from dataset\n");
      return -1;
   }

   H5Tclose (datatype);
   H5Dclose (dataset);
   H5Sclose (dataspace);
   H5Pclose (dset_create_props);
   H5Fclose (file);

   return 0;
}
</pre>
    </td>
  </tr>
  <tr> 
    <td align=left class="fullImgTableCapCell"> 
    <span class=figurenumber>Example 13. Scale-offset compression floating-point data</span><br />
          Illustrates the use of the scale-offset filter for writing 
          and reading floating-point data.</td>
  </tr>
</table>

<h4><em>Limitations</em></h4>

<p>For floating-point data handling, there are some algorithmic 
  limitations to the GRiB data packing mechanism:

<dl>
  <dd>
    <ol>
      <li>Both the E-scaling and D-scaling methods are lossy compression
      <li>For the D-scaling method, since data values have been rounded to 
        integer values (positive) before truncating to the minimum-bits, 
        their range is limited by the maximum value that can be represented 
        by the corresponding unsigned integer type (the same size as that of 
        the floating-point type)
    </ol>
  </dd>
</dl>

<h4><em>Suggestions</em></h4>

<p>The following are some suggestions for using the filter for 
floating-point data:

<dl>
  <dd>
    <ol>
      <li>It is better to convert the units of data so that the units are 
        within certain common range (for example, 1200m to 1.2km)
      <li>If data values to be compressed are very near to zero, it 
        is strongly recommended that the user sets the fill value away 
        from zero (for example, a large positive number); if the user 
        does 
        nothing, the HDF5 Library will set the fill value to zero, and 
        this may cause undesirable compression results
      <li>Users are not encouraged to use a very large decimal scale 
        factor (e.g. 100) for the D-scaling method; this can cause the 
        filter not to ignore the fill value when finding maximum and minimum 
        values, and they will get a much larger minimum-bits (poor 
        compression)
    </ol>
  </dd>
</dl>



  

<a name="Szip">
<h3>6.3. Using the Szip Filter</h3>
</a>

  <p>See The HDF Group website for 
  <a href="http://www.hdfgroup.org/doc_resource/SZIP/" target="Ext1">further 
  information</a> regarding the Szip filter.

<p>&nbsp;
<p>&nbsp;





<!-- HEADER RIGHT " " -->

</body>
</html>

  
