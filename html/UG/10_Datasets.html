<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>

<title>HDF5 User's Guide: Datasets</title>

<!--(Meta)==========================================================-->

<!--(Links)=========================================================-->

<!--( Begin styles definition )=====================================-->
<link href="ed_styles/NewUGelect.css" rel="stylesheet" type="text/css">
<!--( End styles definition )=======================================-->

</head> 

<body>

<!-- #BeginLibraryItem "/ed_libs/styles_UG.lbi" -->
<!--
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  * Copyright by The HDF Group.                                               *
  * Copyright by the Board of Trustees of the University of Illinois.         *
  * All rights reserved.                                                      *
  *                                                                           *
  * This file is part of HDF5.  The full HDF5 copyright notice, including     *
  * terms governing use, modification, and redistribution, is contained in    *
  * the files COPYING and Copyright.html.  COPYING can be found at the root   *
  * of the source code distribution tree; Copyright.html can be found at the  *
  * root level of an installed copy of the electronic HDF5 document set and   *
  * is linked from the top-level documents page.  It can also be found at     *
  * http://hdfgroup.org/HDF5/doc/Copyright.html.  If you do not have          *
  * access to either file, you may request a copy from help@hdfgroup.org.     *
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 -->
<!-- #EndLibraryItem --><!-- HEADER LEFT "HDF5 User's Guide" -->
<!-- HEADER RIGHT "HDF5 Datasets" -->

<!--( TOC )=========================================================-->
<!--<SCRIPT language="JavaScript">-->
<!--
document.writeln ('\
<table x-use-null-cells\
                align=right\
		width=240\
		cellspacing=0\
		class="tocTable">\
-->
<!-- Table Version 3 --><!-- \ -->
<!--
  <tr valign=top> \
    <td class="tocTableHeaderCell" colspan="2"> \
        <span class=TableHead>Chapter Contents</span></td>\
  </tr>\
  <tr valign=top> \
    <td class="tocTableContentCell2"> \
      <a href="#Intro">1.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#Intro">Introduction</a></td> \
  </tr>\
  <tr valign=top> \
    <td class="tocTableContentCell2"> \
      <a href="#FileFunctSums">2.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#FileFunctSums">Dataset (H5D) Function Summaries</a></td>\
  </tr>\
  <tr valign=top> \
    <td class="tocTableContentCell2"> \
      <a href="#PModel">3.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#PModel">Programming Model</a></td> \
  </tr>\
  <tr valign=top> \
    <td class="tocTableContentCell2"> \
      <a href="#DTransfer">4.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#DTransfer">Data Transfer</a></td>\
  </tr>\
  <tr valign=top> \
    <td class="tocTableContentCell2"> \
      <a href="#Allocation">5.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#Allocation">Allocation of Space</a></td>\
  </tr>\
  <tr valign=top> \
    <td class="tocTableContentCell"> \
      <a href="#UseFilters">6.</a></td>\
    <td class="tocTableContentCell4">\
	  <a href="#UseFilters">Specialized Filters</a>\
          <br>&nbsp;&nbsp;&nbsp;&nbsp;\
	  <a href="#N-Bit">N-bit</a>\
          <br>&nbsp;&nbsp;&nbsp;&nbsp;\
	  <a href="#ScaleOffset">Scale-offset</a></td>\
  </tr>\
  </td></tr>\
</table>\
')
-->
<!--</SCRIPT>-->
<!--(End TOC)=======================================================-->

<!-- editingComment
  <span class="editingComment">[ [ [
  ] ] ]</span>
-->

<!-- editingComment
-->

<div align="center">
<a name="TOP">
<h2>Chapter 5<br><font size="7">HDF5 Datasets</font></h2>
</a>
</div>

<!-- editingComment
  <span class="editingComment">[ [ [
  Original title.  Which is proper?
  <h2>10. Datasets I/O</h2>
  ] ] ]</span>
-->

<a name="Intro">
<h3>1. Introduction</h3>
</a>

  <p>An HDF5 dataset is an object composed of a collection of data elements, 
  or raw data, and metadata that stores a description of the data elements, 
  data layout, and all other information necessary to write, read, and interpret 
  the stored data. From the viewpoint of the application the raw data is stored 
  as a one-dimensional or multi-dimensional array of elements (the <em>raw data</em>), 
  those elements can be any of several numerical or character types, small arrays, 
  or even compound types similar to C structs. The dataset object may have attribute 
  objects.</p>
  
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig1.JPG">
    </td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
        <span class=figurenumber>Figure 1</span></td>
  </tr>
</table>

<!-- editingComment
  <span class="editingComment">
  <p>Datatypes are described in  [ [ [ "Datatypes" ] ] ]. and in the [ [ [ "HDF5 
  Datatypes" chapter in this guide ] ] ], Dataspace objects are described in 
  [ [ [ Dataspace ] ] ], and Attributes are described in [ [ [ Attributes ] ] ].
  </span>
-->

  <p>A dataset objects is stored in a file in two parts: a header and a data array. 
  The header contains information that is needed to interpret the array portion of 
  the dataset, as well as metadata (or pointers to metadata) that describes or 
  annotates the dataset. Header information includes the name of the object, its 
  dimensionality, its number-type, information about how the data itself is stored 
  on disk (the <em>storage layout</em>), and other information used by the library 
  to speed up access to the dataset or maintain the file's integrity. 

  <p>The HDF5 dataset interface, comprising the H5D functions, provides a mechanism 
  for managing HDF5 datasets, including the transfer of data between memory and 
  disk and the description of dataset properties. 

  <p>A dataset is used by other HDF5 APIs, either by name or by a handle (e.g., 
  returned by H5Dopen).

<!-- NEW PAGE -->
<h4><em>Link/Unlink</em></h4>

  <p>A dataset can be added to a group with the H5Glink call, and deleted from a 
  group with H5Gunlink. The link and unlink operations use the name of an object, 
  which may be a dataset. The dataset does not have to open to be linked or unlinked.

<h4><em>Object reference</em></h4>

  <p>A dataset may be the target of an object reference.  The object reference is 
  create by H5Rcreate, with the name of an object which may be a dataset and the 
  reference type H5R_OBJECT. The dataset does not have to be open to create a 
  reference to it.

  <p>An object reference may also refer to a region (selection) of a dataset. 
  The reference is created with H5Rcreate and a reference type of 
  H5R_DATASET_REGION.

  <p>An object reference can be accessed by a call to H5Rdereference. When the 
  reference is to a dataset or dataset region, the H5Rdeference call returns a 
  handle to the dataset, just as if H5open has been called.

<h4><em>Adding attributes</em></h4>

  <p>A dataset may have user defined attributes, which are created with H5Acreate, 
  and accessed through the H5A API. To create an attribute for a dataset, the 
  dataset must be open, and the handle is passed to H5Acreate. The attributes of 
  a dataset are discovered, and opened using H5Aopen_name, H5Aopen_idx, or H5Aiterate; 
  which use the handle of the dataset. An attribute can be deleted with H5Adelete, 
  which uses the handle of the dataset.

<!-- editingComment
  <span class="editingComment">
  <p>The remaining sections of this chapter discuss... [To be written last.]</p>
  </span>
-->

<br>

<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="FileFunctSums">
<div align=right>
<a href="#TOP"><font size=-1>(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<!-- NEW PAGE -->
<a name="FileFunctSums">
<h3 class=pagebefore>2. Dataset (H5D) Function Summaries</h3>
</a>

<br>

<table x-use-null-cells
		class="functTable"
		width=600
		cellspacing=0
	        align="center">
  <tr valign=top> 
    <td class="functTableLeftHdr">
        <span class=TableHead>C Function<br>F90 Function</span>
    </td>
    <td class="functTableRightHdr">
        <span class=TableHead>Purpose</span>
    </td>
  </tr>
  <tr valign=top> 
    <td colspan=1
	rowspan=1
	class="functTableCell">
	<code>H5Dcreate<br>h5dcreate_f</code> 
    </td>
    <td colspan=1
	rowspan=1
	class="functTableCell">
	Creates a dataset at the specified location.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dopen<br>h5dopen_f</code> 
    </td>
    <td class="functTableCell">
	Opens an existing dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dclose<br>h5dclose_f</code> 
    </td>
    <td class="functTableCell">
	Closes the specified dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dget_space<br>h5dget_space_f</code> 
    </td>
    <td class="functTableCell">
	Returns an identifier for a copy of the dataspace for a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dget_space_status<br>h5dget_space_status_f</code> 
    </td>
    <td class="functTableCell">
	Determines whether space has been allocated for a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dget_type<br>h5dget_type_f</code> 
    </td>
    <td class="functTableCell">
	Returns an identifier for a copy of the datatype for a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dget_create_plist<br>h5dget_create_plist_f</code> 
    </td>
    <td class="functTableCell">
	Returns an identifier for a copy of the dataset creation property list for a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dget_offset<br>h5dget_offset_f</code> 
    </td>
    <td class="functTableCell">
	Returns dataset address in file.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dget_storage_size<br>h5dget_storage_size_f</code> 
    </td>
    <td class="functTableCell">
	Returns the amount of storage required for a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dvlen_get_buf_size<br>h5dvlen_get_max_len_f</code> 
    </td>
    <td class="functTableCell">
	Determines the number of bytes required to store VL data.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dvlen_reclaim<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Reclaims VL datatype memory buffers.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dread<br>h5dread_f</code> 
    </td>
    <td class="functTableCell">
	Reads raw data from a dataset into a buffer.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dwrite<br>h5dwrite_f</code> 
    </td>
    <td class="functTableCell">
	Writes raw data from a buffer to a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Diterate<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Iterates over all selected elements in a dataspace.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Dextend<br>h5dextend_f</code> 
    </td>
    <td class="functTableCell">
	Extends dataset dimensions.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableBottom">
	<code>H5Dfill<br>h5dfill_f</code> 
    </td>
    <td class="functTableBottom">
	Fills dataspace elements with a fill value in a memory buffer.
    </td>
  </tr>
</table>

<br>
<!-- NEW PAGE -->
<h4>Dataset creation property list functions</h4>

<table x-use-null-cells 
		class="functTable"
		width=100%
		cellspacing=0
	        align="center">
  <tr valign=top> 
    <td class="functTableLeftHdr">
        <span class=TableHead>C Function<br>F90 Function</span>
    </td>
    <td class="functTableRightHdr">
        <span class=TableHead>Purpose</span>
    </td>
  </tr>
  <tr valign=top> 
    <td colspan=1
	rowspan=1
	class="functTableCell">
	<code>H5Pset_layout<br>h5pset_layout_f</code> 
    </td>
    <td colspan=1
	rowspan=1
	class="functTableCell">
	Sets the type of storage used to store the raw data for a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_layout<br>h5pget_layout_f</code> 
    </td>
    <td class="functTableCell">
	Returns the layout of the raw data for a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_chunk<br>h5pset_chunk_f</code> 
    </td>
    <td class="functTableCell">
	Sets the size of the chunks used to store a chunked layout dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_chunk<br>h5pget_chunk_f</code> 
    </td>
    <td class="functTableCell">
	Retrieves the size of chunks for the raw data of a chunked layout dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_deflate<br>h5pset_deflate_f</code> 
    </td>
    <td class="functTableCell">
	Sets compression method and compression level.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_fill_value<br>h5pset_fill_value_f</code> 
    </td>
    <td class="functTableCell">
	Sets the fill value for a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_fill_value<br>h5pget_fill_value_f</code> 
    </td>
    <td class="functTableCell">
	Retrieves a dataset fill value.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pfill_value_defined<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Determines whether fill value is defined.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_fill_time<br>h5pset_fill_time_f</code> 
    </td>
    <td class="functTableCell">
	Sets the time when fill values are written to a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_fill_time<br>h5pget_fill_time_f</code> 
    </td>
    <td class="functTableCell">
	Retrieves the time when fill value are written to a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_alloc_time<br>h5pset_alloc_time_f</code> 
    </td>
    <td class="functTableCell">
	Sets the timing for storage space allocation.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_alloc_time<br>h5pget_alloc_time_f</code> 
    </td>
    <td class="functTableCell">
	Retrieves the timing for storage space allocation.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_filter<br>h5pset_filter_f</code> 
    </td>
    <td class="functTableCell">
	Adds a filter to the filter pipeline.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pall_filters_avail<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Verifies that all required filters are available.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_nfilters<br>h5pget_nfilters_f</code> 
    </td>
    <td class="functTableCell">
	Returns the number of filters in the pipeline.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_filter<br>h5pget_filter_f</code> 
    </td>
    <td class="functTableCell">
	Returns information about a filter in a pipeline.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_filter_by_id<br>h5pget_filter_by_id_f</code> 
    </td>
    <td class="functTableCell">
	Returns information about the specified filter.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pmodify_filter<br>h5pmodify_filter_f</code> 
    </td>
    <td class="functTableCell">
	Modifies a filter in the filter pipeline.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Premove_filter<br>h5premove_filter_f</code> 
    </td>
    <td class="functTableCell">
	Delete one or more filters in the filter pipeline.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_fletcher32<br>h5pset_fletcher32_f</code> 
    </td>
    <td class="functTableCell">
	Sets up use of the Fletcher32 checksum filter.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_nbit<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Sets up use of the n-bit filter.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_scaleoffset<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Sets up use of the scale-offset filter.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_shuffle<br>h5pset_shuffle_f</code> 
    </td>
    <td class="functTableCell">
	Sets up use of the shuffle filter.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_szip<br>h5pset_szip_f</code> 
    </td>
    <td class="functTableCell">
	Sets up use of the Szip compression filter.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_external<br>h5pset_external_f</code> 
    </td>
    <td class="functTableCell">
	Adds an external file to the list of external files.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_external_count<br>h5pget_external_count_f</code> 
    </td>
    <td class="functTableCell">
	Returns the number of external files for a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableBottom">
	<code>H5Pget_external<br>h5pget_external_f</code> 
    </td>
    <td class="functTableBottom">
	Returns information about an external file.
    </td>
  </tr>
</table>

<br>
<h4>Dataset access property list functions</h4>
<table x-use-null-cells 
		class="functTable"
		width=100%
		cellspacing=0
	        align="center">
  <tr valign=top> 
    <td class="functTableLeftHdr">
        <span class=TableHead>C Function<br>F90 Function</span>
    </td>
    <td class="functTableRightHdr">
        <span class=TableHead>Purpose</span>
    </td>
  </tr>
  <tr valign=top> 
    <td colspan=1
	rowspan=1
	class="functTableCell">
	<code>H5Pset_buffer<br>h5pset_buffer_f</code> 
    </td>
    <td colspan=1
	rowspan=1
	class="functTableCell">
	Sets type conversion and background buffers.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_buffer<br>h5pget_buffer_f</code> 
    </td>
    <td class="functTableCell">
	Reads buffer settings.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_preserve<br>h5pset_preserve_f</code> 
    </td>
    <td class="functTableCell">
	Sets the dataset transfer property list status to TRUE or FALSE.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_preserve<br>h5pget_preserve_f</code> 
    </td>
    <td class="functTableCell">
	Checks status of the dataset transfer property list.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_edc_check<br>h5pset_edc_check_f</code> 
    </td>
    <td class="functTableCell">
	Sets whether to enable error-detection when reading a dataset.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_edc_check<br>h5pget_edc_check_f</code> 
    </td>
    <td class="functTableCell">
	Determines whether error-detection is enabled for dataset reads.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_filter_callback<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Sets user-defined filter callback function.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_data_transform<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Sets a data transform expression.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_data_transform<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Retrieves a data transform expression.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_type_conv_cb<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Sets user-defined data type conversion callback function.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_type_conv_cb<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Gets user-defined data type conversion callback function.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_hyper_vector_size<br>h5pset_hyper_vector_size_f</code> 
    </td>
    <td class="functTableCell">
	Sets number of I/O vectors to be read/written in hyperslab I/O.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_hyper_vector_size<br>h5pget_hyper_vector_size_f</code> 
    </td>
    <td class="functTableCell">
	Retrieves number of I/O vectors to be read/written in hyperslab I/O.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_btree_ratios<br>h5pset_btree_ratios_f</code> 
    </td>
    <td class="functTableCell">
	Sets B-tree split ratios for a dataset transfer property list.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_btree_ratios<br>h5pget_btree_ratios_f</code> 
    </td>
    <td class="functTableCell">
	Gets B-tree split ratios for a dataset transfer property list.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_vlen_mem_manager<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Sets the memory manager for variable-length datatype allocation in 
	<code>H5Dread</code> and <code>H5Dvlen_reclaim</code>.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_vlen_mem_manager<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Gets the memory manager for variable-length datatype allocation in 
	<code>H5Dread</code> and <code>H5Dvlen_reclaim</code>.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_dxpl_mpio<br>h5pset_dxpl_mpio_f</code> 
    </td>
    <td class="functTableCell">
	Sets data transfer mode.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_dxpl_mpio<br>h5pget_dxpl_mpio_f</code> 
    </td>
    <td class="functTableCell">
	Returns the data transfer mode.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_dxpl_multi<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Sets the data transfer property list for the multi-file driver.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_dxpl_multi<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Returns multi-file data transfer property list information.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_multi_type<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Sets type of data property for MULTI driver.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pget_multi_type<br>(none)</code> 
    </td>
    <td class="functTableCell">
	Retrieves type of data property for MULTI driver.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableCell">
	<code>H5Pset_small_data_block_size<br>h5pset_small_data_block_size_f</code> 
    </td>
    <td class="functTableCell">
	Sets the size of a contiguous block reserved for small data.
    </td>
  </tr>
  <tr valign=top> 
    <td class="functTableBottom">
	<code>H5Pget_small_data_block_size<br>h5pget_small_data_block_size_f</code> 
    </td>
    <td class="functTableBottom">
	Retrieves the current small data block size setting.
    </td>
  </tr>
</table>

<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="PModel">
<div align=right>
<a href="#TOP"><font size=-1>(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<!-- NEW PAGE -->
<a name="PModel">
<h3 class=pagebefore>3. Programming Model</h3>
</a>

  <p>This section explains the programming model for a datasets.

<h4>3.1 General Model</h4>

  <p>The programming model for using a dataset has three main phases:
  
  <p>obtain access to the dataset operate on the dataset using the dataset handle 
  returned above release the dataset. A dataset may be opened several times, and 
  operations performed with several different handles to the same dataset. All the 
  operations affect the dataset, although the calling program must synchronize if 
  necessary to serialize accesses.

  <p>Note that the dataset remains open until the last handle is closed. 
  Figure 2 shows the basic sequence of operations.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig2.JPG">
    </td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
        <span class=figurenumber>Figure 2</span></td>
  </tr>
</table>

  <p>Creation and data access operations may have optional parameters which are set 
  with property lists.  The general programming model is:

  <ol>
      <li>create property list of appropriate class (dataset create, 
          dataset transfer)
      <li>set properties as needed.  Each type of property has its own 
          format and datatype.
      <li>pass the property list as a parameter of the API call.
  </ol>


<h4><em>Step 1. Obtain Access</em></h4>

  <p>A new dataset is created by a call to H5Dcreate. If successful, the call 
  returns a handle for the newly created dataset.

  <p>Access to an existing dataset is obtained by a call to H5Dopen. This call 
  returns a handle for the existing dataset.

  <p>An object reference 
<!-- editingComment
  <span class="editingComment">[ [ [
  (Chapter ???) 
  ] ] ]</span>
-->
  may be dereferenced to obtain a handle to 
  the dataset it points to.
  
  <p>In each of these cases, the successful call returns a handle to the dataset. 
  The handle is used in subsequent operations until it is closed.

<h4><em>Step 2. Operate on the Dataset</em></h4>

  <p>The dataset handle can be used to write and read data to the dataset, to query 
  and set properties, and to perform other operations such as adding attributes, 
  linking in groups, creating references, and so on.

  <p>The dataset handle can be used for any number of 
  operations until it is closed.

<h4><em>Step 3. Close the Dataset</em></h4>

  <p>When all operations are completed, the dataset handle should be closed. 
  This releases the dataset. 
<!-- editingComment
  <span class="editingComment">[ [ [
  { and writes all metadata to the file? }
  ] ] ]</span>
-->

  <p>After the handle is closed, it cannot be used for further operations.

<h4>3.2 Create Dataset</h4>

  <p>A dataset is created and initialized with a call to H5Dcreate. The dataset 
  create operation sets permanent properties of the dataset:</p>

  <ul>
      <li>name
      <li>dataspace
      <li>datatype
      <li>storage properties
  </ul>

  <p>These properties cannot be changed for the life of the dataset, although the 
  dataspace may be expanded up to its maximum dimensions.

<h4><em>Name</em></h4>

  <p>A dataset name is a sequence of alphanumeric ASCII characters. The full name 
  would include a tracing of the group hierarchy from the root group of the file, 
  e.g., /rootGroup/groupA/subgroup23/dataset1. The local name or relative name 
  within the lowest-level group containing the dataset would include none of the 
  group hierarchy. e.g., Dataset1. 
<!-- editingComment
  <span class="editingComment">[ [ [
  [[See ??]]
  ] ] ]</span>
-->

<!-- NEW PAGE -->
<h4><em>Dataspace</em></h4>

  <p>The dataspace of a dataset defines the number of dimensions and the size of 
  each dimension. 
<!-- editingComment
  <span class="editingComment">[ [ [
  [[Dataspace]]. 
  ] ] ]</span>
-->
  The dataspace defines the number of dimensions, 
  and the maximum dimension sizes and current size of each dimension. 
  The maximum dimension size can be a fixed value or the constant 
  <code>H5D_UNLIMITED</code>, in which case the actual dimension size 
  can be incremented with calls to <code>H5Dextend</code>, up to the 
  maximum set with the <code>maxdims</code> parameter in the 
  <a href="../RM/RM_H5S.html#Dataspace-CreateSimple" target=RMwindow>
  <code>H5Screate_simple</code></a> call that established the 
  dataset&rsquo;s original dimensions. The maximum dimension size is set 
  when the dataset is created and cannot be changed.

<h4><em>Datatype</em></h4>

  <p>Raw data has a datatype, which describes the layout of the raw data stored in 
  the file. 
<!-- editingComment
  <span class="editingComment">[ [ [
  (See [[Datatype]]. 
  ] ] ]</span>
-->
  The file datatype is set when the dataset is created 
  and can never be changed. When data is transferred to and from the dataset, 
  the HDF5 Library will assure that the data is transformed to and 
  from the stored format.

<h4><em>Storage Properties</em></h4>

  <p>Storage properties of the dataset are set when it is created. Table 1 shows the 
  categories of storage properties. The storage properties cannot be changed after 
  the dataset is created. The storage properties are described 
  below. 
<!-- editingComment
  <span class="editingComment">[ [ [
  in [[storage properties]]
  ] ] ]</span>
-->

<h4><em>Filters</em></h4>

  <p>When a dataset is created, optional filters are specified. The filters are 
  added to the data transfer pipeline when data is read or written. The standard 
  library includes filters to implement compression, data shuffling, and error 
  detection code.  Additional user defined filters may also be used. 
<!-- editingComment
  <span class="editingComment">[ [ [
  See [[[filter]]].
  ] ] ]</span>
-->

  <p>The required filters are stored as part of the dataset, and the list may 
  not be changed after the dataset is created. The HDF5 Library automatically 
  applies the filters whenever data is transferred.

<h4><em>Summary</em></h4>

  <p>A newly created dataset has no attributes and no data values. The dimensions, 
  data type (in the file), storage properties, and selected filters are set. 
  Table 1 lists the required inputs, Table 2 lists the optional inputs.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="center" valign="bottom"><h4>Table 1</h4></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Required inputs</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Dataspace</td>
    <td class="ColumnRightCell"> <p>The shape of the array</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Datatype</td>
    <td class="ColumnRightCell"> <p>The layout of the stored elements</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>name</td>
    <td class="ColumnRightBottom"> <p>The name of the dataset in the group</td>
  </tr>
</table>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="center" valign="bottom"><h4>Table 2</h4></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Optional Setting</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Storage Layout</td>
    <td class="ColumnRightCell"> 
        <p>How the data is organized in the file, including chunking.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Fill value</td>
    <td class="ColumnRightCell"> 
        <p>The behavior and value for uninitialized data.</td>
  </tr>
    <tr valign=top> 
    <td class="ColumnLeftCell"> <p>External Storage (optional)</td>
    <td class="ColumnRightCell"> 
        <p>Option to store the raw data in an external file.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Folders</td>
    <td class="ColumnRightBottom"> 
        <p>Select optional filters to be applied, e.g., compression.</td>
  </tr>
</table>

<!-- NEW PAGE -->
<h4><em>Example</em></h4>

  <p>To create a new dataset</p>

<dir>
  Set dataset characteristics. (Optional where default settings are acceptable)
<br> 
<dir>               
  Datatype
<br> 
  Dataspace
<br> 
  Dataset creation property list
</dir> 
  Create the dataset.
<br> 
  Close the datatype, dataspace, and property list. (As necessary)
<br> 
  Close the dataset.
</dir>

  <p>Figure 3 shows example code to create an empty dataset. The dataspace is 7 X 8, 
  the datatype is a big endian integer. The dataset is created with the name "dset1", 
  it is a member of the root group, "/".</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
    <pre><code>
    hid_t    dataset, datatype, dataspace;   

     /* 
      * Create dataspace: Describe the size of the array and 
      * create the data space for fixed-size dataset. 
     */
     dimsf[0] = 7;
     dimsf[1] = 8;
     dataspace = H5Screate_simple(2, dimsf, NULL); 
     /*
      * Define datatype for the data in the file.
      * For this example, store little-endian integer numbers.
      */
     datatype = H5Tcopy(H5T_NATIVE_INT);
     status = H5Tset_order(datatype, H5T_ORDER_LE);
     /*
      * Create a new dataset within the file using defined 
      * dataspace and datatype. No properties are set.
      */
     dataset = H5Dcreate(file, "/dset", datatype, dataspace, H5P_DEFAULT);

     H5Dclose(dataset);
     H5Sclose(dataspace);
     H5Tclose(datatype);
    </code></pre></td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 3</span></td>
  </tr>
</table>

<!-- NEW PAGE -->
  <p>Figure 4 shows example code to create a similar dataset with a fill value of '-1'. 
  This code has the same steps as in Figure 3, but uses a non-default property list. 
  A file creation property list is created, and then the fill value is set to the 
  desired value. Then the property list is passed to the H5Dcreate call.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
    <pre><code>
    hid_t    dataset, datatype, dataspace;
     hid_t plist;  /* property list */
     int fillval = -1;
     dimsf[0] = 7;
     dimsf[1] = 8;
     dataspace = H5Screate_simple(2, dimsf, NULL); 
     
     datatype = H5Tcopy(H5T_NATIVE_INT);
     status = H5Tset_order(datatype, H5T_ORDER_LE);

     /*
      * Example of Dataset Creation property list: set fill value to '-1'
      */
     plist = H5Pcreate((H5P_DATASET_CREATE);
     status = H5Pset_fill_value(plist,datatype, &fillval);

    /* Same as above, but use the property list */
     dataset = H5Dcreate(file, "/dset", datatype, dataspace, plist);

     H5Dclose(dataset);
     H5Sclose(dataspace);
     H5Tclose(datatype);
     H5Pclose(plist);
    </code></pre></td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 4</span></td>
  </tr>
</table>

  <p>After this code is executed, the dataset has been created and written to the file. 
  The data array is uninitialized.  Depending on the storage strategy and fill value 
  options that have been selected, some or all of the space may be allocated in the 
  file, and fill values may be written in the file.  
<!-- editingComment
  <span class="editingComment">[ [ [
  See &lt;&lt;below&gt;&gt;.
  ] ] ]</span>
-->

<h4>3.3 Data Transfer Operations on a Dataset</h4>

  <p>Data is transferred between from memory and the raw data array of the dataset 
  through H5Dwrite and H5Dread operations. A data transfer has the 
  following basic steps:</p>
  
  <ol>
      <li>allocate and initialize memory space as needed
      <li>define the datatype of the memory elements
      <li>define the elements to be transferred (a selection, or all the elements)
      <li>set data transfer properties (including parameters for filters or 
          file drivers) as needed
      <li>call the H5D API
  </ol>

  <p>Note that the location of the data in the file, the datatype of the data in 
  the file, the storage properties, and the filters do not need to be specified, 
  because these are stored as a permanent part of the dataset. A selection of 
  elements from the dataspace is specified, which may be the whole dataspace.

<!-- NEW PAGE -->
  <p>Figure 5 shows a diagram of a write operation, which transfers a data array from 
  memory to a dataset in the file (usually on disk). A read operation has similar 
  parameters, with the data flowing the other direction.</p>
  
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig5.JPG" width="670">
    </td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
        <span class=figurenumber>Figure 5</span></td>
  </tr>
</table>

<h4><em>Memory Space</em></h4>

  <p>The calling program must allocate sufficient memory to store the data elements 
  to be transferred. For a write (from memory to the file), the memory must be 
  initialized with the data to be written to the file.  For a read, the memory must 
  be large enough to store the elements that will be read. The amount of storage 
  needed can be computed from the memory datatype (which defines the size of each 
  data element) and the number of elements in the selection.

<!-- NEW PAGE -->
<h4><em>Memory Datatype</em></h4>

  <p>The memory layout of a single data element is specified by the memory datatype. 
  This specifies the size, alignment, and byte order of the element, as well as the 
  datatype class. Note that the memory data type must be the same datatype class 
  as the file, but may have different byte order and other properties.  The HDF5 
  Library automatically transforms data elements between the source and destination 
  layouts. See the chapter "<a href="11_Datatypes.html">HDF5 Datatypes</a>" 
  for more details.

  <p>For a write, the memory datatype defines the layout of the data to be written, 
  e.g., IEEE floating point numbers in native byte order. If the file datatype (defined 
  when the dataset is created) is different but compatible, the HDF5 Library will 
  transform each data element when it is written. For example, if the file byte 
  order is different than the native byte order, the HDF5 Library 
  will swap the bytes.

  <p>For a read, the memory datatype defines the desired layout of the data to be read. 
  This must be compatible with the file datatype, but should generally use native 
  formats, e.g., byte orders. The HDF5 Library will transform each data 
  element as it is read.

<h4><em>Selection</em></h4>

  <p>The data transfer will transfer some or all of the elements of the dataset, 
  depending on the dataspace selection. The selection is two dataspace objects 
  (one for the source, and one for the destination) which describe which elements 
  of the dataspace to be transferred, which may be all of the data, or just some 
  elements (partial I/O). Partial I/O is defined by defining hyperslabs or lists 
  of elements in a dataspace object.

  <p>The dataspace selection for the source defines the indices of the elements 
  to be read, the dataspace selection for the destination defines the indices of 
  the elements to be written. The two selections must define the same number of 
  points, but the order and layout may be different.  The HDF5 Library 
  automatically selects and distributes the elements, according to the selections, 
  e.g., to perform a scatter-gather or sub-set of the data. 
<!-- editingComment
  <span class="editingComment">[ [ [
  See [[Selections]].
  ] ] ]</span>
-->

<h4><em>Data Transfer Properties</em></h4>

  <p>For some data transfers, additional parameters should be set using the 
  transfer property list. Table 2 lists the categories of transfer properties. 
  These properties set parameters for the HDF5 Library, and may be used to 
  pass parameters for optional filters and file drivers. For example, transfer 
  properties are used to select independent or collective 
  operation when using MPI-I/O.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="center" valign="bottom"><h4>Table 3</h4></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Properties</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Library parameters</td>
    <td class="ColumnRightCell"> <p>Internal caches, buffers, B-Trees, etc.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Memory management</td>
    <td class="ColumnRightCell"> 
        <p>Variable length memory management, data overwrite</td>
  </tr>
    <tr valign=top> 
    <td class="ColumnLeftCell"> <p>File driver management</td>
    <td class="ColumnRightCell"> <p>Parameters for file drivers</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Filter management</td>
    <td class="ColumnRightBottom"> <p>Parameters for filters</td>
  </tr>
</table>

<h4><em>Data Transfer Operation (read or write)</em></h4>

  <p>The data transfer is done by calling H5Dread or H5Dwrite with the parameters 
  described above. The HDF5 Library constructs the required pipe-line, 
  which will scatter-gather, transform data types, apply the requested filters, 
  and use the correct file driver.

  <p>During the data transfer, the transformations and filters are applied to 
  each element of the data, in the required order, until all the 
  data is transferred.

<!-- editingComment
  <span class="editingComment">[ [ [
  <p>[[See Data Transfer Below]]
  ] ] ]</span>
-->

<h4><em>Summary</em></h4>

  <p>To perform a data transfer, it is necessary to allocate and initialize memory, 
  describe the source and destination, set required and optional transfer properties, 
  and call the H5D API. 

<h4><em>Examples</em></h4>

  <p>The basic procedure to write to a dataset</p>

<dir>
  Open the dataset.<br> 
  Set dataset dataspace of write. (Optional if dataspace is H5S_SELECT_ALL) <br>
  Write data.<br> 
  Close the datatype, dataspace, and property list. (As necessary)<br> 
  Close the dataset.
</dir> 

  <p>Figure 6 shows example code to write a 4 X 6 array of integers.  In the example, 
  the data is initialized in the memory array dset_data.  The dataset has already 
  been created in the file, so it is opened with H5Dopen.

  <p>The data is written with H5Dwrite. The arguments are the dataset handle, the memory 
  datatype (H5T_NATIVE_INT), the memory and file selections (H5S_ALL in this case: 
  the whole array), and the default (empty) property list. The last argument is 
  the data to be transferred.</p>
  
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
    <pre><code>
   hid_t       file_id, dataset_id;  /* identifiers */
   herr_t      status;
   int         i, j, dset_data[4][6];

   /* Initialize the dataset. */
   for (i = 0; i < 4; i++)
      for (j = 0; j < 6; j++)
         dset_data[i][j] = i * 6 + j + 1;

   /* Open an existing file. */
   file_id = H5Fopen("dset.h5", H5F_ACC_RDWR, H5P_DEFAULT);

   /* Open an existing dataset. */
   dataset_id = H5Dopen(file_id, "/dset");

   /* Write the entire dataset, using 'dset_data': 
         memory type is 'native int'
         write the entire dataspace to the entire dataspace,
         no transfer properties,
    */
   status = H5Dwrite(dataset_id, H5T_NATIVE_INT, H5S_ALL, 
           H5S_ALL, H5P_DEFAULT, dset_data);


   status = H5Dclose(dataset_id);
    </code></pre></td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 6</span></td>
  </tr>
</table>

<!-- NEW PAGE -->
  <p>Figure 7 shows a similar write, setting a non-default value for the transfer buffer. 
<!-- editingComment
  <span class="editingComment">[ [ [
  &lt;&lt;explain what this does&gt;&gt;.  
  ] ] ]</span>
-->
  The code is the same as Figure 6, but a transfer 
  property list is created and the desired buffer size is set. The H5Dwrite has the 
  same arguments, but uses the property list to set the buffer.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
    <pre><code>
   hid_t       file_id, dataset_id;  
   hid_t  xferplist;
   herr_t      status;
   int         i, j, dset_data[4][6];

   file_id = H5Fopen("dset.h5", H5F_ACC_RDWR, H5P_DEFAULT);

   dataset_id = H5Dopen(file_id, "/dset");

   /*
     * Example: set type conversion buffer to 64MB
     */
    xferplist = H5Pcreate(H5P_DTASET_XFER);
    status = H5Pset_buffer( xferplist, 64 * 1024 *1024, NULL, NULL);

   /* Write the entire dataset, using 'dset_data': 
         memory type is 'native int'
         write the entire dataspace to the entire dataspace,
         set the buffer size with the property list,
    */
   status = H5Dwrite(dataset_id, H5T_NATIVE_INT, H5S_ALL, 
           H5S_ALL, plist, dset_data);


   status = H5Dclose(dataset_id);
    </code></pre></td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 7</span></td>
  </tr>
</table>

<!-- editingComment
  <span class="editingComment">[ [ [
  <p>Partial writes (i.e., of selected data elements, such as a hyperslab) 
  are explained below [[partial I/O]]
  ] ] ]</span>
-->

  <p>To read from a dataset</p>

<dir>
  Define memory dataspace of read. (Optional if dataspace is H5S_SELECT_ALL)<br> 
  Open the dataset.<br> 
  Get the dataset dataspace. (If using H5S_SELECT_ALL above)<br> 

<dir>Else define dataset dataspace of read.</dir> 
  Define the memory datatype. (Optional)<br> 
  Define the memory buffer.<br> 
  Open the dataset.<br> 
  Read data.<br> 
  Close the datatype, dataspace, and property list. (As necessary)<br> 
  Close the dataset.
</dir>
  
<!-- NEW PAGE -->
  <p>Figure 8 shows example code that reads a 4 X 6 array of integers from a dataset 
  called "dset1". First, the dataset is opened. 
  The H5Dread call has parameters:</p>
  
  <ul>
      <li>the dataset handle (from H5Dopen)
      <li>The memory datatype (H5T_NATVE_INT)
      <li>The memory and file dataspace (H5S_ALL, the whole array)
      <li>A default (empty) property list
      <li>The memory to be filled.
  </ul>
  
<br>  
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
    <pre><code>
   hid_t       file_id, dataset_id;  
   herr_t      status;
   int         i, j, dset_data[4][6];


   /* Open an existing file. */
   file_id = H5Fopen("dset.h5", H5F_ACC_RDWR, H5P_DEFAULT);

   /* Open an existing dataset. */
   dataset_id = H5Dopen(file_id, "/dset");

   /* read the entire dataset, into 'dset_data': 
         memory type is 'native int'
         read the entire dataspace to the entire dataspace,
         no transfer properties,
    */
   status = H5Dread(dataset_id, H5T_NATIVE_INT, H5S_ALL, 
           H5S_ALL, H5P_DEFAULT, dset_data);

   status = H5Dclose(dataset_id);
    </code></pre></td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 8</span></td>
  </tr>
</table>

<h4>3.4 Retrieve properties of a Dataset</h4>

  <p>
  The functions in the table below allow the user to retrieve 
  information regarding a dataset, including the datatype, 
  the dataspace, the dataset creation property list, 
  and the total stored size of the data.
  
  <p>
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Query Function</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5Dget_space</td>
    <td class="ColumnRightCell"> <p>Retrieve the dataspace of the dataset 
         as stored in the file.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5Dget_type</td>
    <td class="ColumnRightCell"> <p>Retrieve the datatype of the dataset 
         as stored in the file.</td>
  </tr>
    <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5Dget_create_plist</td>
    <td class="ColumnRightCell"> <p>Retrieve the 
        dataset creation properties.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5Dget_storage_size</td>
    <td class="ColumnRightCell"> 
        <p>Retrieve the total bytes for all the data of the dataset.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>H5Dvlen_get_buf_size</td>
    <td class="ColumnRightBottom"> 
        <p>Retrieve the total bytes for all the variable length 
	data of the dataset.</td>
  </tr>
</table>

<!-- NEW PAGE -->
<h4><em>Example</em></h4>

<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell"> 
    <pre><code>
   hid_t       file_id, dataset_id;
   hid_t    dspace_id, dtype_id, plist_id; 
   herr_t      status;

   /* Open an existing file. */
   file_id = H5Fopen("dset.h5", H5F_ACC_RDWR, H5P_DEFAULT);

   /* Open an existing dataset. */
   dataset_id = H5Dopen(file_id, "/dset");

   dspace_id = H5Dget_space(dataset_id);
   dtype_id = H5Dget_type(dataset_id);
   plist_id = H5Dget_create_plist(dataset_id);

   /* use the objects to discover the properties of the dataset */

   status = H5Dclose(dataset_id);
    </code></pre>
    </td>
  </tr>
</table>

<h4>3.5 Other Operations</h4>

  <p>The dataset is used for other miscellaneous operations.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="center" valign="bottom"><h4>Table 4</h4></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr" width="50%"> 
        <p><span class=TableHead>Operation</span></td>
    <td class="ColumnRightHdr" width="50%"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5Dextend</td>
    <td class="ColumnRightCell"> <p>See below</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5Diterate</td>
    <td class="ColumnRightCell"> <p>&nbsp;</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>H5Dvlen_reclaim</td>
    <td class="ColumnRightBottom"> <p>See below</td>
  </tr>
</table>
<br>

<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="DTransfer">
<div align=right>
<a href="#TOP"><font size=-1>(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<!-- NEW PAGE -->
<a name="DTransfer">
<h3 class=pagebefore>4. Data Transfer: Raw Data I/O</h3>
</a>

  <p>The HDF5 Library implements data transfers through a pipeline which implements 
  data transformations (according to the datatype and selections), chunking (as 
  requested), and I/O operations using different mechanisms (file drivers). 
  The pipeline is automatically configured by the HDF5 Library. Metadata is 
  stored in the file so that the correct pipeline can be constructed to retrieve 
  the data. In addition, optional filters, such as compression, may be 
  added to the standard pipeline. 

  <p>Figure 9 illustrates data layouts for different layers of an application using HDF5. 
  The application data is organized as a multidimensional array of elements. 
  The HDF5 format specification
<!-- editingComment
  <span class="editingComment">[ [ [
   [[cite it]] 
  ] ] ]</span>
-->
  defines the stored layout of the data 
  and metadata.  The storage layout properties define the organization of the 
  abstract data. This data is written and read to and from some storage medium.</p>
  
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig9.JPG" width="700">
    </td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
        <span class=figurenumber>Figure 9</span></td>
  </tr>
</table>

<!-- NEW PAGE -->
  <p>The last stage of a write (and first stage of a read) is managed by an HDF5 
  file driver module.  The virtual file layer of the HDF5 Library implements a 
  standard interface to alternative I/O methods, including memory (AKA "core") files, 
  single serial file I/O, multiple file I/O, and parallel I/O. The file driver maps 
  a simple abstract HDF5 file to the specific access methods.

  <p>The raw data of an HDF5 dataset is conceived to be a multi-dimensional array of 
  data elements. This array may be stored in the file according to 
  several storage strategies:</p> 

  <ul>
      <li>COMPACT
      <li>CONTIGUOUS
      <li>CHUNKED
  </ul>

  <p>The storage strategy does not affect data access methods, except that certain 
  operations may be more or less efficient depending on the storage strategy 
  and the access patterns.

  <p>Overall, the data transfer operations (H5Dread and H5Dwrite) work identically 
  for any storage method, for any file driver, and for any filters and transformations. 
  The HDF5 Library automatically manages the data transfer process. In some cases, 
  transfer properties should or must be used to pass additional parameters, such as 
  MPI/IO directives when used the parallel file driver.

<h4>4.1 Data pipeline</h4>

  <p>When data is written or read to or from and HDF5 file, the HDF5 Library passes 
  the data through a sequence of processing steps, the HDF5 data pipeline. This data 
  pipeline performs operations on the data in memory, including byte swapping, alignment, 
  scatter-gather, and hyperslab selections. The HDF5 Library automatically determines 
  which operations are needed and manages the organization of memory operations, 
  such as extracting selected elements from a data block. The data pipeline modules 
  operate on data buffers, each processes the buffer and passes the 
  transformed buffer to the next stage.

  <p>Table 5 lists the stages of the data pipeline Figure 10 shows the order of processing 
  during a read or write.</p>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="center" valign="bottom"><h4>Table 5</h4></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Layers</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>I/O initiation</td>
    <td class="ColumnRightCell"> 
        <p>Initiation of HDF5 I/O activities in user's application program, 
	i.e. H5Dwrite and H5Dread.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Memory hyperslab operation</td>
    <td class="ColumnRightCell"> 
        <p>Data is scattered to (for read), or gathered from (for write) application's 
	memory buffer (bypassed if no datatype conversion is needed).</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Datatype conversion</td>
    <td class="ColumnRightCell"> 
        <p>Datatype is converted if it is different between memory and storage 
	(bypassed if no datatype conversion is needed).</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>File hyperslab operation</td>
    <td class="ColumnRightCell"> 
        <p>Data is gathered from (for read), or scattered to (for write) to 
	file space in memory (bypassed if no datatype conversion is needed).</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Filter pipeline</td>
    <td class="ColumnRightCell"> 
        <p>Data is processed by filters when it passes.  Data can be modified and 
	restored here (bypassed if no datatype conversion is needed, no filter is 
	enabled, or dataset is not chunked).</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Virtual File Layer</td>
    <td class="ColumnRightCell"> 
        <p>Facilitate easy plug-in file drivers, like MPIO, POSIX I/O.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Actual I/O</td>
    <td class="ColumnRightBottom"> 
        <p>Actual file driver used by the library, like MPIO or STDIO.</td>
  </tr>
</table>

<br>

<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig10.JPG"><br>
    </td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
        <span class=figurenumber>Figure 10</span></td>
  </tr>
</table>

  <br>
  <p>The HDF5 Library automatically applies the stages as needed.  

  <p>When the memory dataspace selection is other than the whole dataspace, the memory 
  hyperslab stage scatters/gathers the data elements between the appliation 
  memory (described by the selection) and contiguous memory buffer for the pipeline. 
  On a write, this is a gather operation, on a read, this is a scatter operation.

  <p>When the memory datatype is different from the file datatype, the datatype 
  conversion stage transforms each data element. For example, if data is written 
  from 32-bit big endian memory, and the file datatype is 32-bit little endian, 
  the datatype conversion stage will swap the bytes of every elements.  Similarly, 
  when data is read from the file to native memory, byte swapping will be 
  applied automatically when needed.

  <p>The file hyperslab stage is similar to the memory hyperslab stage, 
  but is managing the arrangement of the elements according to the file 
  dataspace selection. When data is read, data elements are gathered from 
  the data blocks from the file to fill the contiguous buffers, which are 
  processed by the pipeline. When data is read, the elements from a buffer 
  are scattered to the data blocks of the file.

<h4>4.2 Filters</h4>

  <p>In addition to the standard pipeline, optional stages, called filters, 
  can be inserted in the pipeline. 
<!-- editingComment
  <span class="editingComment">[ [ [
  see [[chunked]]) 
  ] ] ]</span>
-->
  The standard distribution includes optional filters to 
  implement compression and error checking. User applications may 
  add custom filters as well.

  <p>The HDF5 Library distribution includes or employs 
  several optional filters, as listed in Table 6. 
  The filters are applied in the pipeline between the virtual file layer and 
  the file hyperslab operation (Figure 10). The application can use any 
  number of filters, in any order.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="center" valign="bottom"><h4>Table 6</h4></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Filter</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>gzip compression</td>
    <td class="ColumnRightCell"> <p>Data compression using 
      <code>zlib</code>.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Szip&nbsp;compression&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
    <td class="ColumnRightCell"> <p>Data compression using the 
      Szip library.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>N-bit compression</td>
    <td class="ColumnRightCell"> <p>Data compression using an algorithm 
      specialized for n-bit datatypes.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Scale-offset compression</td>
    <td class="ColumnRightCell"> <p>Data compression using using a 
      &ldquo;scale and offset&rdquo; algorithm.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Shuffling</td>
    <td class="ColumnRightCell"> 
        <p>To improve compression performance, data is regrouped by 
	its byte position in the data unit.  
	I.e. 1<sup><font size="-1">st</font></sup>, 
	2<sup><font size="-1">nd</font></sup>, 
	3<sup><font size="-1">rd</font></sup>, 
	4<sup><font size="-1">th</font></sup> bytes of integers are 
	stored together respectively.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Fletcher32</td>
    <td class="ColumnRightBottom"> 
        <p>Fletcher32 checksum for error-detection.</td>
  </tr>
</table>

  <p>Filters may be used only for chunked data and are applied to chunks of 
  data between the file hyperslab stage and the virtual file layer. At this 
  stage in the pipeline, the data is organized as fixed-size blocks of elements,
  and the filter stage processes each chunk separately.

  <p>Filters are selected by dataset creation properties, and some behavior may 
  be controlled by data transfer properties. The library determines what 
  filters must be applied and in what order.
  
  <p>See The HDF Group website for 
  <a href="http://www.hdfgroup.org/doc_resource/SZIP/" target="Ext1">further 
  information</a> regarding the Szip filter.

  <p>Information regarding the n-bit and scale-offset filters 
  can be found in <a href="#N-Bit">Using the N-bit Filter</a> 
  and <a href="#ScaleOffset">Using the Scale-offset Filter</a>,
  respectively.

<h4>4.3 File drivers</h4>

  <p>I/O is performed by the HDF5 virtual file layer. The file driver interface 
  writes and reads blocks of data, each driver module implements the interface 
  using different I/O mechanisms. 
  Table 7 lists the file drivers currently supported. 
  Note that the I/O mechanisms are separated from the pipeline processing: 
  the pipeline and filter operations are identical no matter what 
  data access mechanism is used.</p>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="center" valign="bottom"><h4>Table 7</h4></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>File Driver</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5FD_CORE</td>
    <td class="ColumnRightCell"> 
        <p>Store in memory (optional backing store to disk file)</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5FD_DPSS</td>
    <td class="ColumnRightCell"> <p>
    &nbsp;
<!-- editingComment
  <span class="editingComment">[ [ [
    ???
  ] ] ]</span>
-->
    </td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5FD_FAMILY</td>
    <td class="ColumnRightCell"> <p>Store in a set of files 
<!-- editingComment
  <span class="editingComment">[ [ [
    (See [[??]])
  ] ] ]</span>
-->
    </td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5FD_GASS</td>
    <td class="ColumnRightCell"> 
        <p>Store using Globus Access to Secondary Storage 
<!-- editingComment
  <span class="editingComment">[ [ [
	(See [[cite]])
  ] ] ]</span>
-->
	</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5FD_LOG</td>
    <td class="ColumnRightCell"> <p>Store in logging file.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5FD_MPIO</td>
    <td class="ColumnRightCell"> <p>Store using MPI/IO 
<!-- editingComment
  <span class="editingComment">[ [ [
    (See [[cite]])
  ] ] ]</span>
-->
    </td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5FD_MULTI</td>
    <td class="ColumnRightCell"> 
        <p>Store in multiple files, several options to control layout.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5FD_SEC2</td>
    <td class="ColumnRightCell"> 
        <p>Serial I/O to file using Unix "section 2" functions.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5FD_STDIO</td>
    <td class="ColumnRightCell"> 
        <p>Serial I/O to file using Unix "stdio" functions</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>H5FD_STREAM</td>
    <td class="ColumnRightBottom"> <p>I/O to socket.</td>
  </tr>
</table>

  <p>Each file driver writes/reads contiguous blocks of bytes from a logically 
  contiguous address space. The file driver is responsible for managing the 
  details of the different physical storage methods.

  <p>In general, everything above the virtual file layer works identically no 
  matter what storage method is used. However, some combinations of storage 
  strategies and file drivers are not allowed.  Also, some options may have 
  substantially different performance depending on the file driver that is used. 
  In particular, multi-file and parallel I/O may perform considerably differently 
  from serial drivers, depending on chunking and other settings.

<h4>4.4 Data Transfer Properties to manage the pipeline</h4>

  <p>Data transfer properties set optional parameters that control parts of the 
  data pipeline. Table 8 lists three transfer properties that control the behavior 
  of the library.  
<!-- editingComment
  <span class="editingComment">[ [ [
  &lt;&lt;Developers: explain what these do!&gt;&gt;</p>
  ] ] ]</span>
-->

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="center" valign="bottom"><h4>Table 8</h4></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Property</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5Pset_buffer</td>
    <td class="ColumnRightCell"> 
        <p>Maximum size for the type conversion buffer and background buffer and 
	optionally supplies pointers to application-allocated buffers</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5Pset_hyper_cache</td>
    <td class="ColumnRightCell"> 
        <p>Whether to cache hyperslab blocks during I/O.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>H5Pset_btree_ratios</td>
    <td class="ColumnRightBottom"> 
        <p>Set the B-tree split ratios for a dataset transfer property list. 
	The split ratios determine what percent of children go in the 
	first node when a node splits.</td>
  </tr>
</table>

  <p>Some filters and file drivers require or use additional parameters from the 
  application program. These can be passed in the transfer property list. 
  Table 9 lists the four file driver property lists.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="center" valign="bottom"><h4>Table 9</h4></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Property</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5Pset_dxpl_mpio</td>
    <td class="ColumnRightCell"> 
        <p>Control the MPI I/O transfer mode (independent or collective) 
	during data I/O operations.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5Pset_dxpl_multi</td>
    <td class="ColumnRightCell">
    &nbsp;
<!-- editingComment
  <span class="editingComment">[ [ [
    <p>??
  ] ] ]</span>
-->
    </td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>H5Pset_small_data_block_size</td>
    <td class="ColumnRightCell"> 
        <p>Reserves blocks of size bytes for the contiguous storage of the raw 
	data portion of small datasets. The HDF5 Library then writes the raw data 
	from small datasets to this reserved space, thus reducing unnecessary 
	discontinuities within blocks of meta data and 
	improving IO performance.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>H5Pset_edc_check</td>
    <td class="ColumnRightBottom"> 
        <p>Disable/enable EDC checking for read.  (When selected, EDC 
	is always written)</td>
  </tr>
</table>

  <p>The transfer properties are set in a property list, which is passed as a 
  parameter of the H5Dread or H5Dwrite call.  The transfer properties are 
  passed to each pipeline stage, which may use or ignore any property in the 
  list. In short, there is one property list, which contains all the properties.

<!-- NEW PAGE -->
<h4>4.5 Storage strategies</h4>

  <p>The raw data is conceptually a multi-dimensional array of elements, 
  stored as a contiguous array of bytes. The data may be physically stored 
  in the file in several ways. Table 6 lists the storage strategies 
  for a dataset.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="center" valign="bottom"><h4>Table 10</h4></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Storage Strategy</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>CONTIGUOUS</td>
    <td class="ColumnRightCell"> 
        <p>The dataset is stored as one continuous array of bytes</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>CHUNKED</td>
    <td class="ColumnRightCell"> 
        <p>The dataset is stored as fixed-size chunks.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>COMPACT</td>
    <td class="ColumnRightBottom"> 
        <p>A small dataset is stored in the metadata header.</td>
  </tr>
</table>

  <p>The different storage strategies do not affect the data transfer operations of 
  the dataset: reads and writes work the same for any storage strategy.

<!-- editingComment
  <span class="editingComment">[ [ [
  <p>&lt;&lt;Relationship between storage strategies, and pipeline, filters, 
  and file drivers.??&gt;&gt;
  ] ] ]</span>
-->

  <p>These strategies are described in the following sections.

<h4><em>Contiguous</em></h4>

  <p>A contiguous dataset is stored in the file as a header and a single 
  continuous array of bytes. (Figure 12) The data elements are arranged in row major order, 
<!-- editingComment
  <span class="editingComment">[ [ [
  Verify "row major order" statement
  ] ] ]</span>
-->
  with according to the datatype. By default, data is stored contiguously.</p>


<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig12.JPG">
    </td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 12</span></td>
  </tr>
</table>


  <p>Contiguous storage is the simplest model. It has several limitations. 
  First, the dataset must be a fixed size: it is not possible to extend the 
  limit of dataset, or to have unlimited dimensions. Second, because data is 
  passed through the pipeline as fixed-size blocks, compression and other 
  filters cannot be used with contiguous data.

<h4><em>Chunked</em></h4>

  <p>The data of a dataset may be stored as fixed-size chunks (Figure 13). 
  A chunk is a hyper-rectangle of any shape. 
  When a dataset is chunked, each chunk is read or written as a single I/O 
  operation, and individually passed from stage to stage of the pipeline 
  and filters.</p>


<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig13.JPG">
    </td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 13</span></td>
  </tr>
</table>


<!-- NEW PAGE -->
  <p>Chunks may be any size and shape that fits in the dataspace of the dataset.
  For example, a three dimensional dataspace can be chunked as 3-D cubes, 
  2-D planes, or 1-D lines. The chunks may extend beyond the size of the 
  dataspace, for example a 3 X 3 dataset might by chunked in 2 X 2 chunks. 
  Sufficient chunks will be allocated to store the array, any extra space 
  will not be accessible. So, to store the 3X3 array, four 2X2 chunks would 
  be allocated, with 5 unused elements stored.

  <p>Chunked datasets can be unlimited (in any direction), 
  and can be compressed or filtered.

  <p>Since the data is read or written by chunks, chunking can have a dramatic 
  effect on performance by optimizing what is read and written.  Note, too, 
  that for specific access patterns (e.g., parallel I./O) decomposition into 
  chunks can have a large impact on performance.

  <p>Two restrictions are placed on chunk shape and size:
<table width=100%><tr align=left><td>
    <ul>
      <li>The rank of a chunk must be less than or equal to 
          the rank of the dataset.  
      <li>Chunk size cannot exceed the size of a fixed-size dataset. 
          For example, a dataset consisting of a 5x4 fixed-size array 
          cannot be defined with 10x10 chunks. 
    </ul>
</td></tr></table>



<h4><em>Compact</em></h4>

  <p>For contiguous and chunked storage, the dataset header information and data 
  are stored in two (or more) blocks (Figure 14). Therefore, at least two I/O operations 
  are required to access the data, one to access the header, and one (or more) 
  to access data. For a small dataset, this is considerable overhead.


<table x-use-null-cells
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig14.JPG">
    </td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 14</span></td>
  </tr>
</table>


  <p>A small dataset may be stored in a continuous array of bytes in the 
  header block, using the COMPACT storage option. This dataset can be read 
  entirely in one operation, which retrieves the header and data.  
  The dataset must fit in the header, which varies depending on what 
  metadata may be stored. In general, a compact dataset should be 
  approximately 30 KB or less total size.

<!-- NEW PAGE -->
<h4>4.6 Partial I/O-Subseting and Hyperslabs</h4>

  <p>Data transfers can write or read some of the data elements of the dataset. 
  This is controlled by specifying two selections, one for the source and one for 
  the destination. Selections are specified by creating a dataspace 
  with selections. 
<!-- editingComment
  <span class="editingComment">[ [ [
  (see [[dataspace chapter]])
  ] ] ]</span>
-->

  <p>Selections may be a union of hyperslabs, where a hyperslab is a contiguous 
  hyper-rectangle from the dataspace. A second form of selection is a list 
  of points. Selected fields of compound data type may be read or written. 
  In this case, the selection is controlled by the memory and file datatypes.

  <p>Summary of procedure:</p>
  
  <ol>
      <li>open the dataset
      <li>define the memory datatype
      <li>define the memory dataspace selection and file dataspace selection
      <li>transfer data (H5Dread or H5Dwrite)
  </ol>

  <p>For a detailed explanation of selections, see the chapter
  "<a href="12_Dataspaces.html">HDF5 Dataspaces and Partial I/O</a>."
  
<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="Allocation">
<div align=right>
<a href="#TOP"><font size=-1>(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>









<!-- NEW PAGE -->
<a name="Allocation">
<h3 class=pagebefore>5. Allocation of Space in the File</h3>
</a>

  <p>When a dataset is created, space is allocated in the file for its header and 
  initial data. The amount of space allocated when the dataset is created depends 
  on the storage properties. When the dataset is modified (data is written, 
  attributes added, or other changes), additional storage may be 
  allocated if necessary.</p>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="center" valign="bottom"><h4>Table 11</h4></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Object</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Size (bytes)</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Header</td>
    <td class="ColumnRightCell"> 
        <p>Variable, but typically around 256 bytes at the creation of 
        a simple dataset with a simple datatype</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Data</td>
    <td class="ColumnRightBottom"> 
        <p>Size of the data array (number of elements X size of element). 
	Space allocated in the file depends on storage strategy 
	and allocation strategy.</td>
  </tr>
</table>

<h4><em>Header</em></h4>

  <p>A dataset header consists of one or more header messages containing 
  persistent metadata describing various aspects of the dataset. 
  These records are defined in the <cite>HDF5 File Format Specification</cite>. 
<!-- editingComment
  <span class="editingComment">[ [ [
  [[cite format]]. 
  ] ] ]</span>
-->
  The amount of storage required for the metadata depends on the metadata 
  to be stored. Table 12 summarizes the metadata.</p>

<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="center" valign="bottom"><h4>Table 12</h4></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr" width="50%"> 
        <p><span class=TableHead>Header Information</span></td>
    <td class="ColumnRightHdr" width="50%"> 
        <p><span class=TableHead>Approximate Storage Size</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Datatype (required)</td>
    <td class="ColumnRightCell"> <p>bytes  or more, depends on type
<!-- editingComment
  <span class="editingComment">[ [ [
  Verify
  ] ] ]</span>
-->
    </td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Dataspace (required)</td>
    <td class="ColumnRightCell"> 
        <p>bytes or more, depends on number of dimensions and hsize_t
<!-- editingComment
  <span class="editingComment">[ [ [
  Verify
  ] ] ]</span>
-->
	</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> 
        <p>Layout (required) - points to the stored data</td>
    <td class="ColumnRightCell"> 
        <p>bytes or more, depends on hsize_t and number of dimensions
<!-- editingComment
  <span class="editingComment">[ [ [
  Verify
  ] ] ]</span>
-->
	</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Filters</td>
    <td class="ColumnRightBottom"> 
        <p>Depends on the number of filters, size of filter message depends on 
	name and data that will be passed.</td>
  </tr>
</table>

  <p>The header blocks also store the name and values of attributes, so the total 
  storage depends on the number and size of the attributes.

  <p>In addition, the data set must have at least one link, including a name, 
  which is stored in the file and in the group it is a linked from.

  <p>The different storage strategies determine when and how much space is 
  allocated for the data array. See the discussion of fill values below
<!-- editingComment
  <span class="editingComment">[ [ [
  Link
  ] ] ]</span>
-->
  for a detailed explanation of the storage allocation.

<h4><em>Contiguous Storage</em></h4>

  <p>For a continuous storage option, the data is stored in a single, 
  contiguous block in the file.  The data is nominally a fixed size, 
  (number of elements X size of element). Figure 15 shows and example of a two 
  dimensional array, stored as a contiguous dataset.

  <p>Depending on the fill value properties, the space may be allocated when the 
  dataset is created or when first written (default), and filled with fill values 
  if specified. For parallel I/O, by default the space is allocated 
  when the dataset if created.</p>
  
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig15.JPG">
    </td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 15</span></td>
  </tr>
</table>

<h4><em>Chunked</em></h4>

  <p>For chunked storage, the data is stored in one or more chunks.  Each chunk 
  is a continuous block in the file, but chunks are not necessarily stored 
  contiguously. Each chunk has the same size.  The data array has the same 
  nominal size as a contiguous array (number of elements X size of element), 
  but the storage is allocated in chunks, so the total size in the file can 
  be larger that the nominal size of the array.
  
<!-- editingComment
  <span class="editingComment">[ [ [
  <p class="editingComment" align="center">
  - - - Figure 16 may be  improperly placed - - -
  </p>
  ] ] ]</span>
-->
  
  <p>
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig16.JPG">
    </td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 16</span></td>
  </tr>
</table>

  <p>If a fill value is defined, each chunk will be filled with the fill value. 
  Chunks must be allocated when data is written, but they may be allocated when 
  the file is created, as the file expands, or when data is written. 

  <p>For serial I/O, by default chunks are allocated incrementally, as data is 
  written to the chunk. For a sparse dataset, chunks are allocated only for the 
  parts of the dataset that are written. In this case, if the dataset is extended, 
  no storage is allocated.

  <p>For parallel I/O, by default the chunks are allocate when the dataset is 
  created or extended., with fill values written to the chunk.

  <p>In either case, the default can be changed using fill value properties.  
  For example, using serial I/O, the properties can select to can allocate 
  chunks when the dataset is created

  <p>H5Dextend is used to change the current dimensions of the dataset, within 
  the limits of the dataspace.  Each dimension can be extended up to its maximum, 
  or unlimited. Extending the dataspace may or may not allocate space in the file, 
  and may or may not write fill values, if they are defined.  See the next 
  section for an explanation.
  
<!-- editingComment
  <span class="editingComment">[ [ [
  <p class="editingComment" align="center">
  - - - Figure 17 may be improperly placed - - -
  </p>
  ] ] ]</span>
-->
  
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
    <pre><code>
   hid_t       file_id, dataset_id;  
   Herr_t      status;
   size_t        newdims[2];


   /* Open an existing file. */
   file_id = H5Fopen("dset.h5", H5F_ACC_RDWR, H5P_DEFAULT);

   /* Open an existing dataset. */
   dataset_id = H5Dopen(file_id, "/dset");

   /* Example:  dataset is 2 X 3, each dimension is UNLIMITED */
   /* extend to 2 X 7 */
   newdims[0] = 2;
   newdims[1] = 7;

   status = H5Dextend(dataset_id, newdims);

   /* dataset is now 2 X 7 */

   status = H5Dclose(dataset_id);
    </code></pre></td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 17</span></td>
  </tr>
</table>
  
<h4>5.1 Storage Allocation in the File: Early, Incremental, Late</h4>

  <p>The HDF5 Library implements several strategies for when storage is allocated 
  if and when it is filled with fill values for elements not yet written by the user. 
  Different strategies are recommended for different storage layouts and file drivers. 
  In particular, a parallel program needs storage allocated during a collective call 
  (e.g., create or extend), while serial programs may benefit from delaying the 
  allocation until the data is written.

  <p>Two file creation properties control "when to allocate space", "when to 
  write the fill-value" and the actual fill-value to write. 

  <p>Table 13 shows the three options for when data is allocated in the file. "Early" 
  allocation is done during dataset create call. Certain file drivers (especially 
  MPI-I/O and MPI-posix) require space to be allocated when a dataset is created, 
  so all processors will have the correct view of the data.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="center" valign="bottom"><h4>Table 13</h4></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Strategy</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Early</td>
    <td class="ColumnRightCell"> 
        <p>Allocate storage for the dataset immediately when the dataset 
	is created. </td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Late</td>
    <td class="ColumnRightCell"> 
        <p>Defer allocating space for storing the dataset until the 
	dataset is written.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Incremental</td>
    <td class="ColumnRightCell"> 
        <p>Defer allocating space for storing each chunk until 
	the chunk is written.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Default</td>
    <td class="ColumnRightBottom"> 
        <p>Use the strategy (Early, Late, Incremental) for the storage method 
	and access method. (Recommended)</td>
  </tr>
</table>

  <p>"Late" allocation is done at the time of the first write to dataset. Space 
  for the whole dataset is allocated at the first write.

  <p>"Incremental" allocation (chunks only) is done at the time of the first 
  write to the chunk. Chunks that have never been written are not allocated 
  in the file. In a sparsely populated dataset, this option allocates chunks 
  only where data is actually written.

<!-- NEW PAGE -->
  <p>The "Default" property selects the option recommended as appropriate for 
  the storage method and access method. The defaults are shown in Table 14. 
  Note that "Early" allocation is recommended for all Parallel I/O, while 
  other options are recommended as the default for serial I/O cases.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="3" align="center" valign="bottom"><h4>Table 14</h4></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr" width="33%"> 
        <p><span class=TableHead>&nbsp;</span></td>
    <td class="ColumnLeftHdr" width="34%"> 
        <p><span class=TableHead>Serial I/O</span></td>
    <td class="ColumnRightHdr" width="33%"> 
        <p><span class=TableHead>Parallel I/O</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Contiguous Storage</td>
    <td class="ColumnCell"> <p>Late</td>
    <td class="ColumnRightCell"> <p>Early</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Chunked Storage</td>
    <td class="ColumnCell"> <p>Incremental</td>
    <td class="ColumnRightCell"> <p>Early</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Compact Storage</td>
    <td class="ColumnBottom"> <p>Early</td>
    <td class="ColumnRightBottom"> <p>Early</td>
  </tr>
</table>
 
  <p>The second property is when to write fill value, "Never" and "Allocation". 
  Table 15 shows these options.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="center" valign="bottom"><h4>Table 15</h4></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>When</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Never</td>
    <td class="ColumnRightCell"> <p>Fill value will never be written.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Allocation</td>
    <td class="ColumnRightBottom"> 
        <p>Fill value is written when space is allocated. (Default for chunked 
	and contiguous data storage.)</td>
  </tr>
</table>

  <p>The third property is the fill value to write. Table 16 shows the values. 
  By default, the data is filled with zeroes. The application may choose no 
  fill value (Undefined), in which case uninitialized data may have any random 
  values. The application may define a fill-value of the appropriate type.  
  See the chapter "<a href="11_Datatypes.html">HDF5 Datatypes</a>" 
  for more information regarding fill values.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>What to Write</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Undefined</td>
    <td class="ColumnRightCell"> 
        <p>No value stored, do not fill with zeroes (the default)</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Default</td>
    <td class="ColumnRightCell"> 
        <p>By default, the library defines a fill-value of all zero bytes</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>User-defined</td>
    <td class="ColumnRightBottom"> 
        <p>The applications specifies the fill value.</td>
  </tr>
</table>

<!-- NEW PAGE -->
  <p>Together these three properties control the library's behavior. 
  Table 16 summarizes the possible behavior of during the dataset 
  create-write-close cycle.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="4" align="center"><h4>Table 16</h4></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr" width="16.5%"> 
        <p align="center"><span class=TableHead>When to allocate space</span></td>
    <td class="ColumnHdr" width="16.5%"> 
        <p align="center"><span class=TableHead>When to write fill value</span></td>
    <td class="ColumnHdr" width="17%"> 
        <p align="center"><span class=TableHead>What fill value to write</span></td>
    <td class="ColumnRightHdr" width="50%"> 
        <p align="center">
	<span class=TableHead>Library create-write-close behavior</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Early</td>
    <td class="ColumnCell"> <p>Never</td>
    <td class="ColumnCell"> <p>-</td>
    <td class="ColumnRightCell"> 
        <p>Library allocates space when dataset is created, but never writes fill 
	value to dataset. (Read of unwritten data returns undefined values.)</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Late</td>
    <td class="ColumnCell"> <p>Never</td>
    <td class="ColumnCell"> <p>-</td>
    <td class="ColumnRightCell"> 
        <p>Library allocates space when dataset is written to, but never writes 
	fill value to dataset. (Read of unwritten data returns 
	undefined values.)</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Incremental</td>
    <td class="ColumnCell"> <p>Never</td>
    <td class="ColumnCell"> <p>-</td>
    <td class="ColumnRightCell"> 
        <p>Library allocates space when dataset or chunk (whichever is smallest 
	unit of space) is written to, but never writes fill value to dataset or 
	chunk. (Read of unwritten data returns undefined values.)</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>-</td>
    <td class="ColumnCell"> <p>Allocation</td>
    <td class="ColumnCell"> <p>undefined</td>
    <td class="ColumnRightCell"> 
        <p><strong>Error</strong> on creating dataset, dataset not created.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Early</td>
    <td class="ColumnCell"> <p>Allocation</td>
    <td class="ColumnCell"> <p>default or user-defined</td>
    <td class="ColumnRightCell"> 
        <p>Allocate space for dataset when dataset is created. Write fill value 
	(default or user-defined) to entire dataset when dataset is created.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Late</td>
    <td class="ColumnCell"> <p>Allocation</td>
    <td class="ColumnCell"> <p>default or user-defined</td>
    <td class="ColumnRightCell"> 
        <p>Allocate space for dataset when application first writes data values 
	to the dataset. Write fill value to entire dataset before writing 
	application data value.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>Incremental</td>
    <td class="ColumnBottom"> <p>Allocation</td>
    <td class="ColumnBottom"> <p>default or user-defined</td>
    <td class="ColumnRightBottom"> 
        <p>Allocate space for dataset when application first writes data values 
	to the dataset or chunk (whichever is smallest unit of space). 
	Write fill value to entire dataset or chunk before writing 
	user's data value. </td>
  </tr>
</table>

<!-- NEW PAGE -->
  <p>During the H5Dread function call, the library behavior depends on whether 
  space has been allocated, whether fill value has been written to storage, 
  how fill value is defined, and when to write fill value. Table 17 summarizes 
  the different behaviors.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="4" align="center"><h4>Table 17</h4></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr" width="16.5%"> 
        <p align="center">
	<span class=TableHead>Is space allocated in the file?</span></td>
    <td class="ColumnHdr" width="16.5%"> 
        <p align="center">
	<span class=TableHead>What is the fill value?</span></td>
    <td class="ColumnHdr" width="17%"> 
        <p align="center">
	<span class=TableHead>When to write fill value?</span></td>
    <td class="ColumnRightHdr" width="50%"> 
        <p align="center">
	<span class=TableHead>Library read behavior</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>No</td>
    <td class="ColumnCell"> <p>undefined</td>
    <td class="ColumnCell"> <p>&lt;&lt;any&gt;&gt;</td>
    <td class="ColumnRightCell"> 
        <p><strong>Error</strong>. Cannot create this dataset.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>&nbsp;</td>
    <td class="ColumnCell"> <p>default or user-defined</td>
    <td class="ColumnCell"> <p>&lt;&lt;any&gt;&gt;</td>
    <td class="ColumnRightCell"> <p>Fill memory buffer with the fill value.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>Yes</td>
    <td class="ColumnCell"> <p>undefined</td>
    <td class="ColumnCell"> <p>&lt;&lt;any&gt;&gt;</td>
    <td class="ColumnRightCell"> 
        <p>Return data from storage (dataset), trash is possible if user has not 
	written data to portion of dataset being read.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>&nbsp;</td>
    <td class="ColumnCell"> <p>default or user-defined</td>
    <td class="ColumnCell"> <p>Never</td>
    <td class="ColumnRightCell"> 
        <p>Return data from storage (dataset), trash is possible if user has not 
	written data to portion of dataset being read.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> <p>&nbsp;</td>
    <td class="ColumnBottom"> <p>default or user-defined</td>
    <td class="ColumnBottom"> <p>Allocation</td>
    <td class="ColumnRightBottom"> <p>Return data from storage (dataset).</td>
  </tr>
</table>

  <p>There are two cases to consider, depending on whether the space in the file 
  has been allocated before the read or not. When space has not yet been allocated, 
  if a fill value is defined the memory buffer will be filled with the values 
  and returned (no read from disk).

  <p>If the space has been allocated, the values are returned from the stored 
  data. The unwritten elements will be filled according to the fill value, 
  or undefined.

<h4>5.2  Deleting a dataset from a file, reclaiming space</h4>

  <p>The size of the dataset cannot be reduced after it is created. The dataset 
  can be expanded by extending one or more dimensions, with H5Dextend. It is 
  not possible to contract a dataspace, or to reclaim allocated space.

  <p>HDF5 does not at this time provide a mechanism to remove a dataset from a 
  file, or to reclaim the storage from deleted objects. Through the H5Gunlink 
  function one can remove links to a dataset from the file structure. Once all 
  links to a dataset have been removed, that dataset becomes inaccessible to any 
  application and is effectively removed from the file. But this does not recover 
  the space the dataset occupies. 

  <p>The only way to recover the space is to write all the objects of the file 
  into a new file. Any unlinked object is inaccessible to the application and 
  will not be included in the new file. 

  <p>See the chapter "<a href="09_Groups.html">HDF5 Groups</a>" for 
  further discussion of HDF5 file structures and the use of links. 

<h4>5.3 Releasing memory resources (handles) when no longer needed</h4>

  <p>The system resources required for HDF5 objects, including datasets, 
  datatypes, and dataspaces, should be released once access to the object is 
  no longer needed. This is accomplished via the appropriate close function. 
  This is not particular to datasets but a general requirement when working 
  with the HDF5 Library; failure to close objects will result in resource leaks. 

  <p>In the case where a dataset is created or data has been transferred, 
  there are several objects that must be closed, 
<!-- editingComment
<span class="editingComment">
   [ [ [ 
   (T? above) 
   originally appeared here.  On the full editorial pass, 
   see if there is any apparent reason for the question.
   ] ] ]
  </span>
-->
  including the dataset, 
  the datatype, dataspace, and property lists. 

  <p>The application program must free any memory variables and buffers it 
  allocates. When accessing data from the file, the amount of memory required 
  can be determined by determining the size of the memory datatype and the 
  number of elements in the memory selection.

  <p>Variable length data are organized in two or more areas of memory 
  (see "<a href="11_Datatypes.html">HDF5 Datatypes</a>").
  When writing data, the application 
  creates an array of vl_info_t, which contains pointers to the elements, 
  e.g., strings. In the file, the variable length data is stored in two parts: 
  a heap with the variable length values of the data elements, and an array 
  vlinfo_t elements. When the data is read, the amount of memory required 
  for the heap can be determined with the H5Dget_vlen_buf_size call.

  <p>The data transfer property may be used to set a custom memory manager 
  for allocating variable length data for a H5Dread. This is set with the 
  H5Pset_vlen_mem_manager call.

  <p>To free the memory for variable length data, it is necessary to visit each 
  element, free the variable length data, and reset the element. The application 
  must free the memory it has allocated. For memory allocated by the HDF5 Library 
  during a read, the H5Dvlen_reclaim function can be used to perform this operation.

<h4>5.4 External Storage Properties</h4>

  <p>The external storage format allows data to be stored across a set of 
  non-HDF5 files. A set segments (offsets and sizes) in one or more files 
  is defined as an external file list, or EFL, and the contiguous logical 
  addresses of the data storage are mapped onto these segments. Currently, 
  only the H5D_CONTIGUOUS storage format allows external storage. External 
  storage is enabled by a dataset creation property. Table 18 shows the API.</p>
  
<table x-use-null-cells
		class="ColumnTable"
		width=600
		cellspacing=0
		align="center">
  <tr valign="bottom">
    <td colspan="2" align="center" valign="bottom"><h4>Table 18</h4></td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftHdr"> 
        <p><span class=TableHead>Function</span></td>
    <td class="ColumnRightHdr"> 
        <p><span class=TableHead>Description</span></td>
  <tr valign=top> 
    <td class="ColumnLeftCell"> 
        <p>herr_t H5Pset_external (hid_t plist, const char *name, off_t offset, 
	hsize_t size) 
</td>
    <td class="ColumnRightCell"> 
        <p>This function adds a new segment to the end of the external file list 
	of the specified dataset creation property list. The segment begins a 
	byte offset of file name and continues for size bytes. The space 
	represented by this segment is adjacent to the space already represented 
	by the external file list. The last segment in a file list may have the 
	size H5F_UNLIMITED, in which case the external file may be of unlimited 
	size and no more files can be added to the external files list.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftCell"> <p>int H5Pget_external_count (hid_t plist)</td>
    <td class="ColumnRightCell"> 
        <p>Calling this function returns the number of segments in an external 
	file list. If the dataset creation property list has no external 
	data then zero is returned.</td>
  </tr>
  <tr valign=top> 
    <td class="ColumnLeftBottom"> 
        <p>herr_t H5Pget_external (hid_t plist, int idx, size_t name_size, 
	char *name, off_t *offset, hsize_t *size)</td>
    <td class="ColumnRightBottom"> 
        <p>This is the counterpart for the H5Pset_external() function. Given a 
	dataset creation property list and a zero-based index into that list, 
	the file name, byte offset, and segment size are returned through non-null 
	arguments. At most name_size characters are copied into the name argument 
	which is not null terminated if the file name is longer than the supplied 
	name buffer (this is similar to strncpy()). </td>
  </tr>
</table>

<!-- editingComment
  <span class="editingComment">[ [ [
  - - - The text and figures that 
  follow may not correspond properly - - -
  <br>
  (Made a quick pass today to sort it out -- FMB, 24 Jy '03.)
  ] ] ]</span>
-->

<!-- NEW PAGE -->
  <p>Figure 19 shows an example of how a contiguous, one-dimensional dataset is 
  partitioned into three parts and each of those parts is stored in a segment 
  of an external file. The top rectangle represents the logical address space 
  of the dataset while the bottom rectangle represents an external file.
  
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
    <img src="Images/Dsets_fig19.JPG">
    </td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 19</span></td>
  </tr>
</table>
  
  <p>Figure 19a shows code that defines the external storage for the example. Note that 
  the segments are defined in order of the logical addresses they represent, 
  not their order within the external file. It would also have been possible 
  to put the segments in separate files. Care should be taken when setting up 
  segments in a single file since the library doesn't automatically check for 
  segments that overlap.</p>
  
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
    <pre><code>
 Plist = H5Pcreate (H5P_DATASET_CREATE);
  H5Pset_external (plist, "velocity.data", 3000, 1000);
  H5Pset_external (plist, "velocity.data", 0, 2500);
  H5Pset_external (plist, "velocity.data", 4500, 1500);</code></pre>
	</td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 19a</span></td>
  </tr>
</table>

  <p>Figure 20 shows an example of how a contiguous, two-dimensional dataset is 
  partitioned into three parts and each of those parts is stored in a separate 
  external file. The top rectangle represents the logical address space of the 
  dataset while the bottom rectangles represent external files.</p>
  
  <p>
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell" align="center">
	<img src="Images/Dsets_fig20.jpg">
    </td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 20</span></td>
  </tr>
</table>

<!-- NEW PAGE -->
  <p>Figure 21 shows code for this example.

  <p>In this example, the library maps the multi-dimensional array onto a linear 
  address space as defined by the HDF5 format specification, and then maps that 
  address space into the segments defined in the external file list. 

  <p>
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
    <pre><code>
 Plist = H5Pcreate (H5P_DATASET_CREATE);
  H5Pset_external (plist, "scan1.data", 0, 24);
  H5Pset_external (plist, "scan2.data", 0, 24);
  H5Pset_external (plist, "scan3.data", 0, 16);
    </code></pre></td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
    <span class=figurenumber>Figure 21</span></td>
  </tr>
</table>

  <p>The segments of an external file can exist beyond the end of the (external) 
  file. The library reads that part of a segment as zeros. When writing to a 
  segment that exists beyond the end of a file, the external file is automatically 
  extended. Using this feature, one can create a segment (or set of segments) 
  which is larger than the current size of the dataset, which allows to dataset 
  to be extended at a future time (provided the data space also allows the 
  extension).

  <p>All referenced external data files must exist before performing raw data I/O 
  on the dataset. This is normally not a problem since those files are being managed 
  directly by the application, or indirectly through some other library. However, 
  if the file is transferred from its original context, care must be taken to assure 
  that all the external files are accessible in the new location.</p>





<a name="UseFilters">
<h3 class=pagebefore>6. Using HDF5 Filters</h3>
</a>

<a name="N-Bit">
<h3>6.1. N-bit Filter</h3>
</a>

<p>N-bit data has <i>n</i> significant bits,  
  where <i>n</i> may not correspond to a precise number of bytes.
  On the other hand, computing systems and applications universally, 
  or nearly so, run most efficiently when manipulating data as 
  whole bytes or multiple bytes.
  This can easily lead to a situation where requirements to facilitate
  high-speed operation

<p>Consider the case of 12-bit integer data.  
  In memory, that data will be handled in at least 2 bytes, or 16 bits, 
  and on some platforms in 4 or even 8 bytes.
  The size of such a dataset can be significantly reduced when written 
  to disk if the unused bits are stripped out.
  
<p>The <i>n-bit filter</i> is provided for this purpose,  
  <i>packing</i> n-bit data on output by stripping off all unused bits 
  and <i>unpacking</i> on input, restoring the extra bits required
  by the computational processor.
  
<h4><em>N-bit Datatype</em></h4>

<p>An <i>n-bit datatype</i> is a datatype of <i>n</i> significant bits.
  Unless it is packed, an <i>n</i>-bit datatype is presented as an 
  <i>n</i>-bit bitfield within a larger-sized value.  
  For example, a 12-bit datatype might be presented as a 12-bit field 
  in a 16-bit, or 2-byte, value.

<p>Currently, the datatype classes of n-bit datatype or n-bit field of a 
  compound datatype or an array datatype are limited to integer or 
  floating-point.
  
<p>The HDF5 user can create an n-bit datatype through a series of
  of function calls.
  For example, the following calls create a 16-bit datatype 
  that is stored in a 32-bit value with a 4-bit offset:
<dir><pre>
hid_t nbit_datatype = H5Tcopy(H5T_STD_I32LE);
H5Tset_precision(nbit_datatype, 16);
H5Tset_offset(nbit_datatype, 4);
</pre></dir>
  
<p>In memory, one value of above example n-bit datatype would be stored on 
  a little-endian machine as follows:
  
<dl>
      <dt>
        <table border="1" width="80%" align="center">
          <tr>
            <td width="25%" align="center">byte 3</td>
            <td width="25%" align="center">byte 2</td>
            <td width="25%" align="center">byte 1</td>
            <td width="25%" align="center">byte 0</td>
          </tr>
          <tr>
            <td width="25%" align="center"><code>????????</code></td>
            <td width="25%" align="center"><code>????SPPP</code></td>
            <td width="25%" align="center"><code>PPPPPPPP</code></td>
            <td width="25%" align="center"><code>PPPP????</code></td>
          </tr>
        </table>
        <table width="80%" border="0" align="center">
          <tr>
            <td colspan="4"><font size=-1>
              Key: 
                  <code>S</code> - sign bit, 
                  <code>P</code> - significant bit, 
                  <code>?</code> - padding bit 
              <br>
              Sign bit is included in signed integer datatype precision.
	    </font></td>
          </tr>
        </table>
        <br>
        
      </dt>
</dl>

<h4><em>N-bit Filter</em></h4>

<p>When data of an n-bit datatype is stored on disk using the 
  n-bit filter, the filter <i>packs</i> the data by stripping off the 
  padding bits; only the significant bits are retained and stored.  
  The values on disk will appear as follows:
  
<dl>
      <dt>
        <table border="1" width="80%" align="center">
          <tr>
            <td width="45%" align="center">1st value</td>
            <td width="45%" align="center">2nd value</td>
            <td width="10%" align="center">&nbsp;</td>
          </tr>
          <tr>
            <td width="45%" align="center"><code>SPPPPPPP&nbsp;PPPPPPPP</code></td>
            <td width="45%" align="center"><code>SPPPPPPP&nbsp;PPPPPPPP</code></td>
            <td width="10%" align="center">...</td>
          </tr>
        </table>
        <table width="80%" border="0" align="center">
          <tr>
            <td colspan="4"><font size=-1>
              Key: 
                  <code>S</code> - sign bit, 
                  <code>P</code> - significant bit, 
                  <code>?</code> - padding bit 
              <br>
              Sign bit is included in signed integer datatype precision.
	    </font></td>
          </tr>
        </table>
      </dt>
</dl>

<p>The n-bit filter can used effectively for compressing data of an n-bit
  datatype, including arrays and the n-bit fields of compound datatypes. 
  The filter supports complex situations where a compound datatype 
  contains member(s) of compound datatype or an array datatype has
  a compound datatype as the base type.

<p>At present, the n-bit filter supports all datatypes. 
  For datatypes of class time, string,
  bitfield, opaque, reference, <small>ENUM</small>, and 
  variable length, the n-bit filter acts as a no-op. 
  For convenience, the rest of this section refers to such datatypes 
  as <i>no-op datatypes</i>.

<p>As is the case with all HDF5 filters, an application using 
  the n-bit filter must store data with chunked storage.
  
<h4><em>How does the n-bit filter work?</em></h4>

<p>The n-bit filter always compresses and decompresses according to
  dataset properties supplied by the HDF5 library in the 
  datatype, dataspace or dataset creation property list.

<p>The dataset datatype refers to how data is stored in an HDF5 file while 
  the memory datatype refers to how data is stored in memory.
  The HDF5 library will do datatype conversion when writing data 
  in memory to the dataset or reading data from the dataset to memory if 
  the memory datatype differs from the dataset datatype. 
  Datatype conversion is performed by HDF5 Library before n-bit compression 
  and after n-bit decompression.
  
<p>The following subsections examine the common cases:
  <ul>
    <li>N-bit integer conversions
    <li>N-bit floating point conversions
  </ul>

<h5><em>Integer/n-bit conversions</em></h5>

<p>Integer data, with a dataset of integer datatype of less than 
  full precision and a memory datatype of <code>H5T_NATIVE_INT</code>,
  provides the simplest application of the n-bit filter.

<p>The precision of <code>H5T_NATIVE_INT</code> is 8 muliplied by 
  <code>sizeof(int)</code>. 
  This value, the size of an <code>int</code> in bytes, differs from 
  platform to platform; we assume a value of <code>4</code> 
  for the following illustration.
  We further assume the memory byte order to be little-endian.

<p>In memory, therefore, the precision of <code>H5T_NATIVE_INT</code> 
  is 32 and the offset is 0. 
  One value of <code>H5T_NATIVE_INT</code> is layed out in memory 
  as follows:
 
<table border="0" width="80%" align="center">
  <tr>
    <td>
<pre>
| byte 3 | byte 2 | byte 1 | byte 0 |
                                
|SPPPPPPP|PPPPPPPP|PPPPPPPP|PPPPPPPP|

</pre>
    </td>
  </tr>
  <tr>
    <td colspan="4"><font size=-1>
      Key: 
        <code>S</code> - sign bit, 
        <code>P</code> - significant bit, 
        <code>?</code> - padding bit 
      <br>
      Sign bit is included in signed integer datatype precision.
      </font></td>
  </tr>
</table>
  
<p>Suppose the dataset datatype has a precision of 16 and an offset of 4. 
  After HDF5 converts values from the memory datatype to the dataset datatype, 
  it passes something like the following to the n-bit filter for compression:

<table border="0" width="80%" align="center">
  <tr>
    <td>
<pre>
| byte 3 |  byte 2 | byte 1 |  byte 0 |
               |                 |
|????????|????S|PPP|PPPPPPPP|PPPP|????|
               |_________________|
                 truncated bits
</pre>
    </td>
  </tr>
  <tr>
    <td colspan="4"><font size=-1>
      Key: 
        <code>S</code> - sign bit, 
        <code>P</code> - significant bit, 
        <code>?</code> - padding bit 
      <br>
      Sign bit is included in signed integer datatype precision.
      </font></td>
  </tr>
</table>
  
<p>Notice that only the specified 16 bits (15 significant bits and the 
  sign bit) are retained in the conversion.  All other significant bits 
  of the memory datatype are discarded because the dataset datatype 
  calls for only 16 bits of precision. 
  After n-bit compression, none of these discarded bits, known as 
  <i>padding bits</i> will be stored on disk.
  
<h5><em>Floating-point/n-bit conversions</em></h5>

<p>Things get more complicated in the case of a floating-point dataset 
  datatype class.  This subsection provides such an example, 
  illustrating the conversion from a memory datatype of 
  <code>H5T_NATIVE_FLOAT</code> to a dataset datatype of class 
  floating-point.

<!-- NEW PAGE --> 
<p>As before, let the <code>H5T_NATIVE_FLOAT</code> be 4 bytes long, 
  and let the memory byte order be little-endian. 
  Per the IEEE standard [4], one value of <code>H5T_NATIVE_FLOAT</code> 
  is layed out in memory as follows:
  
<table border="0" width="80%" align="center">
  <tr>
    <td>
<pre>
| byte 3 | byte 2 | byte 1 | byte 0 |
                         
|SEEEEEEE|EMMMMMMM|MMMMMMMM|MMMMMMMM|

</pre>
  </td></tr>
  <tr>
    <td colspan="4"><font size=-1>
      Key: 
        <code>S</code> - sign bit, 
        <code>E</code> - exponent bit, 
        <code>M</code> - mantissa bit, 
        <code>?</code> - padding bit 
      <br>
      Sign bit is included in floating point datatype precision.
      </font></td>
  </tr>
</table>
 
  <br>
  
<p>Suppose the dataset datatype has a precision of 20, offset of 7, 
  mantissa size of 13, mantissa position of 7, 
  exponent size of 6, exponent position of 20, 
  and sign position of 26. 
  (Refer to [3] for details of how to create a user-defined 
  floating-point datatype.)
  
<p>After HDF5 converts values from the memory datatype to the dataset datatype, 
  it passes something like the following to the n-bit filter for compression:
  
<table border="0" width="80%" align="center">
  <tr>
    <td>
<pre>
| byte 3 | byte 2  | byte 1 | byte 0  |
              |               |
|?????SEE|EEEE|MMMM|MMMMMMMM|M|???????|
              |_______________|
              truncated mantissa
</pre>
  </td></tr>
  <tr>
    <td colspan="4"><font size=-1>
      Key: 
        <code>S</code> - sign bit, 
        <code>E</code> - exponent bit, 
        <code>M</code> - mantissa bit, 
        <code>?</code> - padding bit 
      <br>
      Sign bit is included in floating point datatype precision.
      </font></td>
  </tr>
</table>
  
<p>The sign bit and truncated mantissa bits are not changed during 
  datatype conversion by the HDF5 Library. On the other hand,
  the conversion of the 8-bit exponent to a 6-bit exponent
  is a little tricky:
  
<dir>
  The bias for the new exponent in the n-bit datatype is: 
<!--      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;2&#094;(n-1)-1 
-->      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<code>2<sup>(n-1)</sup>-1</code> 
      <br>
  <p>The following formula is used for this exponent conversion:
  
<!--      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;exp8 - (2&#094;(8-1)-1) = exp6 - (2&#094;(6-1)-1) = actual exponent value 
-->
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;
      <code>exp8 - (2<sup>(8-1)</sup>-1)</code> = 
      <code>exp6 - (2<sup>(6-1)</sup>-1)</code> = 
      <i>actual exponent value</i> 

      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      where <code>exp8</code> is the stored decimal value 
      as represented by the 8-bit exponent
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      and <code>exp6</code> is the stored decimal value 
      as represented by the 6-bit exponent
</dir>

<p>In this example, caution must be taken to ensure that, 
  after conversion, the actual exponent value is 
  within the range that can be represented by a 6-bit exponent. 
  For example, 
  an 8-bit exponent can represent values  from -127 to 128 while 
  a 6-bit exponent can represent values only from -31 to 32.
  
<a name="Design">
<h4><em>N-bit filter behavior</em></h4>
</a>

<p>The n-bit filter was designed to treat the incoming data byte by byte at 
  the lowest level. The purpose was to make the n-bit filter as generic as 
  possible so that no pointer cast related to the datatype is needed.

<p>Bitwise operations are employed for packing and unpacking at the byte level.

<p>Recursive function calls are used to treat compound and array datatypes.

<h5><em>N-bit compression</em></h5>

  The main idea of n-bit compression is to use a loop to compress each  
  data element in a chunk. Depending on the datatype of each element, 
  the n-bit filter will call one of four functions.  Each of these functions
  performs one of the following tasks:  

    <ul>
      <li>Compress a data element of a no-op datatype.
      <li>Compress a data element of an atomic datatype.
      <li>Compress a data element of a compound datatype.
      <li>Compress a data element of an array datatype.
    </ul> 


<p><b>No-op datatypes:</b>
  The n-bit filter does not actually compress no-op datatypes.  
  Rather, it copies the data buffer of the no-op datatype from the 
  noncompressed buffer to proper location in the compressed buffer; 
  the compressed buffer has no holes. 
  The term "compress" is used here simply to distinguish this function  
  from the function that performs the reverse operation during decompression.
  

<p><b>Atomic datatypes:</b>
  The n-bit filter will find the bytes where significant bits are 
  located and try to compress these bytes, one byte at a time, using a loop. 
  At this level, the filter needs the following information:
  <ul>
    <li>The byte offset of the beginning of the current data element with 
        respect to the beginning of the input data buffer
    <li>Datatype size, precision, offset, and byte order  
  </ul>

<p>The n-bit filter compresses from the most significant byte containing 
  significant bits to the least significant byte.  
  For big-endian data, therefore, the loop index progresses from smaller
  to larger while for little-endian, the loop index progresses from larger
  to smaller.

<p>In the extreme case, i.e., when the n-bit datatype has full precision,
  this function copies the content of the entire noncompressed datatype 
  to the compressed output buffer.


<p><b>Compound datatypes:</b>
  The n-bit filter will compress each data member of the compound datatype. 
  If the member datatype is of an integer or floating-point datatype, 
  the n-bit filter will call the function described above in section 2.1.2. 
  If the member datatype is of a no-op datatype, 
  the filter will call the function described above in section 2.1.1. 
  If the member datatype is of a compound datatype, the filter will make a 
  recursive call to itself 
  (i.e., to the function described in this section, 2.1.3). 
  If the member datatype is of an array datatype, the filter will call the 
  function described below in section 2.1.4.


<p><b>Array datatypes:</b>
  The n-bit filter will use a loop to compress each array element in 
  the array. If the base datatype of array element is of an integer or 
  floating-point datatype, the n-bit filter will call the function described 
  above in section 2.1.2. 
  If the base datatype is of a no-op datatype, the filter will call the
  function described above in section 2.1.1. 
  If the base datatype is of a compound datatype, the filter will call the
  function described above in section 2.1.3. 
  If the member datatype is of an array datatype, the filter will make a 
  recursive call of itself 
  (i.e., to the function described in this section, 2.1.4).
  
<h5><em>N-bit decompression</em></h5>

<p>The n-bit decompression algorithm is very similar to n-bit compression. 
  The only difference is that at the byte level, compression packs out all 
  padding bits and stores only significant bits into a continous buffer 
  (unsigned char) while decompression unpacks significant bits and inserts 
  padding bits (zeros) at the proper positions to recover the data bytes 
  as they existed before compression.
  
<h5><em>Storing n-bit parameters to array</em> <code>cd_value[]</code></h5>

<p>All of the information, or parameters, required by the n-bit filter 
  are gathered and stored in the array <code>cd_values[]</code> by the 
  private function <code>H5Z_set_local_nbit</code> and are passed 
  to another private function, 
  <code>H5Z_filter_nbit</code>, by the HDF5 Library. 
  
<p>These parameters ar as follows:
  <ol>
    <li>Parameters related to the datatype
    <li>The number of elements within the chunk
    <li>A flag indicating whether compression is needed
  </ol>

<p>The first and second parameters can be obtained using the HDF5 dataspace
  and datatype interface calls. 
  The third parameter is set during the storing process as described 
  in section 3.2.

<p>A compound datatype can have members of array or compound datatype. 
  An array datatype's base datatype can be a complex compound datatype. 
  Recursive calls are required to set parameters for these complex situations.

<p>Before setting the parameters, the number of parameters should be 
  calculated to dynamically allocate the array <code>cd_values[]</code>,
  which will be passed to the HDF5 Library. 
  This also requires recursive calls.
  
<p>For an atomic datatype (integer or floating-point), parameters to store 
  include the datatype's size, endianness, precision, and offset. 
  
<p>For a no-op datatype, only the size is required.

<p>For a compound datatype, parameters to store include the datatype's
  total size and number of members. 
  For each member, its member offset needs to be stored. 
  Other paramters for members will depends on the respective datatype class.

<p>For an array datatype, parameters to store include total size. 
  Other paramters for the array's base type depend on the base type's 
  datatype class. 
  
<p>Further, to correctly retrieve the parameter for use of n-bit 
  compression or decompression later, parameters for distinguishing  
  between datatype classes should be stored.
  
<a name="implementation">
<h4><em>Implementation</em></h4>
</a>

<p>Three filter call-back functions were written for the n-bit filter:
  <br><code>&nbsp;&nbsp;&nbsp;&nbsp;H5Z_can_apply_nbit</code>
  <br><code>&nbsp;&nbsp;&nbsp;&nbsp;H5Z_set_local_nbit</code>
  <br><code>&nbsp;&nbsp;&nbsp;&nbsp;H5Z_filter_nbit</code> 
  <br>These functions are called internally by the HDF5 library. 
  A number of utility functions were written for the function 
  <code>H5Z_set_local_nbit</code>. Compression and decompression functions 
  were written and are called by function <code>H5Z_filter_nbit</code>. 
  All these functions are included in the file <code>H5Znbit.c</code>.

<p>The public function<code>H5Pset_nbit</code> is called by 
  the application to sett up the use of the n-bit filter [2]. 
  This function is included in the file <code>H5Pdcpl.c</code>. 
  The application does not need to supply any parameters.
  
<h5><em>How n-bit parameters are stored</em></h5>

<p>A scheme of storing parameters required by the n-bit filter in the 
  array <code>cd_values[]</code> was developed utilizing recursive 
  function calls.


<p>Four private utility functions were written for storing the paramters 
  associated with atomic (integer or floating-point), no-op, array, and 
  compound datatypes:
  <br><code>&nbsp;&nbsp;&nbsp;&nbsp;H5Z_set_parms_atomic</code>
  <br><code>&nbsp;&nbsp;&nbsp;&nbsp;H5Z_set_parms_array</code>
  <br><code>&nbsp;&nbsp;&nbsp;&nbsp;H5Z_set_parms_nooptype</code>
  <br><code>&nbsp;&nbsp;&nbsp;&nbsp;H5Z_set_parms_compound</code> 

<!-- NEW PAGE -->
<p>The scheme is briefly described below.

<dir>

  First assign a numeric code for datatype class atomic (integer or float), 
  no-op, array, and compound datatype. The code is stored before other 
  datatype related parameters are stored.
  
<dl>
  <dd>
  <dt>The first three parameters of <code>cd_values[]</code> are reserved for:
    <ol>
      <li>Number of valid entries in the array <code>cd_values[]</code>
      <li>A flag indicating whether compression is needed
      <li>The number of elements in the chunk
    </ol>
  
    
  <dt>Throughout the balance of this explanation, 
    <code>i</code> represents the index of <code>cd_values[]</code>.
    <br>&nbsp;

  <dt>In the function <code>H5Z_set_local_nbit</code>:
  <dd>
      <ol>
        <li><code>i</code> = 2
        <li>Get number of elements in the chunk and store in
          <code>cd_value[i]</code>; increment <code>i</code>.
        <li>Get class of datatype:
          <br>&nbsp;&nbsp;If integer or floating-point datatype, call 
          <code>H5Z_set_parms_atomic</code>.
          <br>&nbsp;&nbsp;If array datatype, call 
            <code>H5Z_set_parms_array</code>.
          <br>&nbsp;&nbsp;If compound datatype, call 
            <code>H5Z_set_parms_compound</code>.
          <br>&nbsp;&nbsp;If none of the above, call 
            <code>H5Z_set_parms_noopdatatype</code>.
        <li>Store <code>i</code> in <code>cd_value[0]</code> and 
          flag in <code>cd_values[1]</code>.
      </ol>
  </dd>
</dl>

<dl>
  <dt>In the function <code>H5Z_set_parms_atomic</code>:</dt>
    <dd>
      <ol>
        <li>Store code for atomic datatype in 
          <code>cd_value[i]</code>; increment <code>i</code>.
        <li>Get size of atomic datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code>.
        <li>Get order of atomic datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code>.
        <li>Get precision of atomic datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code>.
        <li>Get offset of atomic datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code>.
        <li>Determine need to do compression at this point.
      </ol>
  </dd>
</dl>

<dl>
  <dt>In the function <code>H5Z_set_parms_nooptype</code>:
  <dd>
      <ol>
        <li>Store code for no-op datatype in 
          <code>cd_value[i]</code>; increment <code>i</code>.
        <li>Get size of no-op datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code>.
      </ol>
  </dd>
</dl>

<dl>
  <dt>In the function <code>H5Z_set_parms_array</code>:
  <dd>
      <ol>
        <li>Store code for array datatype in 
          <code>cd_value[i]</code>; increment <code>i</code>.
        <li>Get size of array datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code>.
        <li>Get class of array's base datatype.
          <br>&nbsp;&nbsp;If integer or floating-point datatype, 
            call <code>H5Z_set_parms_atomic</code>.
          <br>&nbsp;&nbsp;If array datatype, call 
            <code>H5Z_set_parms_array</code>.
          <br>&nbsp;&nbsp;If compound datatype, call 
            <code>H5Z_set_parms_compound</code>.
          <br>&nbsp;&nbsp;If none of the above, 
            call <code>H5Z_set_parms_noopdatatype</code>.
      </ol>
  </dd>
</dl>

<dl>
  <dt>In the function <code>H5Z_set_parms_compound</code>:
  <dd>
      <ol>
        <li>Store code for compound datatype in 
          <code>cd_value[i]</code>; increment <code>i</code>.
        <li>Get size of compound datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code>.
        <li>Get number of members and store in 
          <code>cd_values[i]</code>; increment <code>i</code>.
        <li>For each member
          <br>&nbsp;&nbsp;Get member offset and store in 
            <code>cd_values[i]</code>; increment <code>i</code>.
          <br>&nbsp;&nbsp;Get class of member datatype.
          <br>&nbsp;&nbsp;If integer or floating-point datatype, 
            call <code>H5Z_set_parms_atomic</code>.
          <br>&nbsp;&nbsp;If array datatype, 
            call <code>H5Z_set_parms_array</code>.
          <br>&nbsp;&nbsp;If compound datatype, 
            call <code>H5Z_set_parms_compound</code>.
          <br>&nbsp;&nbsp;If none of the above, 
            call <code>H5Z_set_parms_noopdatatype</code>.
      </ol>
  </dd>
</dl>

</dir>

<h5><em>N-bit compression and decompression functions</em></h5>

<p>The n-bit compression and decompression functions above are called 
  by the private HDF5 function <code>H5Z_filter_nbit</code>. 
  The compress and decompress functions retrieve the n-bit parameters
  from <code>cd_values[]</code> as it was passed by
  <code>H5Z_filter_nbit</code>. Parameters are retrieved in exactly the 
  same order in which they are stored and lower-level compression and 
  decompression functions for different datatype classes are called. 
  These functions are implementated according to the descriptions 
  in sections 2.1 and 2.2.
  
<p>N-bit compression is not implemented in place. Due to the 
  difficulty of calculating actual output buffer size after compression, 
  the same space as that of the input buffer is allocated for the output 
  buffer as passed to the compression function. However, the size of the 
  output buffer passed by reference to the compression function will 
  be changed (smaller) after the compression is complete.
  
<a name="examples">
<h4><em>Usage Examples</em></h4>
</a>

<p>The following code example illustrates the use of the n-bit filter 
  for writing and reading n-bit integer data.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">

<pre>
#include "hdf5.h"
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#define H5FILE_NAME  "nbit_test_int.h5"
#define DATASET_NAME "nbit_int"
#define NX 200
#define NY 300
#define CH_NX 10
#define CH_NY 15

int main(void)
{
   hid_t   file, dataspace, dataset, datatype, mem_datatype, properties;
   hsize_t dims[2], chunk_size[2];
   int     orig_data[NX][NY];
   int     new_data[NX][NY];
   int     i, j;
   size_t  precision, offset;


   /* Define dataset datatype (integer), and set precision, offset */
   datatype = H5Tcopy(H5T_NATIVE_INT);
   precision = 17; /* precision includes sign bit */
   if(H5Tset_precision(datatype,precision)&lt;0) {
      printf("Error: fail to set precision\n");
      return -1;
   }
   offset = 4;
   if(H5Tset_offset(datatype,offset)&lt;0) {
      printf("Error: fail to set offset\n");
      return -1;
   }


   /* Copy to memory datatype */
   mem_datatype = H5Tcopy(datatype);


   /* Set order of dataset datatype */
   if(H5Tset_order(datatype, H5T_ORDER_BE)&lt;0) {
      printf("Error: fail to set endianness\n");
      return -1;
   }


  /* Initiliaze data buffer with random data within correct range
   * corresponding to the memory datatype's precision and offset.
   */
   for (i=0; i &lt; NX; i++)
       for (j=0; j &lt; NY; j++)
           orig_data[i][j] = rand() % (int)pow(2, precision-1) &lt;&lt;offset;


   /* Describe the size of the array. */
   dims[0] = NX;
   dims[1] = NY;
   if((dataspace = H5Screate_simple (2, dims, NULL))&lt;0) {
      printf("Error: fail to create data space\n");
      return -1;
   }


  /*
   * Create a new file using read/write access, default file
   * creation properties, and default file access properties.
   */
   if((file = H5Fcreate (H5FILE_NAME, H5F_ACC_TRUNC,
                         H5P_DEFAULT, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create file\n");
      return -1;
   }


  /*
   * Set the dataset creation property list to specify that
   * the raw data is to be partitioned into 10x15 element
   * chunks and that each chunk is to be compressed.
   */
   chunk_size[0] = CH_NX;
   chunk_size[1] = CH_NY;
   if((properties = H5Pcreate (H5P_DATASET_CREATE))&lt;0) {
      printf("Error: fail to create dataset property\n");
      return -1;
   }
   if(H5Pset_chunk (properties, 2, chunk_size)&lt;0) {
      printf("Error: fail to set chunk\n");
      return -1;
   }


</pre><!-- NEW PAGE -->
<pre>
  /*
   * Set parameters for n-bit compression; check the description of
   * the H5Pset_nbit function in the HDF5 Reference Manual for more
   * information.
   */
   if(H5Pset_nbit (properties)&lt;0) {
      printf("Error: fail to set nbit filter\n");
      return -1;
   }


  /*
   * Create a new dataset within the file.  The datatype
   * and data space describe the data on disk, which may
   * be different from the format used in the application's
   * memory.
   */
   if((dataset = H5Dcreate (file, DATASET_NAME, datatype,
                            dataspace, properties))&lt;0) {
      printf("Error: fail to create dataset\n");
      return -1;
   }


  /*
   * Write the array to the file. The datatype and dataspace
   * describe the format of the data in the 'orig_data' buffer.
   * The raw data is translated to the format required on disk,
   * as defined above. We use default raw data transfer properties.
   */
   if(H5Dwrite (dataset, mem_datatype, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, orig_data)&lt;0) {
      printf("Error: fail to write to dataset\n");
      return -1;
   }


   H5Dclose (dataset);


   if((dataset = H5Dopen(file, DATASET_NAME))&lt;0) {
      printf("Error: fail to open dataset\n");
      return -1;
   }


  /*
   * Read the array. This is similar to writing data,
   * except the data flows in the opposite direction.
   * Note: Decompression is automatic.
   */
   if(H5Dread (dataset, mem_datatype, H5S_ALL, H5S_ALL,
               H5P_DEFAULT, new_data)&lt;0) {
      printf("Error: fail to read from dataset\n");
      return -1;
   }


</pre><!-- NEW PAGE -->
<pre>
   H5Tclose (datatype);
   H5Tclose (mem_datatype);
   H5Dclose (dataset);
   H5Sclose (dataspace);
   H5Pclose (properties);
   H5Fclose (file);


   return 0;
}
</pre>
    </td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
    <span class=figurenumber>Example 1, n-bit compression:</span> 
         illustrating use of the n-bit filter for writing and reading 
         n-bit integer data.</td>
  </tr>
</table>


<br><!-- NEW PAGE -->
<p>The following code example illustrates the use of the n-bit filter 
  for writing and reading n-bit floating-point data.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
<pre>
#include "hdf5.h"
#define H5FILE_NAME  "nbit_test_float.h5"
#define DATASET_NAME "nbit_float"
#define NX 2
#define NY 5
#define CH_NX 2
#define CH_NY 5


int main(void)
{
   hid_t   file, dataspace, dataset, datatype, properties;
   hsize_t dims[2], chunk_size[2];
  /* orig_data[] are initialized to be within the range that can be
   * represented by dataset datatype (no precision loss during
   * datatype conversion)
   */
   float   orig_data[NX][NY] = {{188384.00, 19.103516, -1.0831790e9,
   -84.242188, 5.2045898}, {-49140.000, 2350.2500, -3.2110596e-1,
   6.4998865e-5, -0.0000000}};
   float   new_data[NX][NY];
   size_t  precision, offset;


  /* Define single-precision floating-point type for dataset
   *-------------------------------------------------------------------
   * size=4 byte, precision=20 bits, offset=7 bits,
   * mantissa size=13 bits, mantissa position=7,
   * exponent size=6 bits, exponent position=20,
   * exponent bias=31.
   * It can be illustrated in little-endian order as:
   * (S - sign bit, E - exponent bit, M - mantissa bit,
   *  ? - padding bit)
   *
   *           3        2        1        0
   *       ?????SEE EEEEMMMM MMMMMMMM M???????
   *
   * To create a new floating-point type, the following
   * properties must be set in the order of
   *     set fields -> set offset -> set precision -> set size.
   * All these properties must be set before the type can function.
   * Other properties can be set anytime. Derived type size cannot
   * be expanded bigger than original size but can be decreased.
   * There should be no holes among the significant bits. Exponent
   * bias usually is set 2^(n-1)-1, where n is the exponent size [3].


*-------------------------------------------------------------------*/
   datatype = H5Tcopy(H5T_IEEE_F32BE);
   if(H5Tset_fields(datatype, 26, 20, 6, 7, 13)&lt;0) {
      printf("Error: fail to set fields\n");
      return -1;
   }
   offset = 7;
   if(H5Tset_offset(datatype,offset)&lt;0) {
      printf("Error: fail to set offset\n");
      return -1;
   }
   precision = 20;
   if(H5Tset_precision(datatype,precision)&lt;0) {
      printf("Error: fail to set precision\n");
      return -1;
   }
   if(H5Tset_size(datatype, 4)&lt;0) {
      printf("Error: fail to set size\n");
      return -1;
   }
   if(H5Tset_ebias(datatype, 31)&lt;0) {
      printf("Error: fail to set exponent bias\n");
      return -1;
   }


   /* Describe the size of the array. */
   dims[0] = NX;
   dims[1] = NY;
   if((dataspace = H5Screate_simple (2, dims, NULL))&lt;0) {
      printf("Error: fail to create data space\n");
      return -1;
   }


  /*
   * Create a new file using read/write access, default file
   * creation properties, and default file access properties.
   */
   if((file = H5Fcreate (H5FILE_NAME, H5F_ACC_TRUNC,
                         H5P_DEFAULT, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create file\n");
      return -1;
   }


  /*
   * Set the dataset creation property list to specify that
   * the raw data is to be partitioned into 2x5 element
   * chunks and that each chunk is to be compressed.
   */
   chunk_size[0] = CH_NX;
   chunk_size[1] = CH_NY;
   if((properties = H5Pcreate (H5P_DATASET_CREATE))&lt;0) {
      printf("Error: fail to create dataset property\n");
      return -1;
   }
   if(H5Pset_chunk (properties, 2, chunk_size)&lt;0) {
      printf("Error: fail to set chunk\n");
      return -1;
   }


  /*
   * Set parameters for n-bit compression; check the description
   * of the H5Pset_nbit function in the HDF5 Reference Manual
   * for more information.
   */
   if(H5Pset_nbit (properties)&lt;0) {
      printf("Error: fail to set nbit filter\n");
      return -1;
   }


  /*
   * Create a new dataset within the file.  The datatype
   * and data space describe the data on disk, which may
   * be different from the format used in the application's
   * memory.
   */
   if((dataset = H5Dcreate (file, DATASET_NAME, datatype,
                            dataspace, properties))&lt;0) {
      printf("Error: fail to create dataset\n");
      return -1;
   }


  /*
   * Write the array to the file. The datatype and dataspace
   * describe the format of the data in the 'orig_data' buffer.
   * The raw data is translated to the format required on disk,
   * as defined above. We use default raw data transfer properties.
   */
   if(H5Dwrite (dataset, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, orig_data)&lt;0) {
      printf("Error: fail to write to dataset\n");
      return -1;
   }


   H5Dclose (dataset);


   if((dataset = H5Dopen(file, DATASET_NAME))&lt;0) {
      printf("Error: fail to open dataset\n");
      return -1;
   }


  /*
   * Read the array. This is similar to writing data,
   * except the data flows in the opposite direction.
   * Note: Decompression is automatic.
   */
   if(H5Dread (dataset, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
               H5P_DEFAULT, new_data)&lt;0) {
      printf("Error: fail to read from dataset\n");
      return -1;
   }


   H5Tclose (datatype);
   H5Dclose (dataset);
   H5Sclose (dataspace);
   H5Pclose (properties);
   H5Fclose (file);


   return 0;
}
</pre>
    </td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
    <span class=figurenumber>Example 2, n-bit compression:</span> 
          illustrating the use of the n-bit filter for writing and reading 
          n-bit floating-point data.</td>
  </tr>
</table>

<a name="limitations">
<h4><em>Limitations</em></h4>
</a>

<p>Because the array <code>cd_values[]</code> has to fit into an object 
  header message of 64K, the n-bit filter has an uppper limit on the number 
  of n-bit paramters that can be stored in it. To be conservative, a maximum 
  of 4K is allowed for the number of parameters.

<p>The n-bit filter currently only compresses n-bit dataypes or fields derived 
  from integer or floating-point datatypes. The n-bit filter assumes padding 
  bits of zero. This may not be true since the HDF5 user can set padding bit 
  to be zero, one, or leave the background alone. However, it is expected 
  the n-bit filter will be modified to adjust to such situations.

<p>The n-bit filter does not have a way to handle the situation where the  
  fill value of a dataset is defined and the fill value is not of an n-bit 
  datatype although the dataset datatype is.





<!-- NEW PAGE -->
<a name="ScaleOffset">
<h3>6.2. Scale-offset Filter</h3>
</a> 

<p>Generally speaking, scale-offset compression performs a scale and/or 
  offset operation on each data value and truncates the resulting value 
  to a minimum number of bits (minimum-bits) before storing it [1]. 

<p>The current scale-offset filter supports integer and floating-point 
  datatype only. For floating-point datatype, float and double are supported 
  while long double is not supported.

<p>Integer data compression uses a straight-forward algorithm. Floating-point 
  data compression adopts the GRiB data packing mechanism [2], which offers 
  two alternate methods: a fixed minimum-bits method, and a variable 
  minimum-bits method. Currently, only the variable minimum-bits method 
  is implemented.

<p>Like other I/O filters supported by the HDF5 library, application 
  using the scale-offset filter must store data with chunked storage.
  
<p>
<b><i>Integer type:</i></b>
  The minimum-bits of integer data can be determined by the filter. 
  For example, if the maximum value of data to be compressed is 7065 
  and the minimum value is 2970. Then the "span" of dataset values is 
  equal to(max-min+1),which is 4676. If no fill value is defined for the 
  dataset, the minimum-bits is: ceiling(log2(span)) = 12. With fill 
  value set, the minimum-bits is: ceiling(log2(span+1)) = 13[1].

<p>HDF5 user can also set the minimum-bits. However, if the user gives 
  a minimum-bits that is less than that calculated by the filter, 
  the compression will be lossy.

<p>
<b><i>Floating-point type</i></b>
  The basic idea of scaleoffset filter for floating-point type is 
  to transform the data by some kind of scaling to integer data and 
  then follow the procedure of scaleoffset filter for integer type to 
  do the data compression. Due to the data transformation from 
  floating-point to integer, the scaleoffset filter is 
  lossy in nature. 

<p>Two methods of scaling the floating-point data are used, the so-called 
  D-scaling and E-scaling. D-scaling is more straightforward and easy to 
  understand. For HDF5 1.8 release, only D-scaling method is implemented. 
  More information about D-scaling and E-scaling can be found from [2].
  
<h4><em>Design</em></h4>

<p>Before the filter does any real work, it needs to gather some information 
  from the HDF5 library through API calls. The parameters the filter needs 
  are: Minimum-bits of the data value, number of data elements in the chunk, 
  datatype class, size, sign (only for integer type), byte order, fill value 
  if defined. Size and sign are needed to determine what kind of pointer cast 
  to use when retrieving values from data buffer.

<p>The pipeline of filter can be divided into four parts: (1)pre-compression; 
  (2)compression; (3)decompression; (4)post-decompression.

<p>Depending on whether fill value is defined or not, the filter will handle 
  pre-compression and post-decompression differently. 

<p>The scaleoffset filter only needs the memory byte order, size of datatype, 
  and minimum-bits for compression and decompression.

<p>Since decompression has no access to the original data, the minimum-bits 
  and the minimum value need to be stored with the compressed data for 
  decompression and post-decompression.
  
<h5><em>Integer type</em></h5>

<h6><em>Pre-compression</em></h6>

<p>During pre-compression Minimum-bits is calculated if it is not 
  set by the user. Calculation of Minimum-bits has already been 
  illustrated in section 1. 
 
<p>If fill value is defined, finding of maximum and minimum value 
  should ignore the data element whose value is equal to the fill value. 

<p>If no fill value is defined, value of each data element is subtracted 
  by minimum value during this stage.

<p>If fill value is defined, fill value is assigned to the maximum value. 
  In this way minimum-bits can represent data element whose value is equal 
  to the fill value and subtracts the minimum value from data element whose 
  value is not equal to the fill value.

<p>Fill value, if defined, number of elements inside the chunk, class of 
  datatype, size of datatype, memory order of the datatype etc. should be 
  stored into HDF5 object header for the usage of post-decompression.

<p>After pre-compression, all values are non-negative and are within the range 
  that can be store by Minimum-bits.
  
<h6><em>Compression</em></h6>

<p>All modified data values after pre-compression are packed together 
  into the compressed data buffer. The number of bit for each data value 
  decreases from the number of bit of integer (32 for most platforms) to 
  minimum-bits. The value of minimum-bits and minimum-value are added to 
  the data buffer and the whole buffer is sent back to the library. In this 
  way, number of bit for each modified value is no more than 
  the size of minimum-bits.
  
<h6><em>Decompression</em></h6>

<p>In this stage, the number of bit for each data value is resumed from 
  minimum-bits to the number of bit of integer.

<h6><em>Post-decompression</em></h6>

<p>For the stage of the post-decompression the filter does the opposite 
  of what it does during pre-compression except that it does not calculate 
  the minimum-bits or the minimum value. 
 
<p>They have been saved during compression and can be retrieved through 
  the resumed data buffer. If no fill value is defined, the filter adds 
  the minimum value back to each data element.

<p>If fill value is defined, the filter assigns the fill value to data 
  element whose value is equal to the maximum value that minimum-bits can 
  represent and adds the minimum value back to each data element whose value 
  is not equal to the maximum value  that minimum-bits can represent.
  
<h5><em>Floating-point type</em></h5>

<p>The filter will do data transformation from floating-point type to 
  integer type and then handle the data by using the procedure for handling 
  the integer data inside the filter.  
  Since insignificant bits of floating-point data will be cut off 
  during data transformation, so this filter is a lossy compression method.

<p>Two scaling methods are introduced by[2]; namely D-scaling and E-scaling. 
  HDF5 1.8 release only supports D-scaling. In this document, we only 
  introduce D-scaling. E-scaling should be similar conceptually. D-scaling 
  means decimal scaling. In order to transform data from floating-point to 
  integer, a scale factor is introduced. The minimum value will be calculated. 
  Each data element value will subtract the minimum value. The modified data 
  will be multiplied by 10(Decimal) to the power of <code>scale_factor</code> 
  and only the integer part will be kept and manipulated through the routines 
  for integer type of the filter during the pre-compression and compression. 
  The integer data will be divided by 10 to the power of 
  <code>scale_factor</code> to transform back to the floating-point data 
  during the decompression and post-decompression.  
  Each data element value will then add the minimum value and the 
  floating-data are resumed. However, the resumed data will lose some 
  insignificant bits compared with the original value.

<p>For example, the following floating point data are manipulated by the 
  filter, the D-scaling factor is 2.
  
<p>{104.561, 99.459, 100.545, 105.644}

<p>The minimum value is 99.459, each data element subtracts 99.459, the 
  modified data is {5.102, 0, 1.086, 6.185}

<p>Since D-scaling factor is 2, all floating-point data will be 
  multiplied by 10^2,

<p>{510.2, 0, 108.6, 618.5}

<p>The digit after decimal point will be rounded off. The set looks like: 
  {510 , 0, 109, 619}

<p>After decompression, each value will be divided by 10^2 and add 
  the offset 99.459,

<p>The floating point data becomes {104.559, 99.459, 100.549, 105.649}

<p>The relative error for each value should be no more than 
  5* (10^(D-scaling factor +1)). D-scaling sometimes is also refered 
  as variable Minimum-bits method since for different datasets the 
  minimum-bits to represent the same decimal precision will vary. The 
  Data value is modified to 2 to power <code>scale_factor</code> of for 
  E-scaling. E-scaling is also called fixed-bits method since for different 
  datasets the minimum-bits will always be fixed to the scale factor of 
  E-scaling. 
  Currently HDF5 ONLY supports D-scaling(variable Minimum-bits) method.
  
<h4><em>Implementation</em></h4>

<p>The scale-offset filter implementation was written and included in the file 
  <code>H5Zscaleoffset.c</code>. Function <code>H5Pset_scaleoffset</code> was 
  written and included in the file "<code>H5Pdcpl.c</code>". The HDF5 user can 
  supply minimum-bits by calling function <code>H5Pset_scaleoffset</code> [3].

<!-- NEW PAGE -->
<p>The scale-offset filter was implemented based on the design outlined in 
  section 2. However, the following factors need to be considered:
  
<dl>
  <dd>
    <ol>
      <li>The filter needs the appropriate cast pointer whenever it needs 
        to retrieve data values.
      <li>The HDF5 library passes to the filter the to-be-compressed data 
        in format of dataset datatype and the filter passes back the 
        decompressed data in the same format. If fill value is defined, 
        it is also in dataset datatype format. 
        For example, if byte order of dataset datatype is different 
        from that of the memory datatype of the platform compression or 
        decompression performs, endianness conversion of data buffer is needed. 
        Moreover, it should be aware that memory byte order can be different 
        during compression and decompression.
      <li>The difference of endianness and datatype between file and memory 
        should be considered when saving and retrieval of minimum-bits, 
        minimum value, and fill value.
      <li>If the user sets the minimum-bits to full precision of the datatype, 
        no operation is needed at the filter side. If the full precision is 
        a result of calculation by the filter, then the minimum-bits needs 
        to be saved for decompression but no compression or decompression 
        is needed (only copy of the input buffer is needed).
      <li>If by calculation of the filter, the minimum-bits is equal to zero, 
        special handling is needed. Since it means all values are the same, 
        no compression or decompression is needed. But the minimum-bits 
        and minimum value still need to be saved during compression.
      <li>For floating-point data, the minimum value of the dataset should 
        be calculated at first. Each data element value will then subtract 
        the minimum value to obtain the "offset" data. 
        The offset data will then follow 2.2 <strong>(3.1.2??)</strong> 
        to do data transformation to integer and rounding.
    </ol>
  </dd>
</dl>

<h4><em>Usage Examples</em></h4>

<p>The following code example illustrates the use of the scale-offset filter 
  for writing and reading integer data.</p>

<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
<pre>
#include "hdf5.h"
#include &lt;stdlib.h&gt;
#define H5FILE_NAME  "scaleoffset_test_int.h5"
#define DATASET_NAME "scaleoffset_int"
#define NX 200
#define NY 300
#define CH_NX 10
#define CH_NY 15
</pre>

<pre>
int main(void)
{
   hid_t   file, dataspace, dataset, datatype, properties;
   hsize_t dims[2], chunk_size[2];
   int     orig_data[NX][NY];
   int     new_data[NX][NY];   
   int     i, j, fill_val;   

   /* Define dataset datatype */
   datatype = H5Tcopy(H5T_NATIVE_INT);   
   
   /* Initiliaze data buffer */
   for (i=0; i &lt; NX; i++) 
       for (j=0; j &lt; NY; j++)
           orig_data[i][j] = rand() % 10000;

   /* Describe the size of the array. */
   dims[0] = NX;
   dims[1] = NY;
   if((dataspace = H5Screate_simple (2, dims, NULL))&lt;0) {
      printf("Error: fail to create data space\n");
      return -1;
   }

  /*
   * Create a new file using read/write access, default file
   * creation properties, and default file access properties.
   */
   if((file = H5Fcreate (H5FILE_NAME, H5F_ACC_TRUNC, 
                         H5P_DEFAULT, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create file\n");
      return -1;
   }

  /*
   * Set the dataset creation property list to specify that
   * the raw data is to be partitioned into 10x15 element
   * chunks and that each chunk is to be compressed.
   */
   chunk_size[0] = CH_NX;
   chunk_size[1] = CH_NY;
   if((properties = H5Pcreate (H5P_DATASET_CREATE))&lt;0) {
      printf("Error: fail to create dataset property\n");
      return -1;
   }
   if(H5Pset_chunk (properties, 2, chunk_size)&lt;0) {
      printf("Error: fail to set chunk\n");
      return -1;
   }

   /* Set the fill value of dataset */
   fill_val = 10000;
   if (H5Pset_fill_value(properties, H5T_NATIVE_INT, 
       &fill_val)&lt;0) {
      printf("Error: can not set fill value for dataset\n");
      return -1;
   }

  /*
   * Set parameters for scale-offset compression. Check the 
   * description of the H5Pset_scaleoffset function in the 
   * HDF5 Reference Manual for more information [3].
   */
   if(H5Pset_scaleoffset (properties, H5_SO_INT, 
                          H5_SO_INT_MINIMUMBITS_DEFAULT)&lt;0) {
      printf("Error: fail to set scaleoffset filter\n");
      return -1;
   }

  /*
   * Create a new dataset within the file. The datatype
   * and data space describe the data on disk, which may
   * or may not be different from the format used in the 
   * application's memory.
   */
   if((dataset = H5Dcreate (file, DATASET_NAME, datatype,
                            dataspace, properties))&lt;0) {
      printf("Error: fail to create dataset\n");
      return -1;
   }

  /*
   * Write the array to the file. The datatype and dataspace
   * describe the format of the data in the 'orig_data' buffer.
   * We use default raw data transfer properties.
   */
   if(H5Dwrite (dataset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, orig_data)&lt;0) {
      printf("Error: fail to write to dataset\n");
      return -1;
   }

   H5Dclose (dataset);

   if((dataset = H5Dopen(file, DATASET_NAME))&lt;0) {
      printf("Error: fail to open dataset\n");
      return -1;
   }   

  /*
   * Read the array. This is similar to writing data,
   * except the data flows in the opposite direction.
   * Note: Decompression is automatic.
   */
   if(H5Dread (dataset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL,
               H5P_DEFAULT, new_data)&lt;0) {
      printf("Error: fail to read from dataset\n");
      return -1;
   }

   H5Tclose (datatype);
   H5Dclose (dataset);
   H5Sclose (dataspace);
   H5Pclose (properties);
   H5Fclose (file);

   return 0;
}
</pre>
    </td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
    <span class=figurenumber>Example 3, scale-offset compression:</span>
          illustrating the use of the scale-offset filter for writing 
          and reading integer data</td>
  </tr>
</table>

<br><!-- NEW PAGE -->
<p>The following code example illustrates the use of the scale-offset filter 
  (set for variable minimum-bits method) 
  for writing and reading floating-point data.</p>
  
<table x-use-null-cells
		width=600
		cellspacing=0
                class="fullImgTable"
		align="center">
  <tr valign=top> 
    <td class="fullImgTableImgCell">
<pre>
#include "hdf5.h"
#include &lt;stdlib.h&gt;
#define H5FILE_NAME  "scaleoffset_test_float_Dscale.h5"
#define DATASET_NAME "scaleoffset_float_Dscale"
#define NX 200
#define NY 300
#define CH_NX 10
#define CH_NY 15
</pre>

<pre>
int main(void)
{
   hid_t   file, dataspace, dataset, datatype, properties;
   hsize_t dims[2], chunk_size[2];
   float   orig_data[NX][NY];
   float   new_data[NX][NY];
   float   fill_val;   
   int     i, j;   

   /* Define dataset datatype */
   datatype = H5Tcopy(H5T_NATIVE_FLOAT);   
   
   /* Initiliaze data buffer */
   for (i=0; i < NX; i++) 
       for (j=0; j < NY; j++)
           orig_data[i][j] = (rand() % 10000) / 1000.0;

   /* Describe the size of the array. */
   dims[0] = NX;
   dims[1] = NY;
   if((dataspace = H5Screate_simple (2, dims, NULL))&lt;0) {
      printf("Error: fail to create data space\n");
      return -1;
   }

  /*
   * Create a new file using read/write access, default file
   * creation properties, and default file access properties.
   */
   if((file = H5Fcreate (H5FILE_NAME, H5F_ACC_TRUNC, 
                         H5P_DEFAULT, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create file\n");
      return -1;
   }

  /*
   * Set the dataset creation property list to specify that
   * the raw data is to be partitioned into 10x15 element
   * chunks and that each chunk is to be compressed.
   */
   chunk_size[0] = CH_NX;
   chunk_size[1] = CH_NY;
   if((properties = H5Pcreate (H5P_DATASET_CREATE))&lt;0) {
      printf("Error: fail to create dataset property\n");
      return -1;
   }
   if(H5Pset_chunk (properties, 2, chunk_size)&lt;0) {
      printf("Error: fail to set chunk\n");
      return -1;
   }

   /* Set the fill value of dataset */
   fill_val = 10000.0;
   if (H5Pset_fill_value(properties, H5T_NATIVE_FLOAT, 
       &fill_val)<0) {
      printf("Error: can not set fill value for dataset\n");
      return -1;
   }

  /*
   * Set parameters for scale-offset compression; use varialbe
   * minimum-bits method, set decimal scale factor to 3. Check the 
   * description of the H5Pset_scaleoffset function in the HDF5 
   * Reference Manual for more information [3].
   */
   if(H5Pset_scaleoffset (properties, 3, H5_SO_FLOAT_DSCALE)&lt;0) {
      printf("Error: fail to set scaleoffset filter\n");
      return -1;
   }

  /*
   * Create a new dataset within the file. The datatype
   * and data space describe the data on disk, which may
   * or may not be different from the format used in the 
   * application's memory.
   */
   if((dataset = H5Dcreate (file, DATASET_NAME, datatype,
                            dataspace, properties))&lt;0) {
      printf("Error: fail to create dataset\n");
      return -1;
   }

  /*
   * Write the array to the file. The datatype and dataspace
   * describe the format of the data in the 'orig_data' buffer.
   * We use default raw data transfer properties.
   */
   if(H5Dwrite (dataset, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, orig_data)&lt;0) {
      printf("Error: fail to write to dataset\n");
      return -1;
   }

   H5Dclose (dataset);

   if((dataset = H5Dopen(file, DATASET_NAME))&lt;0) {
      printf("Error: fail to open dataset\n");
      return -1;
   }   

  /*
   * Read the array. This is similar to writing data,
   * except the data flows in the opposite direction.
   * Note: Decompression is automatic.
   */
   if(H5Dread (dataset, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
               H5P_DEFAULT, new_data)&lt;0) {
      printf("Error: fail to read from dataset\n");
      return -1;
   }

   H5Tclose (datatype);
   H5Dclose (dataset);
   H5Sclose (dataspace);
   H5Pclose (properties);
   H5Fclose (file);

   return 0;
}
</pre>
    </td>
  </tr>
  <tr> 
    <td align=center class="fullImgTableCapCell"> 
    <span class=figurenumber>Example 4, scale-offset compression:</span>
          illustrating the use of the scale-offset filter for writing 
          and reading floating-point data</td>
  </tr>
</table>

<h4><em>Limitations</em></h4>

<p>For floating-point data handling, there are some algorithmic 
  limitations to the GRiB data packing mechanism:

<dl>
  <dd>
    <ol>
      <li>Both E-scaling and D-scaling method are lossy compression.
      <li>For D-scaling method, since data values have been rounded to 
        integer values (positive) before truncating to the minimum-bits, 
        their range is limited by the maximum value that can be represented 
        by the corresponding unsigned integer type (same size with that of 
        floating-point type).
    </ol>
  </dd>
</dl>

<h4><em>Suggestions</em></h4>

<p>Some suggestions for using the filter for floating-point data:

<dl>
  <dd>
    <ol>
      <li>It is better to convert the units of data so that it is 
        within certain common range (e.g. 1200m to 1.2km).
      <li>If data values to be compressed are very near to zero, it 
        is strongly recommended that the user sets the fill value away 
        from zero (e.g. a large positive number) because if the user does 
        nothing the HDF5 library will set the fill value to zero, which 
        may cause the compression not as desirable.
      <li>Users are not encouraged to use a very large decimal scale 
        factor (e.g. 100) for the D-scaling method. This can cause the 
        filter not to ignore fill value when finding maximum and minimum 
        values, and get a much larger minimum-bits (poor compression).
    </ol>
  </dd>
</dl>



  

<a name="Szip">
<h3>6.3. Using the Szip Filter</h3>
</a>

  <p>See The HDF Group website for 
  <a href="http://www.hdfgroup.org/doc_resource/SZIP/" target="Ext1">further 
  information</a> regarding the Szip filter.

<p>&nbsp;
<p>&nbsp;





<!-- HEADER RIGHT " " -->

</body>
</html>

  
