<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<head>
<title>Chapter 5: HDF5 Datasets</title>

<!--(Meta)==========================================================-->

<!--(Links)=========================================================-->

<!--( Begin styles definition )=====================================-->
<link href="ed_styles/NewUGelect.css" rel="stylesheet" type="text/css">
<!--( End styles definition )=======================================-->

</head> 

<body>

<!-- #BeginLibraryItem "/ed_libs/styles_UG.lbi" -->
<!--
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  * Copyright by The HDF Group.                                               *
  * Copyright by the Board of Trustees of the University of Illinois.         *
  * All rights reserved.                                                      *
  *                                                                           *
  * This file is part of HDF5.  The full HDF5 copyright notice, including     *
  * terms governing use, modification, and redistribution, is contained in    *
  * the files COPYING and Copyright.html.  COPYING can be found at the root   *
  * of the source code distribution tree; Copyright.html can be found at the  *
  * root level of an installed copy of the electronic HDF5 document set and   *
  * is linked from the top-level documents page.  It can also be found at     *
  * http://www.hdfgroup.org/HDF5/doc/Copyright.html.  If you do not have      *
  * access to either file, you may request a copy from help@hdfgroup.org.     *
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 -->
<!-- #EndLibraryItem --><!-- HEADER LEFT "HDF5 User's Guide" -->
<!-- HEADER RIGHT "HDF5 Datasets" -->

<!--( TOC )=========================================================-->
<!--<SCRIPT language="JavaScript">-->
<!--
document.writeln ('\
<table x-use-null-cells\
                align=right\
		width=240\
		cellspacing="0"\
		class="tocTable">\
-->
<!-- Table Version 3 --><!-- \ -->
<!--
  <tr valign="top"> \
    <td class="tocTableHeaderCell" colspan="2"> \
        <span class="TableHead">Chapter Contents</span></td>\
  </tr>\
  <tr valign="top"> \
    <td class="tocTableContentCell2"> \
      <a href="#Intro">1.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#Intro">Introduction</a></td> \
  </tr>\
  <tr valign="top"> \
    <td class="tocTableContentCell2"> \
      <a href="#FileFunctSums">2.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#FileFunctSums">Dataset (H5D) Function Summaries</a></td>\
  </tr>\
  <tr valign="top"> \
    <td class="tocTableContentCell2"> \
      <a href="#PModel">3.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#PModel">Programming Model</a></td> \
  </tr>\
  <tr valign="top"> \
    <td class="tocTableContentCell2"> \
      <a href="#DTransfer">4.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#DTransfer">Data Transfer</a></td>\
  </tr>\
  <tr valign="top"> \
    <td class="tocTableContentCell2"> \
      <a href="#Allocation">5.</a></td>\
    <td class="tocTableContentCell3">\
	  <a href="#Allocation">Allocation of Space</a></td>\
  </tr>\
  <tr valign="top"> \
    <td class="tocTableContentCell"> \
      <a href="#UseFilters">6.</a></td>\
    <td class="tocTableContentCell4">\
	  <a href="#UseFilters">Specialized Filters</a>\
          <br>&nbsp;&nbsp;&nbsp;&nbsp;\
	  <a href="#N-Bit">N-bit</a>\
          <br>&nbsp;&nbsp;&nbsp;&nbsp;\
	  <a href="#ScaleOffset">Scale-offset</a></td>\
  </tr>\
  </td></tr>\
</table>\
')
-->
<!--</SCRIPT>-->
<!--(End TOC)=======================================================-->

<!-- editingComment
  <span class="editingComment">[ [ [
  ] ] ]</span>
-->

<!-- editingComment
-->

<div align="center">
<a name="TOP">
<h2>Chapter 5<br><font size="7">HDF5 Datasets</font></h2>
</a>
</div>

<!-- editingComment
  <span class="editingComment">[ [ [
  Original title.  Which is proper?
  <h2>10. Datasets I/O</h2>
  ] ] ]</span>
-->
<br />
<a name="Intro">
<h3>5.1. Introduction</h3>
</a>

  <p>An HDF5 dataset is an object composed of a collection of data elements, 
  or raw data, and metadata that stores a description of the data elements, 
  data layout, and all other information necessary to write, read, and interpret 
  the stored data. From the viewpoint of the application the raw data is stored 
  as a one-dimensional or multi-dimensional array of elements (the <em>raw 
  data</em>), those elements can be any of several numerical or character 
  types, small arrays, or even compound types similar to C structs. The 
  dataset object may have attribute objects. See the figure below.</p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dsets_fig1.JPG">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 1. Application view of a dataset</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<!-- editingComment
  <span class="editingComment">
  <p>Datatypes are described in  [ [ [ "Datatypes" ] ] ]. and in the [ [ [ "HDF5 
  Datatypes" chapter in this guide ] ] ], Dataspace objects are described in 
  [ [ [ Dataspace ] ] ], and Attributes are described in [ [ [ Attributes ] ] ].
  </span>
-->

  <p>A dataset object is stored in a file in two parts: a header and a data 
  array. The header contains information that is needed to interpret the 
  array portion of the dataset, as well as metadata (or pointers to metadata) 
  that describes or annotates the dataset. Header information includes the 
  name of the object, its dimensionality, its number-type, information about 
  how the data itself is stored on disk (the <em>storage layout</em>), and 
  other information used by the library to speed up access to the dataset 
  or maintain the file&rsquo;s integrity. </p>

  <p>The HDF5 dataset interface, comprising the H5D functions, provides a 
  mechanism for managing HDF5 datasets including the transfer of data 
  between memory and disk and the description of dataset properties. </p>

  <p>A dataset is used by other HDF5 APIs, either by name or by an 
  identifier (e.g., returned by <code>H5Dopen</code>).</p>


<h4><em>Link/Unlink</em></h4>

  <p>A dataset can be added to a group with one of the <code>H5Lcreate</code> 
  calls, and deleted from a group with <code>H5Ldelete</code>. The link and 
  unlink operations use the name of an object, which may be a dataset. The 
  dataset does not have to open to be linked or unlinked.</p>

<h4><em>Object reference</em></h4>

  <p>A dataset may be the target of an object reference.  The object 
  reference is created by <code>H5Rcreate</code> with the name of an object 
  which may be a dataset and the reference type <code>H5R_OBJECT</code>. 
  The dataset does not have to be open to create a reference to it.</p>

  <p>An object reference may also refer to a region (selection) of a dataset. 
  The reference is created with <code>H5Rcreate</code> and a reference type of 
  <code>H5R_DATASET_REGION</code>.</p>

  <p>An object reference can be accessed by a call to <code>H5Rdereference</code>. When the 
  reference is to a dataset or dataset region, the <code>H5Rdeference</code> 
  call returns an identifier to the dataset just as if <code>H5Dopen</code> 
  has been called.</p>

<h4><em>Adding attributes</em></h4>

  <p>A dataset may have user-defined attributes which are created with 
  <code>H5Acreate</code> and accessed through the H5A API. To create an 
  attribute for a dataset, the dataset must be open, and the identifier is 
  passed to <code>H5Acreate</code>. The attributes of a dataset are 
  discovered and opened using <code>H5Aopen_name</code>, 
  <code>H5Aopen_idx</code>, or <code>H5Aiterate</code>; these functions 
  use the identifier of the dataset. An attribute can be deleted with 
  <code>H5Adelete</code> which also uses the identifier of the dataset.</p>

<!-- editingComment
  <span class="editingComment">
  <p>The remaining sections of this chapter discuss... [To be written last.]</p>
  </span>
-->

<br>

<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="FileFunctSums">
<div align=right>
<a href="#TOP"><font size="-1">(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<!-- NEW PAGE -->
<a name="FileFunctSums">
<h3 class=pagebefore>5.2. Dataset Function Summaries</h3>
</a>
<p>Functions that can be used with datasets (H5D functions) and property 
list functions that can used with datasets (H5P functions) are listed below.</p>


<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Function Listing 1. Dataset functions (H5D)
        </b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td>
        <b>C Function<br>Fortran Function</b>
        </td><td>&nbsp;</td>
        <td>
        <b>Purpose</b>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Dcreate<br>h5dcreate_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Creates a dataset at the specified location. The C function is a 
        macro: see <a href="../RM/APICompatMacros.html">&ldquo;API 
        Compatibility Macros in HDF5.&rdquo;</a>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Dcreate_anon<br>h5dcreate_anon_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Creates a dataset in a file without linking it into the file structure. 
        </td>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Dopen<br>h5dopen_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Opens an existing dataset. The C function is a 
        macro: see <a href="../RM/APICompatMacros.html">&ldquo;API 
        Compatibility Macros in HDF5.&rdquo;</a>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Dclose<br>h5dclose_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Closes the specified dataset.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Dget_space<br>h5dget_space_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns an identifier for a copy of the dataspace for a dataset.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Dget_space_status<br>h5dget_space_status_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Determines whether space has been allocated for a dataset.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Dget_type<br>h5dget_type_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns an identifier for a copy of the datatype for a dataset.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Dget_create_plist<br>h5dget_create_plist_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns an identifier for a copy of the dataset creation property 
        list for a dataset.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Dget_access_plist<br>(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns the dataset access property list associated with a dataset. 
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Dget_offset<br>h5dget_offset_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns the dataset address in a file.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Dget_storage_size<br>h5dget_storage_size_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns the amount of storage required for a dataset.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Dvlen_get_buf_size<br>h5dvlen_get_max_len_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Determines the number of bytes required to store variable-length (VL) 
        data.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Dvlen_reclaim<br>h5dvlen_reclaim_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Reclaims VL datatype memory buffers.
        </td>
        </tr>
    <!-- NEW PAGE -->
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Dread<br>h5dread_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Reads raw data from a dataset into a buffer.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Dwrite<br>h5dwrite_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Writes raw data from a buffer to a dataset.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Diterate<br>(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Iterates over all selected elements in a dataspace.
        </td>
        </tr>

    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Dgather<br>(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Gathers data from a selection within a memory buffer. 
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Dscatter<br>(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Scatters data into a selection within a memory buffer. 
        </td>
        </tr>

    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Dfill<br>h5dfill_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Fills dataspace elements with a fill value in a memory buffer.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Dset_extent<br>h5dset_extent_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Changes the sizes of a dataset&rsquo;s dimensions. 
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />

<!-- NEW PAGE -->

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Function Listing 2. Dataset creation property list functions (H5P)
        </b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td>
        <b>C Function<br>Fortran Function</b>
        </td><td>&nbsp;</td>
        <td>
        <b>Purpose</b>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_layout<br>h5pset_layout_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the type of storage used to store the raw data for a dataset.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_layout<br>h5pget_layout_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns the layout of the raw data for a dataset.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_chunk<br>h5pset_chunk_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the size of the chunks used to store a chunked layout dataset.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_chunk<br>h5pget_chunk_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the size of chunks for the raw data of a chunked layout 
        dataset.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_deflate<br>h5pset_deflate_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets compression method and compression level.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_fill_value<br>h5pset_fill_value_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the fill value for a dataset.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_fill_value<br>h5pget_fill_value_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves a dataset fill value.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pfill_value_defined<br>(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Determines whether the fill value is defined.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_fill_time<br>h5pset_fill_time_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the time when fill values are written to a dataset.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_fill_time<br>h5pget_fill_time_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the time when fill value are written to a dataset.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_alloc_time<br>h5pset_alloc_time_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the timing for storage space allocation.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_alloc_time<br>h5pget_alloc_time_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the timing for storage space allocation.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_filter<br>h5pset_filter_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Adds a filter to the filter pipeline.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pall_filters_avail<br>(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Verifies that all required filters are available.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_nfilters<br>h5pget_nfilters_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns the number of filters in the pipeline.
        </td>
        </tr>
    <!-- NEW PAGE -->
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_filter<br>h5pget_filter_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns information about a filter in a pipeline. The C function is a 
        macro: see <a href="../RM/APICompatMacros.html">&ldquo;API 
        Compatibility Macros in HDF5.&rdquo;</a>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_filter_by_id<br>h5pget_filter_by_id_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns information about the specified filter. The C function is a 
        macro: see <a href="../RM/APICompatMacros.html">&ldquo;API 
        Compatibility Macros in HDF5.&rdquo;</a>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pmodify_filter<br>h5pmodify_filter_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Modifies a filter in the filter pipeline.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Premove_filter<br>h5premove_filter_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Deletes one or more filters in the filter pipeline.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_fletcher32<br>h5pset_fletcher32_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets up use of the Fletcher32 checksum filter.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_nbit<br>h5pset_nbit_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets up use of the n-bit filter.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_scaleoffset<br>h5pset_scaleoffset_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets up use of the scale-offset filter.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_shuffle<br>h5pset_shuffle_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets up use of the shuffle filter.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_szip<br>h5pset_szip_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets up use of the Szip compression filter.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_external<br>h5pset_external_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Adds an external file to the list of external files.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_external_count<br>h5pget_external_count_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns the number of external files for a dataset.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_external<br>h5pget_external_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns information about an external file.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_char_encoding<br>h5pset_char_encoding_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the character encoding used to encode a string. 
        Use to set ASCII or UTF-8 character encoding for object names.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_char_encoding<br>h5pget_char_encoding_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the character encoding used to create a string. 
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br/>


<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Function Listing 3. Dataset access property list functions (H5P)
        </b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td>
        <b>C Function<br>Fortran Function</b>
        </td><td>&nbsp;</td>
        <td>
        <b>Purpose</b>
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_buffer<br>h5pset_buffer_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets type conversion and background buffers.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_buffer<br>h5pget_buffer_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Reads buffer settings.
        </td>
        </tr>
<!-- 8.10.10, MEE: I removed two dataset access property list functions: 
                   H5Pset_preserve and H5Pget_preserve. -->
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_chunk_cache<br>h5pset_chunk_cache_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the raw data chunk cache parameters.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_chunk_cache<br>h5pget_chunk_cache_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the raw data chunk cache parameters. 
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_edc_check<br>h5pset_edc_check_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets whether to enable error-detection when reading a dataset.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_edc_check<br>h5pget_edc_check_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Determines whether error-detection is enabled for dataset reads.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_filter_callback<br>(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets user-defined filter callback function.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_data_transform<br>h5pset_data_transform_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets a data transform expression.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_data_transform<br>h5pget_data_transform_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves a data transform expression.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_type_conv_cb<br>(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets user-defined datatype conversion callback function.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_type_conv_cb<br>(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Gets user-defined datatype conversion callback function.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_hyper_vector_size<br>h5pset_hyper_vector_size_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets number of I/O vectors to be read/written in hyperslab I/O.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_hyper_vector_size<br>h5pget_hyper_vector_size_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves number of I/O vectors to be read/written in hyperslab I/O.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_btree_ratios<br>h5pset_btree_ratios_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets B-tree split ratios for a dataset transfer property list.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_btree_ratios<br>h5pget_btree_ratios_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Gets B-tree split ratios for a dataset transfer property list.
        </td>
        </tr>
    <!-- NEW PAGE -->
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_vlen_mem_manager<br>(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the memory manager for variable-length datatype allocation in 
        <code>H5Dread</code> and <code>H5Dvlen_reclaim</code>.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_vlen_mem_manager<br>(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Gets the memory manager for variable-length datatype allocation in 
        <code>H5Dread</code> and <code>H5Dvlen_reclaim</code>.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_dxpl_mpio<br>h5pset_dxpl_mpio_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets data transfer mode.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_dxpl_mpio<br>h5pget_dxpl_mpio_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns the data transfer mode.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_dxpl_mpio_chunk_opt<br>(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets a flag specifying linked-chunk I/O or multi-chunk I/O.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_dxpl_mpio_chunk_opt_num<br>(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets a numeric threshold for linked-chunk I/O.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_dxpl_mpio_chunk_opt_ratio<br>(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets a ratio threshold for collective I/O.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_dxpl_mpio_collective_opt<br>(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets a flag governing the use of independent versus collective I/O. 
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_dxpl_multi<br>(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the data transfer property list for the multi-file driver.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_dxpl_multi<br>(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Returns multi-file data transfer property list information.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_multi_type<br>(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the type of data property for the MULTI driver.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_multi_type<br>(none)</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the type of data property for the MULTI driver.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pset_small_data_block_size<br>h5pset_small_data_block_size_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Sets the size of a contiguous block reserved for small data.
        </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>
        <code>H5Pget_small_data_block_size<br>h5pget_small_data_block_size_f</code> 
        </td><td>&nbsp;</td>
        <td>
        Retrieves the current small data block size setting.
        </td>
        </tr>
        <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />







<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="PModel">
<div align=right>
<a href="#TOP"><font size="-1">(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>

<!-- NEW PAGE -->
<a name="PModel">
<h3 class=pagebefore>5.3. Programming Model</h3>
</a>

  <p>This section explains the programming model for datasets.</p>
<br />
<h4>5.3.1. General Model</h4>

  <p>The programming model for using a dataset has three main phases:</p>
  
  <ul>
    <li>Obtain access to the dataset </li>
    <li>Operate on the dataset using the dataset identifier returned 
    at access </li>
    <li>Release the dataset</li>
  </ul>
  <p>These three phases or steps are described in more detail below the 
  figure.</p>
  
  <p>A dataset may be opened several times and operations performed 
  with several different identifiers to the same dataset. All the 
  operations affect the dataset although the calling program must 
  synchronize if necessary to serialize accesses.</p>

  <p>Note that the dataset remains open until every identifier is closed. 
  The figure below shows the basic sequence of operations.</p>


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dsets_fig2.JPG">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 2. Dataset programming sequence</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

  <p>Creation and data access operations may have optional parameters 
  which are set with property lists.  The general programming model is:</p>

  <ul>
      <li>Create property list of appropriate class (dataset create, 
          dataset transfer)</li>
      <li>Set properties as needed; each type of property has its own 
          format and datatype</li>
      <li>Pass the property list as a parameter of the API call</li>
  </ul>
  <p>The steps below describe the programming phases or steps for using a 
  dataset.</p>

<h4><em>Step 1. Obtain Access</em></h4>

  <p>A new dataset is created by a call to <code>H5Dcreate</code>. If 
  successful, the call returns an identifier for the newly created dataset.</p>

  <p>Access to an existing dataset is obtained by a call to <code>H5Dopen</code>. This call 
  returns an identifier for the existing dataset.</p>

  <p>An object reference 
<!-- editingComment
  <span class="editingComment">[ [ [
  (Chapter ???) 
  ] ] ]</span>
-->
  may be dereferenced to obtain an identifier to 
  the dataset it points to.</p>
  
  <p>In each of these cases, the successful call returns an identifier 
  to the dataset. The identifier is used in subsequent operations until 
  the dataset is closed.</p>

<h4><em>Step 2. Operate on the Dataset</em></h4>

  <p>The dataset identifier can be used to write and read data to the dataset, 
  to query and set properties, and to perform other operations such as 
  adding attributes, linking in groups, and creating references.</p>

  <p>The dataset identifier can be used for any number of 
  operations until the dataset is closed.</p>

<h4><em>Step 3. Close the Dataset</em></h4>

  <p>When all operations are completed, the dataset identifier should 
  be closed. This releases the dataset. </p>
<!-- editingComment
  <span class="editingComment">[ [ [
  { and writes all metadata to the file? }
  ] ] ]</span>
-->

  <p>After the identifier is closed, it cannot be used for further operations.</p>

<h4>5.3.2. Create Dataset</h4>

  <p>A dataset is created and initialized with a call to <code>H5Dcreate</code>. The dataset 
  create operation sets permanent properties of the dataset:</p>

  <ul>
      <li>Name</li>
      <li>Dataspace</li>
      <li>Datatype</li>
      <li>Storage properties</li>
  </ul>

  <p>These properties cannot be changed for the life of the dataset, 
  although the dataspace may be expanded up to its maximum dimensions.</p>

<h4><em>Name</em></h4>

  <p>A dataset name is a sequence of alphanumeric ASCII characters. The 
  full name would include a tracing of the group hierarchy from the root 
  group of the file, e.g., /rootGroup/groupA/subgroup23/dataset1. The 
  local name or relative name within the lowest-level group containing 
  the dataset would include none of the group hierarchy. e.g., Dataset1.</p>


<h4><em>Dataspace</em></h4>

  <p>The dataspace of a dataset defines the number of dimensions and the 
  size of each dimension. 
<!-- editingComment
  <span class="editingComment">[ [ [
  [[Dataspace]]. 
  ] ] ]</span>
-->
  The dataspace defines the number of dimensions, 
  and the maximum dimension sizes and current size of each dimension. 
  The maximum dimension size can be a fixed value or the constant 
  <code>H5D_UNLIMITED</code>, in which case the actual dimension size 
  can be changed with calls to <code>H5Dset_extent</code>, up to the 
  maximum set with the <code>maxdims</code> parameter in the 
  <a href="../RM/RM_H5S.html#Dataspace-CreateSimple" target=RMwindow>
  <code>H5Screate_simple</code></a> call that established the 
  dataset&rsquo;s original dimensions. The maximum dimension size is set 
  when the dataset is created and cannot be changed.</p>

<h4><em>Datatype</em></h4>

  <p>Raw data has a datatype which describes the layout of the raw data 
  stored in the file. 
<!-- editingComment
  <span class="editingComment">[ [ [
  (See [[Datatype]]. 
  ] ] ]</span>
-->
  The datatype is set when the dataset is created 
  and can never be changed. When data is transferred to and from the dataset, 
  the HDF5 Library will assure that the data is transformed to and 
  from the stored format.</p>

<h4><em>Storage Properties</em></h4>

  <p>Storage properties of the dataset are set when it is created. The 
  required inputs table 
  below shows the categories of storage properties. The storage properties 
  cannot be changed after the dataset is created. </p>
<!-- editingComment
  <span class="editingComment">[ [ [
  in [[storage properties]]
  ] ] ]</span>
-->

<h4><em>Filters</em></h4>

  <p>When a dataset is created, optional filters are specified. The 
  filters are added to the data transfer pipeline when data is read or 
  written. The standard library includes filters to implement compression, 
  data shuffling, and error detection code.  Additional user-defined 
  filters may also be used. </p>
<!-- editingComment
  <span class="editingComment">[ [ [
  See [[[filter]]].
  ] ] ]</span>
-->

  <p>The required filters are stored as part of the dataset, and the list may 
  not be changed after the dataset is created. The HDF5 Library automatically 
  applies the filters whenever data is transferred.</p>

<h4><em>Summary</em></h4>

  <p>A newly created dataset has no attributes and no data values. The 
  dimensions, datatype, storage properties, and selected filters are set. 
  The table below lists the required inputs, and the second table below lists 
  the optional inputs.</p>
  
<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 1. Required inputs</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="25%"><b>Required Inputs</b></td>
        <td width="75%"><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Dataspace</td>
        <td>The shape of the array.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Datatype</td>
        <td>The layout of the stored elements.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Name</td>
        <td>The name of the dataset in the group.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />


<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 2. Optional inputs</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="25%"><b>Optional Inputs</b></td>
        <td width="75%"><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Storage Layout</td>
        <td>How the data is organized in the file including chunking.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td> Fill Value</td>
        <td>The behavior and value for uninitialized data.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td> External Storage</td>
        <td>Option to store the raw data in an external file.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td> Filters</td>
        <td>Select optional filters to be applied. One of the filters 
        that might be applied is compression.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />

<!-- NEW PAGE -->
<h4><em>Example</em></h4>

<p>To create a new dataset, go through the following general steps:</p>

<ul>
    <li>Set dataset characteristics (optional where default settings are 
    acceptable)</li>
    <ul>               
        <li>Datatype</li>
        <li>Dataspace</li>
        <li>Dataset creation property list</li>
    </ul> 
    <li>Create the dataset</li>
    <li>Close the datatype, dataspace, and property list (as necessary)</li>
    <li>Close the dataset</li>
    </ul>




  <p>Example 1 below shows example code to create an empty dataset. The 
  dataspace is 7 x 8, and the datatype is a big-endian integer. The dataset 
  is created with the name &ldquo;dset1&rdquo; and is a member of the root 
  group, &ldquo;/&rdquo;.</p>


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  hid_t    dataset, datatype, dataspace;   

  /* 
   * Create dataspace: Describe the size of the array and 
   * create the dataspace for fixed-size dataset. 
   */
  dimsf[0] = 7;
  dimsf[1] = 8;
  dataspace = H5Screate_simple(2, dimsf, NULL); 
  /*
   * Define datatype for the data in the file.
   * For this example, store little-endian integer numbers.
   */
  datatype = H5Tcopy(H5T_NATIVE_INT);
  status = H5Tset_order(datatype, H5T_ORDER_LE);
  /*
   * Create a new dataset within the file using defined 
   * dataspace and datatype. No properties are set.
   */
  dataset = H5Dcreate(file, "/dset", datatype, dataspace, H5P_DEFAULT, 
            H5P_DEFAULT, H5P_DEFAULT);

  H5Dclose(dataset);
  H5Sclose(dataspace);
  H5Tclose(datatype);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 1. Create an empty dataset</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<!-- NEW PAGE -->
  <p>Example 2 below shows example code to create a similar dataset with a 
  fill value of &lsquo;-1&rsquo;. 
  This code has the same steps as in the example above, but uses a non-default 
  property list. A file creation property list is created, and then the 
  fill value is set to the desired value. Then the property list is passed 
  to the <code>H5Dcreate</code> call.</p>


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  hid_t    dataset, datatype, dataspace;
  hid_t plist;  /* property list */
  int fillval = -1;
  dimsf[0] = 7;
  dimsf[1] = 8;
  dataspace = H5Screate_simple(2, dimsf, NULL); 
  
  datatype = H5Tcopy(H5T_NATIVE_INT);
  status = H5Tset_order(datatype, H5T_ORDER_LE);

  /*
   * Example of Dataset Creation property list: set fill value to '-1'
   */
  plist = H5Pcreate(H5P_DATASET_CREATE);
  status = H5Pset_fill_value(plist, datatype, &amp;fillval);

  /* Same as above, but use the property list */
  dataset = H5Dcreate(file, "/dset", datatype, dataspace, H5P_DEFAULT, 
            plist, H5P_DEFAULT);

  H5Dclose(dataset);
  H5Sclose(dataspace);
  H5Tclose(datatype);
  H5Pclose(plist);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 2. Create a dataset with fill value set</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

  <p>After this code is executed, the dataset has been created and written to 
  the file. The data array is uninitialized.  Depending on the storage 
  strategy and fill value options that have been selected, some or all of the 
  space may be allocated in the file, and fill values may be written in the 
  file.</p>
<!-- editingComment
  <span class="editingComment">[ [ [
  See &lt;&lt;below&gt;&gt;.
  ] ] ]</span>
-->

<h4>5.3.3. Data Transfer Operations on a Dataset</h4>

  <p>Data is transferred between memory and the raw data array of the dataset 
  through <code>H5Dwrite</code> and <code>H5Dread</code> operations. A data 
  transfer has the following basic steps:</p>
  
  <ol>
      <li>Allocate and initialize memory space as needed</li>
      <li>Define the datatype of the memory elements</li>
      <li>Define the elements to be transferred (a selection, or all the 
      elements)</li>
      <li>Set data transfer properties (including parameters for filters or 
          file drivers) as needed</li>
      <li>Call the H5D API</li>
  </ol>

  <p>Note that the location of the data in the file, the datatype of the data in 
  the file, the storage properties, and the filters do not need to be specified 
  because these are stored as a permanent part of the dataset. A selection of 
  elements from the dataspace is specified; the selected elements may be the 
  whole dataspace.</p>

<!-- NEW PAGE -->
  <p>The figure below shows a diagram of a write operation which transfers a 
  data array from memory to a dataset in the file (usually on disk). A read 
  operation has similar parameters with the data flowing the other direction.</p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dsets_fig5.JPG" width="670">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 3. A write operation</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<h4><em>Memory Space</em></h4>

  <p>The calling program must allocate sufficient memory to store the data 
  elements to be transferred. For a write (from memory to the file), the 
  memory must be initialized with the data to be written to the file. For 
  a read, the memory must be large enough to store the elements that 
  will be read. The amount of storage needed can be computed from the 
  memory datatype (which defines the size of each data element) and the 
  number of elements in the selection.</p>

<!-- NEW PAGE -->
<h4><em>Memory Datatype</em></h4>

  <p>The memory layout of a single data element is specified by the memory 
  datatype. This specifies the size, alignment, and byte order of the 
  element as well as the datatype class. Note that the memory datatype 
  must be the same datatype class as the file, but may have different byte 
  order and other properties.  The HDF5 Library automatically transforms 
  data elements between the source and destination layouts. See the chapter 
  &ldquo;<a href="11_Datatypes.html">HDF5 Datatypes</a>&rdquo; 
  for more details.</p>

  <p>For a write, the memory datatype defines the layout of the data to be 
  written; an example is IEEE floating-point numbers in native byte order. 
  If the file datatype (defined when the dataset is created) is different 
  but compatible, the HDF5 Library will transform each data element when 
  it is written. For example, if the file byte order is different than 
  the native byte order, the HDF5 Library will swap the bytes.</p>

  <p>For a read, the memory datatype defines the desired layout of the 
  data to be read. This must be compatible with the file datatype, but 
  should generally use native formats, e.g., byte orders. The HDF5 Library 
  will transform each data element as it is read.</p>

<h4><em>Selection</em></h4>

  <p>The data transfer will transfer some or all of the elements of the 
  dataset depending on the dataspace selection. The selection has two 
  dataspace objects: one for the source, and one for the destination. 
  These objects describe which elements of the dataspace to be transferred. 
  Some (partial I/O) or all of the data may be transferred. Partial I/O 
  is defined by defining hyperslabs or lists of elements in a dataspace 
  object.</p>

  <p>The dataspace selection for the source defines the indices of the elements 
  to be read or written. The two selections must define the same number of 
  points, but the order and layout may be different.  The HDF5 Library 
  automatically selects and distributes the elements according to the 
  selections. It might, for example, perform a scatter-gather or 
  sub-set of the data. </p>
<!-- editingComment
  <span class="editingComment">[ [ [
  See [[Selections]].
  ] ] ]</span>
-->

<h4><em>Data Transfer Properties</em></h4>

  <p>For some data transfers, additional parameters should be set using the 
  transfer property list. The table below lists the categories of transfer 
  properties. These properties set parameters for the HDF5 Library and may 
  be used to pass parameters for optional filters and file drivers. For 
  example, transfer properties are used to select independent or collective 
  operation when using MPI-I/O.</p>
  

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 3. Categories of transfer properties</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td><b>Properties</b></td>
        <td><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Library parameters</td>
        <td>Internal caches, buffers, B-Trees, etc.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Memory management</td>
        <td>Variable-length memory management, data overwrite</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>File driver management</td>
        <td>Parameters for file drivers</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Filter management</td>
        <td>Parameters for filters</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />

<h4><em>Data Transfer Operation (Read or Write)</em></h4>

  <p>The data transfer is done by calling <code>H5Dread</code> or 
  <code>H5Dwrite</code> with the parameters described above. The HDF5 
  Library constructs the required pipeline, which will scatter-gather, 
  transform datatypes, apply the requested filters, and use the correct 
  file driver.</p>

  <p>During the data transfer, the transformations and filters are applied to 
  each element of the data in the required order until all the 
  data is transferred.</p>

<!-- editingComment
  <span class="editingComment">[ [ [
  <p>[[See Data Transfer Below]]
  ] ] ]</span>
-->

<h4><em>Summary</em></h4>

  <p>To perform a data transfer, it is necessary to allocate and initialize 
  memory, describe the source and destination, set required and optional 
  transfer properties, and call the H5D API. </p>

<h4><em>Examples</em></h4>

  <p>The basic procedure to <b>write</b> to a dataset is the following:</p>

<dir>
  Open the dataset.<br>
  Set the dataset dataspace for the write (optional if dataspace is 
  <code>H5S_SELECT_ALL</code>).<br>
  Write data.<br>
  Close the datatype, dataspace, and property list (as necessary).<br>
  Close the dataset.<br>
</dir> 

  <p>Example 3 below shows example code to write a 4 x 6 array of integers. 
  In the example, the data is initialized in the memory array dset_data.  
  The dataset has already been created in the file, so it is opened 
  with <code>H5Dopen</code>.</p>

  <p>The data is written with <code>H5Dwrite</code>. The arguments are the 
  dataset identifier, the memory datatype (<code>H5T_NATIVE_INT</code>), the 
  memory and file selections (<code>H5S_ALL</code> in this case: 
  the whole array), and the default (empty) property list. The last argument 
  is the data to be transferred.</p>
  
<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  hid_t       file_id, dataset_id;  /* identifiers */
  herr_t      status;
  int         i, j, dset_data[4][6];

  /* Initialize the dataset. */
  for (i = 0; i &lt; 4; i++)
     for (j = 0; j &lt; 6; j++)
        dset_data[i][j] = i * 6 + j + 1;

  /* Open an existing file. */
  file_id = H5Fopen("dset.h5", H5F_ACC_RDWR, H5P_DEFAULT);

  /* Open an existing dataset. */
  dataset_id = H5Dopen(file_id, "/dset", H5P_DEFAULT);

  /* Write the entire dataset, using 'dset_data': 
        memory type is 'native int'
        write the entire dataspace to the entire dataspace,
        no transfer properties,
   */
  status = H5Dwrite(dataset_id, H5T_NATIVE_INT, H5S_ALL, 
          H5S_ALL, H5P_DEFAULT, dset_data);

  status = H5Dclose(dataset_id);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 3. Write an array of integers</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />


  <p>Example 4 below shows a similar write except for setting a non-default 
  value for the transfer buffer. 
<!-- editingComment
  <span class="editingComment">[ [ [
  &lt;&lt;explain what this does&gt;&gt;.  
  ] ] ]</span>
-->
  The code is the same as Example 3, but a transfer 
  property list is created, and the desired buffer size is set. The 
  <code>H5Dwrite</code> function has the same arguments, but uses the 
  property list to set the buffer.</p>

<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  hid_t       file_id, dataset_id;  
  hid_t       xferplist;
  herr_t      status;
  int         i, j, dset_data[4][6];

  file_id = H5Fopen("dset.h5", H5F_ACC_RDWR, H5P_DEFAULT);

  dataset_id = H5Dopen(file_id, "/dset", H5P_DEFAULT);

  /*
   * Example: set type conversion buffer to 64MB
   */
  xferplist = H5Pcreate(H5P_DATASET_XFER);
  status = H5Pset_buffer( xferplist, 64 * 1024 *1024, NULL, NULL);

  /* Write the entire dataset, using 'dset_data': 
        memory type is 'native int'
        write the entire dataspace to the entire dataspace,
        set the buffer size with the property list,
   */
  status = H5Dwrite(dataset_id, H5T_NATIVE_INT, H5S_ALL, 
        H5S_ALL, xferplist, dset_data);

  status = H5Dclose(dataset_id);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 4. Write an array using a property list</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<!-- editingComment
  <span class="editingComment">[ [ [
  <p>Partial writes (i.e., of selected data elements, such as a hyperslab) 
  are explained below [[partial I/O]]
  ] ] ]</span>
-->

  <p>The basic procedure to <b>read</b> from a dataset is the 
  following:</p>

<dir>
  Define the memory dataspace of the read (optional if dataspace is 
  <code>H5S_SELECT_ALL</code>).<br> 
  Open the dataset.<br> 
  Get the dataset dataspace (if using <code>H5S_SELECT_ALL</code> above).<br> 

<dir>Else define dataset dataspace of read.</dir> 
  Define the memory datatype (optional).<br> 
  Define the memory buffer.<br> 
  Open the dataset.<br> 
  Read data.<br> 
  Close the datatype, dataspace, and property list (as necessary).<br> 
  Close the dataset.
</dir>
  

  <p>The example below shows code that reads a 4 x 6 array of integers from 
  a dataset called &ldquo;dset1&rdquo;. First, the dataset is opened. 
  The <code>H5Dread</code> call has parameters:</p>
<!-- NEW PAGE -->

  <ul>
      <li>The dataset identifier (from <code>H5Dopen</code>)</li>
      <li>The memory datatype (<code>H5T_NATVE_INT</code>)</li>
      <li>The memory and file dataspace (<code>H5S_ALL</code>, the whole array)</li>
      <li>A default (empty) property list</li>
      <li>The memory to be filled</li>
  </ul>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  hid_t       file_id, dataset_id;  
  herr_t      status;
  int         i, j, dset_data[4][6];

  /* Open an existing file. */
  file_id = H5Fopen("dset.h5", H5F_ACC_RDWR, H5P_DEFAULT);

  /* Open an existing dataset. */
  dataset_id = H5Dopen(file_id, "/dset", H5P_DEFAULT);

  /* read the entire dataset, into 'dset_data': 
        memory type is 'native int'
        read the entire dataspace to the entire dataspace,
        no transfer properties,
   */
  status = H5Dread(dataset_id, H5T_NATIVE_INT, H5S_ALL, 
        H5S_ALL, H5P_DEFAULT, dset_data);

  status = H5Dclose(dataset_id);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 5. Read an array from a dataset</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<h4>5.3.4. Retrieve the Properties of a Dataset</h4>

  <p>
  The functions listed below allow the user to retrieve 
  information regarding a dataset including the datatype, 
  the dataspace, the dataset creation property list, 
  and the total stored size of the data.</p>


<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Function Listing 4. Retrieve dataset information
        </b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td> 
        <b>Query Function</b></td><td>&nbsp;</td>
        <td> 
        <b>Description</b></td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td> <code>H5Dget_space</code></td><td>&nbsp;</td>
        <td> Retrieve the dataspace of the dataset 
        as stored in the file.</td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td> <code>H5Dget_type</code></td><td>&nbsp;</td>
        <td> Retrieve the datatype of the dataset 
        as stored in the file.</td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td> <code>H5Dget_create_plist</code></td><td>&nbsp;</td>
        <td> Retrieve the 
        dataset creation properties.</td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td> <code>H5Dget_storage_size</code></td><td>&nbsp;</td>
        <td> 
        Retrieve the total bytes for all the data of the dataset.</td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td> <code>H5Dvlen_get_buf_size</code></td><td>&nbsp;</td>
        <td> 
        Retrieve the total bytes for all the variable-length 
        data of the dataset.</td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />

<!-- NEW PAGE -->

<p>The example below illustrates how to retrieve dataset information.</p>

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  hid_t       file_id, dataset_id;
  hid_t       dspace_id, dtype_id, plist_id; 
  herr_t      status;

  /* Open an existing file. */
  file_id = H5Fopen("dset.h5", H5F_ACC_RDWR, H5P_DEFAULT);

  /* Open an existing dataset. */
  dataset_id = H5Dopen(file_id, "/dset", H5P_DEFAULT);

  dspace_id = H5Dget_space(dataset_id);
  dtype_id = H5Dget_type(dataset_id);
  plist_id = H5Dget_create_plist(dataset_id);

  /* use the objects to discover the properties of the dataset */

  status = H5Dclose(dataset_id);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 6. Retrieve dataset</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="DTransfer">
<div align=right>
<a href="#TOP"><font size="-1">(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>


<a name="DTransfer">
<h3 class=pagebefore>5.4. Data Transfer</h3>
</a>

  <p>The HDF5 Library implements data transfers through a pipeline which 
  implements data transformations (according to the datatype and selections), 
  chunking (as requested), and I/O operations using different mechanisms 
  (file drivers). The pipeline is automatically configured by the HDF5 
  Library. Metadata is stored in the file so that the correct pipeline 
  can be constructed to retrieve the data. In addition, optional filters 
  such as compression may be added to the standard pipeline. </p>

  <p>The figure below illustrates data layouts for different layers of an 
  application using HDF5. The application data is organized as a 
  multidimensional array of elements. The HDF5 format specification
<!-- editingComment
  <span class="editingComment">[ [ [
   [[cite it]] 
  ] ] ]</span>
-->
  defines the stored layout of the data and metadata.  The storage layout 
  properties define the organization of the abstract data. This data is 
  written and read to and from some storage medium.</p>
  
<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dsets_fig9.JPG" width="95%">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 4. Data layouts in an application </b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />


  <p>The last stage of a write (and first stage of a read) is managed by 
  an HDF5 file driver module.  The virtual file layer of the HDF5 Library 
  implements a standard interface to alternative I/O methods, including 
  memory (AKA &ldquo;core&rdquo;) files, single serial file I/O, multiple 
  file I/O, and parallel I/O. The file driver maps a simple abstract HDF5 
  file to the specific access methods.</p>

  <p>The raw data of an HDF5 dataset is conceived to be a multidimensional 
  array of data elements. This array may be stored in the file according to 
  several storage strategies:</p> 


  <ul>
      <li>Contiguous</li>
      <li>Chunked</li>
      <li>Compact</li>
  </ul>

  <p>The storage strategy does not affect data access methods except that 
  certain operations may be more or less efficient depending on the storage 
  strategy and the access patterns.</p>

  <p>Overall, the data transfer operations (<code>H5Dread</code> and 
  <code>H5Dwrite</code>) work identically for any storage method, for any 
  file driver, and for any filters and transformations. The HDF5 Library 
  automatically manages the data transfer process. In some cases, transfer 
  properties should or must be used to pass additional parameters such as 
  MPI/IO directives when used the parallel file driver.</p>

<h4>5.4.1. The Data Pipeline</h4>

  <p>When data is written or read to or from an HDF5 file, the HDF5 
  Library passes the data through a sequence of processing steps which 
  are known as the HDF5 data pipeline. This data pipeline performs 
  operations on the data in memory such as byte swapping, alignment, 
  scatter-gather, and hyperslab selections. The HDF5 Library automatically 
  determines which operations are needed and manages the organization 
  of memory operations such as extracting selected elements from a 
  data block. The data pipeline modules operate on data buffers: each 
  module processes a buffer and passes the transformed buffer to the 
  next stage.</p>

  <p>The table below lists the stages of the data pipeline. The figure below 
  the table shows the order of processing 
  during a read or write.</p>


<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 4. Stages of the data pipeline</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="35%"><b>Layers</b></td>
        <td width="65%"><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>I/O initiation</td>
        <td>Initiation of HDF5 I/O activities (<code>H5Dwrite</code> and 
        <code>H5Dread</code>) in a user&rsquo;s application program. </td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Memory hyperslab operation</td>
        <td>Data is scattered to (for read), or gathered from (for write) 
        the application&rsquo;s memory buffer (bypassed if no datatype 
        conversion is needed).</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Datatype conversion</td>
        <td>Datatype is converted if it is different between memory and 
        storage (bypassed if no datatype conversion is needed).</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>File hyperslab operation</td>
        <td>Data is gathered from (for read), or scattered to (for write) to 
        file space in memory (bypassed if no datatype conversion is needed).</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Filter pipeline</td>
        <td>Data is processed by filters when it passes.  Data can be 
        modified and restored here (bypassed if no datatype conversion 
        is needed, no filter is enabled, or dataset is not chunked).</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Virtual File Layer</td>
        <td>Facilitate easy plug-in file drivers such as MPIO or 
        POSIX I/O.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Actual I/O</td>
        <td>Actual file driver used by the library such as MPIO or STDIO.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />
<br />


<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dsets_fig10.JPG"><br>
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 5. The processing order in the data pipeline</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

  <p>The HDF5 Library automatically applies the stages as needed. </p>

  <p>When the memory dataspace selection is other than the whole dataspace, 
  the memory hyperslab stage scatters/gathers the data elements between 
  the application memory (described by the selection) and a contiguous 
  memory buffer for the pipeline. On a write, this is a gather operation; 
  on a read, this is a scatter operation.</p>

  <p>When the memory datatype is different from the file datatype, the 
  datatype conversion stage transforms each data element. For example, if 
  data is written from 32-bit big-endian memory, and the file datatype is 
  32-bit little-endian, the datatype conversion stage will swap the bytes 
  of every elements.  Similarly, when data is read from the file to 
  native memory, byte swapping will be applied automatically when needed.</p>

  <p>The file hyperslab stage is similar to the memory hyperslab stage, 
  but is managing the arrangement of the elements according to the 
  dataspace selection. When data is read, data elements are gathered from 
  the data blocks from the file to fill the contiguous buffers which are then 
  processed by the pipeline. When data is read, the elements from a buffer 
  are scattered to the data blocks of the file.</p>

<h4>5.4.2. Data Pipeline Filters</h4>

  <p>In addition to the standard pipeline, optional stages, called filters, 
  can be inserted in the pipeline. 
<!-- editingComment
  <span class="editingComment">[ [ [
  see [[chunked]]) 
  ] ] ]</span>
-->
  The standard distribution includes optional filters to 
  implement compression and error checking. User applications may 
  add custom filters as well.</p>

  <p>The HDF5 Library distribution includes or employs 
  several optional filters. These are listed in the table below. 
  The filters are applied in the pipeline between the virtual file layer and 
  the file hyperslab operation. See the figure above. The application can 
  use any number of filters in any order.</p>
  

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 5. Data pipeline filters</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="35%"><b>Filter</b></td>
        <td width="65%"><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>gzip compression</td>
        <td>Data compression using <code>zlib</code>.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Szip compression</td>
        <td>Data compression using the Szip library. See The HDF Group 
        website for more information regarding the 
        <a href="http://www.hdfgroup.org/doc_resource/SZIP/" 
        target="Ext1">Szip</a> filter.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>N-bit compression</td>
        <td>Data compression using an algorithm specialized for 
        n-bit datatypes.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Scale-offset compression</td>
        <td>Data compression using using a &ldquo;scale and 
        offset&rdquo; algorithm.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Shuffling</td>
        <td>To improve compression performance, data is regrouped by 
        its byte position in the data unit. In other words, the 
        1<sup><font size="-1">st</font></sup>, 
        2<sup><font size="-1">nd</font></sup>, 
        3<sup><font size="-1">rd</font></sup>, and 
        4<sup><font size="-1">th</font></sup> bytes of integers are 
        stored together respectively.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Fletcher32</td>
        <td>Fletcher32 checksum for error-detection.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />

  <p>Filters may be used only for chunked data and are applied to chunks of 
  data between the file hyperslab stage and the virtual file layer. At this 
  stage in the pipeline, the data is organized as fixed-size blocks of 
  elements, and the filter stage processes each chunk separately.</p>

  <p>Filters are selected by dataset creation properties, and some behavior may 
  be controlled by data transfer properties. The library determines what 
  filters must be applied and applies them in the order in which they were
  set by the application. That is, if an application calls
  <code>H5Pset_shuffle</code> and then <code>H5Pset_deflate</code> when 
  creating
  a dataset&rsquo;s creation property list, the library will apply the 
  shuffle filter first and then the deflate filter.</p>
  
  <p>Information regarding the n-bit and scale-offset filters 
  can be found in the &ldquo;<a href="#N-Bit">Using the N-bit Filter</a>&rdquo;
  and &ldquo;<a href="#ScaleOffset">Using the Scale-offset Filter</a>&rdquo; 
  sections, respectively.</p>

<h4>5.4.3. File Drivers</h4>

  <p>I/O is performed by the HDF5 virtual file layer. The file driver 
  interface writes and reads blocks of data; each driver module implements 
  the interface using different I/O mechanisms. The table below lists the 
  file drivers currently supported. Note that the I/O mechanisms are 
  separated from the pipeline processing: the pipeline and filter 
  operations are identical no matter what data access mechanism is used.</p>


<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 6. I/O file drivers</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td><b>File Driver</b></td>
        <td><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5FD_CORE</code></td>
        <td>Store in memory (optional backing store to disk file).</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5FD_FAMILY</code></td>
        <td>Store in a set of files.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5FD_LOG</code></td>
        <td>Store in logging file.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5FD_MPIO</code></td>
        <td>Store using MPI/IO.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5FD_MULTI</code></td>
        <td>Store in multiple files. There are several options to control 
        layout.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5FD_SEC2</code></td>
        <td>Serial I/O to file using Unix &ldquo;section 2&rdquo; functions.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>H5FD_STDIO</code></td>
        <td>Serial I/O to file using Unix &ldquo;stdio&rdquo; functions.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />

  <p>Each file driver writes/reads contiguous blocks of bytes from a logically 
  contiguous address space. The file driver is responsible for managing the 
  details of the different physical storage methods.</p>

  <p>In serial environments, everything above the virtual file layer tends 
  to work identically no matter what storage method is used. </p>
  
  <p>Some options may have substantially different performance depending 
  on the file driver that is used. In particular, multi-file and parallel 
  I/O may perform considerably differently from serial drivers depending 
  on chunking and other settings.</p>

<h4>5.4.4. Data Transfer Properties to Manage the Pipeline</h4>

  <p>Data transfer properties set optional parameters that control parts of the 
  data pipeline. The function listing below shows transfer properties 
  that control the behavior of the library.</p>
<!-- editingComment
  <span class="editingComment">[ [ [
  &lt;&lt;Developers: explain what these do!&gt;&gt;</p>
  ] ] ]</span>
-->

<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Function Listing 5. Data transfer property list functions
        </b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td> 
        <b>Property</b></td><td>&nbsp;</td>
        <td> 
        <b>Description</b></td></tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td> <code>H5Pset_buffer</code></td><td>&nbsp;</td>
        <td> 
        Maximum size for the type conversion buffer and the background 
        buffer. May also  
        supply pointers to application-allocated buffers.</td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td> <code>H5Pset_hyper_cache</code></td><td>&nbsp;</td>
        <td> 
        Whether to cache hyperslab blocks during I/O.</td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td> <code>H5Pset_btree_ratios</code></td><td>&nbsp;</td>
        <td> 
        Set the B-tree split ratios for a dataset transfer property list. 
        The split ratios determine what percent of children go in the 
        first node when a node splits.</td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />

  <p>Some filters and file drivers require or use additional parameters 
  from the application program. These can be passed in the data transfer 
  property list. The table below shows file driver property list functions.</p>
  

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Function Listing 6. File driver property list functions
        </b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td> 
        <b>Property</b></td><td>&nbsp;</td>
        <td> 
        <b>Description</b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td> <code>H5Pset_dxpl_mpio</code></td><td>&nbsp;</td>
        <td> 
        Control the MPI I/O transfer mode (independent or collective) 
        during data I/O operations.</td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td> <code>H5Pset_dxpl_multi</code></td><td>&nbsp;</td>
        <td> Sets the data transfer property list for 
        the multi-file driver. </td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td> <code>H5Pset_small_data_block_size</code></td><td>&nbsp;</td>
        <td> 
        Reserves blocks of size bytes for the contiguous storage of the raw 
        data portion of small datasets. The HDF5 Library then writes the raw data 
        from small datasets to this reserved space which reduces unnecessary 
        discontinuities within blocks of metadata and 
        improves I/O performance.</td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td> <code>H5Pset_edc_check</code></td><td>&nbsp;</td>
        <td> 
        Disable/enable EDC checking for read. When selected, EDC 
        is always written.</td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />

  <p>The transfer properties are set in a property list which is passed as a 
  parameter of the <code>H5Dread</code> or <code>H5Dwrite</code> call.  The 
  transfer properties are passed to each pipeline stage. Each stage may use 
  or ignore any property in the list. In short, there is one property list 
  that contains all the properties.</p>


<h4>5.4.5. Storage Strategies</h4>

  <p>The raw data is conceptually a multi-dimensional array of elements that 
  is stored as a contiguous array of bytes. The data may be physically stored 
  in the file in several ways. The table below lists the storage strategies 
  for a dataset.</p>
  

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 7. Dataset storage strategies</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td><b>Storage Strategy</b></td>
        <td><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Contiguous</td>
        <td>The dataset is stored as one continuous array of bytes.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Chunked</td>
        <td>The dataset is stored as fixed-size chunks.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Compact</td>
        <td>A small dataset is stored in the metadata header.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />

  <p>The different storage strategies do not affect the data transfer 
  operations of the dataset: reads and writes work the same for any 
  storage strategy.</p>

<!-- editingComment
  <span class="editingComment">[ [ [
  <p>&lt;&lt;Relationship between storage strategies, and pipeline, filters, 
  and file drivers.??&gt;&gt;
  ] ] ]</span>
-->

  <p>These strategies are described in the following sections.</p>

<h4><em>Contiguous</em></h4>

  <p>A contiguous dataset is stored in the file as a header and a single 
  continuous array of bytes. See the figure below. In the case of a 
  multi-dimensional array, the data is serialized in row major order. 
  By default, data is stored contiguously.</p>


<table width="400" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dsets_fig12.JPG">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 6. Contiguous data storage</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

  <p>Contiguous storage is the simplest model. It has several limitations. 
  First, the dataset must be a fixed-size: it is not possible to extend 
  the limit of the dataset or to have unlimited dimensions. In other 
  words, if the number of dimensions of the array might change over 
  time, then chunking storage must be used instead of contiguous. 
  Second, because data is passed through the pipeline as fixed-size 
  blocks, compression and other filters cannot be used with contiguous 
  data.</p>

  <!-- NEW PAGE -->
<h4><em>Chunked</em></h4>

  <p>The data of a dataset may be stored as fixed-size chunks. See the 
  figure below. 
  A chunk is a hyper-rectangle of any shape. 
  When a dataset is chunked, each chunk is read or written as a single I/O 
  operation, and individually passed from stage to stage of the data pipeline. 
  </p>


<table width="400" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dsets_fig13.JPG">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 7. Chunked data storage</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />


  <p>Chunks may be any size and shape that fits in the dataspace of the dataset.
  For example, a three dimensional dataspace can be chunked as 3-D cubes, 
  2-D planes, or 1-D lines. The chunks may extend beyond the size of the 
  dataspace. For example, a 3 x 3 dataset might by chunked in 2 x 2 chunks. 
  Sufficient chunks will be allocated to store the array, and any extra space 
  will not be accessible. So, to store the 3 x 3 array, four 2 x 2 chunks would 
  be allocated with 5 unused elements stored.</p>

  <p>Chunked datasets can be unlimited in any direction 
  and can be compressed or filtered.</p>

  <p>Since the data is read or written by chunks, chunking can have a dramatic 
  effect on performance by optimizing what is read and written.  Note, too, 
  that for specific access patterns such as parallel I/O, decomposition into 
  chunks can have a large impact on performance.</p>

  <p>Two restrictions have been placed on chunk shape and size:</p>

  <ul>
    <li>The rank of a chunk must be less than or equal to 
        the rank of the dataset</li>
    <li>Chunk size cannot exceed the size of a fixed-size dataset; 
        for example, a dataset consisting of a 5 x 4 fixed-size array 
        cannot be defined with 10 x 10 chunks</li>
    </ul>


<!-- NEW PAGE -->
<h4><em>Compact</em></h4>

  <p>For contiguous and chunked storage, the dataset header information and data 
  are stored in two (or more) blocks. Therefore, at least two I/O operations 
  are required to access the data: one to access the header, and one (or more) 
  to access data. For a small dataset, this is considerable overhead.</p>

  <p>A small dataset may be stored in a continuous array of bytes in the 
  header block using the compact storage option. This dataset can be read 
  entirely in one operation which retrieves the header and data.  
  The dataset must fit in the header. This may vary depending on the 
  metadata that is stored. In general, a compact dataset should be 
  approximately 30 KB or less total size.
  See the figure below.</p>


<table width="400" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dsets_fig14.JPG">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 8. Compact data storage</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />


<h4>5.4.6. Partial I/O Sub-setting and Hyperslabs</h4>

  <p>Data transfers can write or read some of the data elements of the dataset. 
  This is controlled by specifying two selections: one for the source and 
  one for the destination. Selections are specified by creating a dataspace 
  with selections. </p>
<!-- editingComment
  <span class="editingComment">[ [ [
  (see [[dataspace chapter]])
  ] ] ]</span>
-->

  <p>Selections may be a union of hyperslabs or a list of points.
  A hyperslab is a contiguous hyper-rectangle from the dataspace. 
  Selected fields of a compound datatype may be read or written. 
  In this case, the selection is controlled by the memory and file 
  datatypes.</p>

  <p>Summary of procedure:</p>
  
  <ol>
      <li>Open the dataset</li>
      <li>Define the memory datatype</li>
      <li>Define the memory dataspace selection and file dataspace 
      selection</li>
      <li>Transfer data (<code>H5Dread</code> or <code>H5Dwrite</code>)</li>
  </ol>

  <p>For a detailed explanation of selections, see the chapter
  &ldquo;<a href="12_Dataspaces.html">HDF5 Dataspaces and Partial I/O</a>.
  &rdquo;</p>
  
<SCRIPT language="JavaScript">
<!--
document.writeln ("
<a name="Allocation">
<div align=right>
<a href="#TOP"><font size="-1">(Top)</font></a>
</div>
</a>
");
-->
</SCRIPT>








<br />
<!-- NEW PAGE -->
<a name="Allocation">
<h3 class=pagebefore>5.5. Allocation of Space in the File</h3>
</a>

  <p>When a dataset is created, space is allocated in the file for its 
  header and initial data. The amount of space allocated when the dataset 
  is created depends on the storage properties. When the dataset is 
  modified (data is written, attributes added, or other changes), 
  additional storage may be allocated if necessary.</p>

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 8. Initial dataset size</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="15%"><b>Object</b></td>
        <td width="85%"><b>Size</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Header</td>
        <td>Variable, but typically around 256 bytes at the creation of 
        a simple dataset with a simple datatype.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Data</td>
        <td>Size of the data array (number of elements x size of element). 
        Space allocated in the file depends on the storage strategy 
        and the allocation strategy.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />

<h4><em>Header</em></h4>

  <p>A dataset header consists of one or more header messages containing 
  persistent metadata describing various aspects of the dataset. 
  These records are defined in the <a href="../H5.format.html"><i>HDF5 File 
  Format Specification</i></a>. The amount of storage required for the 
  metadata depends on the metadata to be stored. The table below 
  summarizes the metadata.</p>


<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 9. Metadata storage sizes</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="25%"><b>Header Information</b></td>
        <td width="70%"><b>Approximate Storage Size</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Datatype (required)</td>
        <td>Bytes  or more. Depends on type.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Dataspace (required)</td>
        <td>Bytes or more. Depends on number of dimensions and hsize_t.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Layout (required)</td>
        <td>Points to the stored data. Bytes or more. Depends on hsize_t and 
        number of dimensions.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Filters</td>
        <td>Depends on the number of filters. The size of the filter message 
        depends on the name and data that will be passed.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />

  <p>The header blocks also store the name and values of attributes, so 
  the total storage depends on the number and size of the attributes.</p>

  <p>In addition, the dataset must have at least one link, including a name, 
  which is stored in the file and in the group it is linked from.</p>

  <p>The different storage strategies determine when and how much space is 
  allocated for the data array. See the discussion of fill values below
<!-- editingComment
  <span class="editingComment">[ [ [
  Link
  ] ] ]</span>
-->
  for a detailed explanation of the storage allocation.</p>

  <!-- NEW PAGE -->
<h4><em>Contiguous Storage</em></h4>

  <p>For a continuous storage option, the data is stored in a single, 
  contiguous block in the file.  The data is nominally a fixed-size, 
  (number of elements x size of element). The figure below shows an example 
  of a two dimensional array stored as a contiguous dataset.</p>

  <p>Depending on the fill value properties, the space may be allocated 
  when the dataset is created or when first written (default), and filled 
  with fill values if specified. For parallel I/O, by default the space 
  is allocated when the dataset is created.</p>
  

<table width="400" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dsets_fig15.JPG">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 9. A two dimensional array stored as a contiguous dataset</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<h4><em>Chunked</em></h4>

  <p>For chunked storage, the data is stored in one or more chunks.  Each chunk 
  is a continuous block in the file, but chunks are not necessarily stored 
  contiguously. Each chunk has the same size.  The data array has the same 
  nominal size as a contiguous array (number of elements x size of element), 
  but the storage is allocated in chunks, so the total size in the file can 
  be larger that the nominal size of the array. See the figure below.</p>
  
  <p>If a fill value is defined, each chunk will be filled with the fill value. 
  Chunks must be allocated when data is written, but they may be allocated when 
  the file is created, as the file expands, or when data is written. </p>

  <p>For serial I/O, by default chunks are allocated incrementally, as data is 
  written to the chunk. For a sparse dataset, chunks are allocated only for the 
  parts of the dataset that are written. In this case, if the dataset is 
  extended, no storage is allocated.</p>

  <p>For parallel I/O, by default chunks are allocated when the dataset is 
  created or extended with fill values written to the chunk.</p>

  <p>In either case, the default can be changed using fill value properties.  
  For example, using serial I/O, the properties can select to allocate 
  chunks when the dataset is created.</p>

  

<table width="400" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dsets_fig16.JPG">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 10. A two dimensional array stored in chunks</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />


<h4><em>Changing Dataset Dimensions</em></h4>  
  
  <p><code>H5Dset_extent</code> is used to change the current dimensions 
  of the dataset within the limits of the dataspace.  Each dimension can 
  be extended up to its maximum or unlimited. Extending the dataspace may 
  or may not allocate space in the file and may or may not write fill 
  values, if they are defined. See the example code below.</p>

  <p>The dimensions of the dataset can also reduced. If the sizes specified 
  are smaller than the datasets current dimension sizes, 
  <code>H5Dset_extent</code> will reduce the datasets dimension sizes to 
  the specified values. It is the users responsibility to ensure that 
  valuable data is not lost; <code>H5Dset_extent</code> does not check.</p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  hid_t       file_id, dataset_id;  
  Herr_t      status;
  size_t      newdims[2];

  /* Open an existing file. */
  file_id = H5Fopen("dset.h5", H5F_ACC_RDWR, H5P_DEFAULT);

  /* Open an existing dataset. */
  dataset_id = H5Dopen(file_id, "/dset", H5P_DEFAULT);

  /* Example:  dataset is 2 x 3, each dimension is UNLIMITED */
  /* extend to 2 x 7 */
  newdims[0] = 2;
  newdims[1] = 7;

  status = H5Dset_extent(dataset_id, newdims);

  /* dataset is now 2 x 7 */

  status = H5Dclose(dataset_id);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 7. Using <code>H5Dset_extent</code> 
        to increase the size of a dataset</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<h4>5.5.1. Storage Allocation in the File: Early, Incremental, Late</h4>

  <p>The HDF5 Library implements several strategies for when storage is 
  allocated if and when it is filled with fill values for elements not 
  yet written by the user. Different strategies are recommended for 
  different storage layouts and file drivers. In particular, a parallel 
  program needs storage allocated during a collective call (for example, 
  create or extend) while serial programs may benefit from delaying the 
  allocation until the data is written.</p>

  <p>Two file creation properties control when to allocate space, when to 
  write the fill value, and the actual fill value to write. </p>

 
  <h4><em>When to Allocate Space</em></h4>  

  <p>The table below shows the options for when data is allocated in the 
  file. &ldquo;Early&rdquo; allocation is done during the dataset create 
  call. Certain file drivers (especially MPI-I/O and MPI-POSIX) require 
  space to be allocated when a dataset is created, so all processors will 
  have the correct view of the data.</p>
  

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 10. File storage allocation options</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="20%"><b>Strategy</b></td>
        <td width="80%"><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Early</td>
        <td>Allocate storage for the dataset immediately when the dataset 
        is created. </td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Late</td>
        <td>Defer allocating space for storing the dataset until the 
        dataset is written.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Incremental</td>
        <td>Defer allocating space for storing each chunk until 
        the chunk is written.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Default</td>
        <td>Use the strategy (Early, Late, or Incremental) for the storage method 
        and access method. This is the recommended strategy.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />

  <p>&ldquo;Late&rdquo; allocation is done at the time of the first write to 
  dataset. Space for the whole dataset is allocated at the first write.</p>

  <p>&ldquo;Incremental&rdquo; allocation (chunks only) is done at the time 
  of the first write to the chunk. Chunks that have never been written are 
  not allocated in the file. In a sparsely populated dataset, this option 
  allocates chunks only where data is actually written.</p>


  <p>The &ldquo;Default&rdquo; property selects the option recommended as 
  appropriate for the storage method and access method. The defaults are 
  shown in the table below. Note that &ldquo;Early&rdquo; allocation is 
  recommended for all Parallel I/O, while other options are recommended 
  as the default for serial I/O cases.</p>
  
<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="3" align="left" valign="bottom">
        <b>Table 11. Default storage options</b></td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="33%"> 
        <b>&nbsp;</b></td>
        <td width="34%"> 
        <b>Serial I/O</b></td>
        <td width="33%"> 
        <b>Parallel I/O</b></td>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Contiguous Storage</td>
        <td>Late</td>
        <td>Early</td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Chunked Storage</td>
        <td>Incremental</td>
        <td>Early</td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Compact Storage</td>
        <td>Early</td>
        <td>Early</td>
        </tr>
    <tr><td colspan="3"><hr color="green" size="3" /></td></tr>
</table>
<br />
 
<h4><em>When to Write the Fill Value</em></h4>  

  <p>The second property is when to write the fill value. The possible values 
  are &ldquo;Never&rdquo; and &ldquo;Allocation&rdquo;. 
  The table below shows these options.</p>
  

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 12. When to write fill values</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="15%"><b>When</b></td>
        <td width="85%"><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Never</td>
        <td>Fill value will never be written.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Allocation</td>
        <td>Fill value is written when space is allocated. (Default for 
        chunked and contiguous data storage.)</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />


<h4><em>Fill Values</em></h4>  

  <p>The third property is the fill value to write. The table below shows the 
  values. By default, the data is filled with zeroes. The application may 
  choose no fill value (Undefined). In this case, uninitialized data may have 
  random values. The application may define a fill value of an 
  appropriate type. See the chapter &ldquo;<a href="11_Datatypes.html">HDF5 
  Datatypes</a>&rdquo; for more information regarding fill values.</p>
  

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 13. Fill values</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td><b>What to Write</b></td>
        <td><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Default</td>
        <td>By default, the library fills allocated space with zeroes.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Undefined</td>
        <td>Allocated space is filled with random values.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>User-defined</td>
        <td>The application specifies the fill value.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />

  <p>Together these three properties control the library&rsquo;s behavior. 
  The table below summarizes the possibilities during the dataset 
  create-write-close cycle.</p>
  

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="4" align="left" valign="bottom">
        <b>Table 14. Storage allocation and fill summary</b></td>
        </tr>
    <tr><td colspan="4"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="17%"> 
        <b>When to<br />allocate<br />space</b></td>
        <td width="17%"> 
        <b>When to<br />write fill<br />value</b></td>
        <td width="17%"> 
        <b>What fill<br />value to<br />write</b></td>
        <td width="49%"> 
        <b>Library create-write-close behavior</b></td>
    <tr><td colspan="4"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Early</td>
        <td>Never</td>
        <td>-</td>
        <td>Library allocates space when dataset is created, but never 
        writes a fill value to dataset. A read of unwritten data returns 
        undefined values.</td>
        </tr>
    <tr><td colspan="4"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Late</td>
        <td>Never</td>
        <td>-</td>
        <td>Library allocates space when dataset is written to, but never 
        writes a fill value to the dataset. A read of unwritten data 
        returns undefined values.</td>
        </tr>
    <tr><td colspan="4"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Incremental</td>
        <td>Never</td>
        <td>-</td>
        <td>Library allocates space when a dataset or chunk (whichever 
        is the smallest unit of space) is written to, but it never writes 
        a fill value to a dataset or a chunk. A read of unwritten data 
        returns undefined values.</td>
        </tr>
    <tr><td colspan="4"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>-</td>
        <td>Allocation</td>
        <td>Undefined</td>
        <td><b>Error</b> on creating the dataset. The dataset is not 
        created.</td>
        </tr>
    <tr><td colspan="4"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Early</td>
        <td>Allocation</td>
        <td>Default or User-defined</td>
        <td>Allocate space for the dataset when the dataset is created. 
        Write the fill value (default or user-defined) to the entire 
        dataset when the dataset is created.</td>
        </tr>
    <tr><td colspan="4"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Late</td>
        <td>Allocation</td>
        <td>Default or User-defined</td>
        <td>Allocate space for the dataset when the application first 
        writes data values to the dataset. Write the fill value to the 
        entire dataset before writing application data values.</td>
        </tr>
    <tr><td colspan="4"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Incremental</td>
        <td>Allocation</td>
        <td>Default or User-defined</td>
        <td>Allocate space for the dataset when the application first 
        writes data values to the dataset or chunk (whichever is the 
        smallest unit of space). Write the fill value to the entire dataset 
        or chunk before writing application data values. </td>
        </tr>
    <tr><td colspan="4"><hr color="green" size="3" /></td></tr>
</table>
<br />





<!-- NEW PAGE -->
  <p>During the <code>H5Dread</code> function call, the library behavior 
  depends on whether space has been allocated, whether the fill value has 
  been written to storage, how the fill value is defined, and when to 
  write the fill value. The table below summarizes the different behaviors.</p>
  

<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="4" align="left" valign="bottom">
        <b>Table 15. <code>H5Dread</code> summary</b></td>
        </tr>
    <tr><td colspan="4"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td width="17%"> 
        <b>Is space<br />allocated<br />in the file?</b></td>
        <td width="17%"> 
        <b>What is the<br />fill value?</b></td>
        <td width="17%"> 
        <b>When to<br />write the<br />fill value?</b></td>
        <td width="49%"> 
        <b>Library read behavior</b></td>
    <tr><td colspan="4"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>No</td>
        <td>Undefined</td>
        <td>&lt;&lt;any&gt;&gt;</td>
        <td><b>Error</b>. Cannot create this dataset.</td>
        </tr>
    <tr><td colspan="4"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>No</td>
        <td>Default or User-defined</td>
        <td>&lt;&lt;any&gt;&gt;</td>
        <td>Fill the memory buffer with the fill value.</td>
        </tr>
    <tr><td colspan="4"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Yes</td>
        <td>Undefined</td>
        <td>&lt;&lt;any&gt;&gt;</td>
        <td>Return data from storage (dataset). Trash is possible if 
        the application has not written data to the portion of the 
        dataset being read.</td>
        </tr>
    <tr><td colspan="4"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Yes</td>
        <td>Default or User-defined</td>
        <td>Never</td>
        <td>Return data from storage (dataset). Trash is possible if the 
        application has not written data to the portion of the dataset being 
        read.</td>
        </tr>
    <tr><td colspan="4"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td>Yes</td>
        <td>Default or User-defined</td>
        <td>Allocation</td>
        <td>Return data from storage (dataset).</td>
        </tr>
    <tr><td colspan="4"><hr color="green" size="3" /></td></tr>
</table>
<br />

  <p>There are two cases to consider depending on whether the space in the 
  file has been allocated before the read or not. When space has not yet 
  been allocated and if a fill value is defined, the memory buffer will 
  be filled with the fill values and returned. In other words, no data 
  has been read from the disk. If space has been allocated, the values 
  are returned from the stored data. The unwritten elements will be 
  filled according to the fill value.</p>
  

<h4>5.5.2.  Deleting a Dataset from a File and Reclaiming Space</h4>

  <p>HDF5 does not at this time provide an easy mechanism to remove a dataset 
  from a file or to reclaim the storage space occupied by a deleted object. </p>
  
  <p>Removing a dataset and reclaiming the space it used can be done with 
  the <code>H5Ldelete</code> function and the 
  <a href="../RM/Tools.html#Tools-Repack">h5repack</a> utility program.
  With the <code>H5Ldelete</code> function, links to a dataset can be 
  removed from the file structure. After all the links have been removed, 
  the dataset becomes inaccessible to any application and is effectively 
  removed from the file. The way to recover the space occupied by an 
  unlinked dataset is to write all of the objects of the file into a 
  new file. Any unlinked object is inaccessible to the application and 
  will not be included in the new file. Writing objects to a new file 
  can be done with a custom program or with the h5repack utility program.</p>

  <!-- 8.11.10, MEE: in the paragraph below, the link should be changed.
  Links are now done separately from groups, but there is no HDF5 Links 
  chapter yet. -->
  <p>See the chapter &ldquo;<a href="09_Groups.html">HDF5 Groups</a>&rdquo; for 
  further discussion of HDF5 file structures and the use of links. </p>

<h4>5.5.3. Releasing Memory Resources</h4>

  <p>The system resources required for HDF5 objects such as datasets, 
  datatypes, and dataspaces should be released once access to the object is 
  no longer needed. This is accomplished via the appropriate close function. 
  This is not unique to datasets but a general requirement when working 
  with the HDF5 Library; failure to close objects will result in resource leaks. </p>

  <p>In the case where a dataset is created or data has been transferred, 
  there are several objects that must be closed. These objects 
<!-- editingComment
<span class="editingComment">
   [ [ [ 
   (T? above) 
   originally appeared here.  On the full editorial pass, 
   see if there is any apparent reason for the question.
   ] ] ]
  </span>
-->
  include datasets, 
  datatypes, dataspaces, and property lists. </p>

  <p>The application program must free any memory variables and buffers it 
  allocates. When accessing data from the file, the amount of memory required 
  can be determined by calculating the size of the memory datatype and the 
  number of elements in the memory selection.</p>

  <p>Variable-length data are organized in two or more areas of memory. 
  See &ldquo;<a href="11_Datatypes.html">HDF5 Datatypes</a>&rdquo; for 
  more information. When writing data, the application creates an array 
  of <code>vl_info_t</code> which contains pointers to the elements. 
  The elements might be, for example, strings. In the file, the 
  variable-length data is stored in two parts: a heap with the 
  variable-length values of the data elements and an array of 
  <code>vlinfo_t</code> elements. When the data is read, the amount of 
  memory required for the heap can be determined with the 
  <code>H5Dget_vlen_buf_size</code> call.</p>

  <p>The data transfer property may be used to set a custom memory manager 
  for allocating variable-length data for a <code>H5Dread</code>. This is 
  set with the <code>H5Pset_vlen_mem_manager</code> call.</p>

  <p>To free the memory for variable-length data, it is necessary to visit 
  each element, free the variable-length data, and reset the element. The 
  application must free the memory it has allocated. For memory allocated 
  by the HDF5 Library during a read, the <code>H5Dvlen_reclaim</code> 
  function can be used to perform this operation.</p>

<h4>5.5.4. External Storage Properties</h4>

  <p>The external storage format allows data to be stored across a set of 
  non-HDF5 files. A set of segments (offsets and sizes) in one or more files 
  is defined as an external file list, or EFL, and the contiguous logical 
  addresses of the data storage are mapped onto these segments. Currently, 
  only the <code>H5D_CONTIGUOUS</code> storage format allows external storage. 
  External storage is enabled by a dataset creation property. The table 
  below shows the API.</p>
  
<!-- NEW PAGE -->
<table width="600" cellspacing="0" align="center" cellpadding="0">
    <tr valign="bottom">
        <td colspan="2" align="left" valign="bottom">
        <b>Table 16. External storage API</b></td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
    <tr valign="top"> 
        <td><b>Function</b></td>
        <td><b>Description</b></td>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td width="50%">
        <code>herr_t H5Pset_external (hid_t plist, const char *name, 
        off_t offset, hsize_t size)</code></td>
        <td width="50%">This function adds a new segment to the end of 
        the external file list of the specified dataset creation property 
        list. The segment begins a byte offset of file name and continues 
        for size bytes. The space represented by this segment is adjacent 
        to the space already represented by the external file list. The 
        last segment in a file list may have the size 
        <code>H5F_UNLIMITED</code>, in which case the external file may 
        be of unlimited size and no more files can be added to the 
        external files list.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>int H5Pget_external_count (hid_t plist)</code></td>
        <td>Calling this function returns the number of segments in an 
        external file list. If the dataset creation property list has no 
        external data, then zero is returned.</td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="1" /></td></tr>
    <tr valign="top"> 
        <td><code>herr_t H5Pget_external (hid_t plist, int idx, size_t 
        name_size,<br />char *name, off_t *offset,<br />hsize_t *size)</code></td>
        <td>This is the counterpart for the <code>H5Pset_external()</code> 
        function. Given a dataset creation property list and a zero-based 
        index into that list, the file name, byte offset, and segment 
        size are returned through non-null arguments. At most name_size 
        characters are copied into the name argument which is not null 
        terminated if the file name is longer than the supplied name 
        buffer (this is similar to <code>strncpy()</code>). </td>
        </tr>
    <tr><td colspan="2"><hr color="green" size="3" /></td></tr>
</table>
<br />


  <p>The figure below shows an example of how a contiguous, one-dimensional 
  dataset is partitioned into three parts and each of those parts is stored 
  in a segment of an external file. The top rectangle represents the logical 
  address space of the dataset while the bottom rectangle represents an 
  external file.</p>
  

<table width="500" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dsets_fig19.JPG">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 11. External file storage</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

  <p>The example below shows code that defines the external storage for the 
  example. Note that the segments are defined in order of the logical 
  addresses they represent, not their order within the external file. It 
  would also have been possible to put the segments in separate files. 
  Care should be taken when setting up segments in a single file since 
  the library does not automatically check for segments that overlap.</p>
  

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  Plist = H5Pcreate (H5P_DATASET_CREATE);
  H5Pset_external (plist, "velocity.data", 3000, 1000);
  H5Pset_external (plist, "velocity.data", 0, 2500);
  H5Pset_external (plist, "velocity.data", 4500, 1500);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 8. External storage</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />


  <p>The figure below shows an example of how a contiguous, two-dimensional 
  dataset is partitioned into three parts and each of those parts is 
  stored in a separate external file. The top rectangle represents the 
  logical address space of the dataset while the bottom rectangles 
  represent external files.</p>
  
  
<table width="500" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="center">
        <hr color="green" size="3"/>
        <img src="Images/Dsets_fig20.jpg">
        </td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left" >
        <b>Figure 12. Partitioning a 2-D dataset for external storage</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />



  <p>The example below shows code for the partitioning described above.
  In this example, the library maps the multi-dimensional array onto a linear 
  address space as defined by the HDF5 format specification, and then maps that 
  address space into the segments defined in the external file list. </p>

  
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
    <pre>
  Plist = H5Pcreate (H5P_DATASET_CREATE);
  H5Pset_external (plist, "scan1.data", 0, 24);
  H5Pset_external (plist, "scan2.data", 0, 24);
  H5Pset_external (plist, "scan3.data", 0, 16);</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 9. Partitioning a 2-D dataset for external storage</b>
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

  <p>The segments of an external file can exist beyond the end of the 
  (external) file. The library reads that part of a segment as zeros. When 
  writing to a segment that exists beyond the end of a file, the external 
  file is automatically extended. Using this feature, one can create a 
  segment (or set of segments) which is larger than the current size of 
  the dataset. This allows the dataset to be extended at a future time 
  (provided the dataspace also allows the extension).</p>

  <p>All referenced external data files must exist before performing raw 
  data I/O on the dataset. This is normally not a problem since those files 
  are being managed directly by the application or indirectly through some 
  other library. However, if the file is transferred from its original 
  context, care must be taken to assure that all the external files are 
  accessible in the new location.</p>

<br />
<!-- NEW PAGE -->
<a name="UseFilters">
<h3 class=pagebefore>5.6. Using HDF5 Filters</h3>
</a>
<p>This section describes in detail how to use the n-bit and 
scale-offset filters. </p>


<a name="N-Bit">
<h3>5.6.1. Using the N-bit Filter</h3>
</a>

<p>N-bit data has <i>n</i> significant bits,  
  where <i>n</i> may not correspond to a precise number of bytes.
  On the other hand, computing systems and applications universally, 
  or nearly so, run most efficiently when manipulating data as 
  whole bytes or multiple bytes.</p>

<p>Consider the case of 12-bit integer data.  
  In memory, that data will be handled in at least 2 bytes, or 16 bits, 
  and on some platforms in 4 or even 8 bytes.
  The size of such a dataset can be significantly reduced when written 
  to disk if the unused bits are stripped out.</p>
  
<p>The <i>n-bit filter</i> is provided for this purpose,  
  <i>packing</i> n-bit data on output by stripping off all unused bits 
  and <i>unpacking</i> on input, restoring the extra bits required
  by the computational processor.</p>
  
<h4><em>N-bit Datatype</em></h4>

<p>An <i>n-bit datatype</i> is a datatype of <i>n</i> significant bits.
  Unless it is packed, an <i>n</i>-bit datatype is presented as an 
  <i>n</i>-bit bitfield within a larger-sized value.  
  For example, a 12-bit datatype might be presented as a 12-bit field 
  in a 16-bit, or 2-byte, value.</p>

<p>Currently, the datatype classes of n-bit datatype or n-bit field of a 
  compound datatype or an array datatype are limited to integer or 
  floating-point.</p>
  
<p>The HDF5 user can create an n-bit datatype through a series of
  of function calls.
  For example, the following calls create a 16-bit datatype 
  that is stored in a 32-bit value with a 4-bit offset:</p>
<dir><pre>
hid_t nbit_datatype = H5Tcopy(H5T_STD_I32LE);
H5Tset_precision(nbit_datatype, 16);
H5Tset_offset(nbit_datatype, 4);
</pre></dir>
  
<p>In memory, one value of the above example n-bit datatype would be stored on 
  a little-endian machine as follows:</p>
  
<dl>
      <dt>
        <table border="1" width="80%" align="center">
          <tr>
            <td width="25%" align="center">byte 3</td>
            <td width="25%" align="center">byte 2</td>
            <td width="25%" align="center">byte 1</td>
            <td width="25%" align="center">byte 0</td>
          </tr>
          <tr>
            <td width="25%" align="center"><code>????????</code></td>
            <td width="25%" align="center"><code>????SPPP</code></td>
            <td width="25%" align="center"><code>PPPPPPPP</code></td>
            <td width="25%" align="center"><code>PPPP????</code></td>
          </tr>
        </table>
        <table width="80%" border="0" align="center">
          <tr>
            <td colspan="4"><font size="-1">
              Key: 
                  <code>S</code> - sign bit, 
                  <code>P</code> - significant bit, 
                  <code>?</code> - padding bit 
              <br>
              Sign bit is included in signed integer datatype precision.
	    </font></td>
          </tr>
        </table>
        <br>
        
      </dt>
</dl>
<br />

<!-- NEW PAGE -->
<h4><em>N-bit Filter</em></h4>

<p>When data of an n-bit datatype is stored on disk using the 
  n-bit filter, the filter <i>packs</i> the data by stripping off the 
  padding bits; only the significant bits are retained and stored.  
  The values on disk will appear as follows:</p>
  
<dl>
      <dt>
        <table border="1" width="80%" align="center">
          <tr>
            <td width="45%" align="center">1st value</td>
            <td width="45%" align="center">2nd value</td>
            <td width="10%" align="center">&nbsp;</td>
          </tr>
          <tr>
            <td width="45%" align="center"><code>SPPPPPPP&nbsp;PPPPPPPP</code></td>
            <td width="45%" align="center"><code>SPPPPPPP&nbsp;PPPPPPPP</code></td>
            <td width="10%" align="center">...</td>
          </tr>
        </table>
        <table width="80%" border="0" align="center">
          <tr>
            <td colspan="4"><font size="-1">
              Key: 
                  <code>S</code> - sign bit, 
                  <code>P</code> - significant bit, 
                  <code>?</code> - padding bit 
              <br>
              Sign bit is included in signed integer datatype precision.
	    </font></td>
          </tr>
        </table>
      </dt>
</dl>
<br />


<p>The n-bit filter can be used effectively for compressing data of an n-bit
  datatype, including arrays and the n-bit fields of compound datatypes. 
  The filter supports complex situations where a compound datatype 
  contains member(s) of a compound datatype or an array datatype has
  a compound datatype as the base type.</p>

<p>At present, the n-bit filter supports all datatypes. 
  For datatypes of class time, string,
  opaque, reference, <small>ENUM</small>, and 
  variable-length, the n-bit filter acts as a no-op which is short for no 
  operation. 
  For convenience, the rest of this section refers to such datatypes 
  as <i>no-op datatypes</i>.</p>

<p>As is the case with all HDF5 filters, an application using 
  the n-bit filter must store data with chunked storage.</p>
  
<h4><em>How Does the N-bit Filter Work?</em></h4>

<p>The n-bit filter always compresses and decompresses according to
  dataset properties supplied by the HDF5 Library in the 
  datatype, dataspace, or dataset creation property list.</p>

<p>The dataset datatype refers to how data is stored in an HDF5 file while 
  the memory datatype refers to how data is stored in memory.
  The HDF5 Library will do datatype conversion when writing data 
  in memory to the dataset or reading data from the dataset to memory if 
  the memory datatype differs from the dataset datatype. 
  Datatype conversion is performed by HDF5 Library before n-bit compression 
  and after n-bit decompression.</p>
  
<p>The following sub-sections examine the common cases:</p>
  <ul>
    <li>N-bit integer conversions</li>
    <li>N-bit floating-point conversions</li>
  </ul>

<h5><em>N-bit Integer Conversions</em></h5>

<p>Integer data with a dataset of integer datatype of less than 
  full precision and a memory datatype of <code>H5T_NATIVE_INT</code>,
  provides the simplest application of the n-bit filter.</p>

<p>The precision of <code>H5T_NATIVE_INT</code> is 8 muliplied by 
  <code>sizeof(int)</code>. 
  This value, the size of an <code>int</code> in bytes, differs from 
  platform to platform; we assume a value of <code>4</code> 
  for the following illustration.
  We further assume the memory byte order to be little-endian.</p>

  <!-- NEW PAGE -->
<p>In memory, therefore, the precision of <code>H5T_NATIVE_INT</code> 
  is 32 and the offset is 0. 
  One value of <code>H5T_NATIVE_INT</code> is laid out in memory 
  as follows:</p>
 
<table border="0" width="80%" align="center">
  <tr>
    <td>
<pre>
| byte 3 | byte 2 | byte 1 | byte 0 |
                                
|SPPPPPPP|PPPPPPPP|PPPPPPPP|PPPPPPPP|

</pre>
    </td>
  </tr>
  <tr>
    <td colspan="4"><font size="-1">
      Key: 
        <code>S</code> - sign bit, 
        <code>P</code> - significant bit, 
        <code>?</code> - padding bit 
      <br>
      Sign bit is included in signed integer datatype precision.
      </font></td>
  </tr>
</table>
  
<p>Suppose the dataset datatype has a precision of 16 and an offset of 4. 
  After HDF5 converts values from the memory datatype to the dataset datatype, 
  it passes something like the following to the n-bit filter for 
  compression:</p>

<table border="0" width="80%" align="center">
  <tr>
    <td>
<pre>
| byte 3 |  byte 2 | byte 1 |  byte 0 |
               |                 |
|????????|????S|PPP|PPPPPPPP|PPPP|????|
               |_________________|
                 truncated bits
</pre>
    </td>
  </tr>
  <tr>
    <td colspan="4"><font size="-1">
      Key: 
        <code>S</code> - sign bit, 
        <code>P</code> - significant bit, 
        <code>?</code> - padding bit 
      <br>
      Sign bit is included in signed integer datatype precision.
      </font></td>
  </tr>
</table>
  
<p>Notice that only the specified 16 bits (15 significant bits and the 
  sign bit) are retained in the conversion.  All other significant bits 
  of the memory datatype are discarded because the dataset datatype 
  calls for only 16 bits of precision. 
  After n-bit compression, none of these discarded bits, known as 
  <i>padding bits</i> will be stored on disk.</p>
  
<h5><em>N-bit Floating-point Conversions</em></h5>

<p>Things get more complicated in the case of a floating-point dataset 
  datatype class.  This sub-section provides an example that 
  illustrates the conversion from a memory datatype of 
  <code>H5T_NATIVE_FLOAT</code> to a dataset datatype of class 
  floating-point.</p>


<p>As before, let the <code>H5T_NATIVE_FLOAT</code> be 4 bytes long, 
  and let the memory byte order be little-endian. 
  Per the IEEE standard, one value of <code>H5T_NATIVE_FLOAT</code> 
  is laid out in memory as follows:</p>
  
<table border="0" width="80%" align="center">
  <tr>
    <td>
<pre>
| byte 3 | byte 2 | byte 1 | byte 0 |
                         
|SEEEEEEE|EMMMMMMM|MMMMMMMM|MMMMMMMM|

</pre>
  </td></tr>
  <tr>
    <td colspan="4"><font size="-1">
      Key: 
        <code>S</code> - sign bit, 
        <code>E</code> - exponent bit, 
        <code>M</code> - mantissa bit, 
        <code>?</code> - padding bit 
      <br>
      Sign bit is included in floating-point datatype precision.
      </font></td>
  </tr>
</table>
 
  <br>
  
<p>Suppose the dataset datatype has a precision of 20, offset of 7, 
  mantissa size of 13, mantissa position of 7, 
  exponent size of 6, exponent position of 20, 
  and sign position of 26. 
  (See &ldquo;Definition of Datatypes,&rdquo; section 4.3 of the 
  &ldquo;<a href="UG_frame11Datatypes.html">Datatypes</a>&rdquo; chapter in 
  the <a href="index.html"><cite>HDF5 User&rsquo;s Guide</cite></a> 
  for a discussion of creating and modifying datatypes.)</p>
  
<p>After HDF5 converts values from the memory datatype to the dataset datatype, 
  it passes something like the following to the n-bit filter for 
  compression:</p>
  
<table border="0" width="80%" align="center">
  <tr>
    <td>
<pre>
| byte 3 | byte 2  | byte 1 | byte 0  |
              |               |
|?????SEE|EEEE|MMMM|MMMMMMMM|M|???????|
              |_______________|
              truncated mantissa
</pre>
  </td></tr>
  <tr>
    <td colspan="4"><font size="-1">
      Key: 
        <code>S</code> - sign bit, 
        <code>E</code> - exponent bit, 
        <code>M</code> - mantissa bit, 
        <code>?</code> - padding bit 
      <br>
      Sign bit is included in floating-point datatype precision.
      </font></td>
  </tr>
</table>
  
<p>The sign bit and truncated mantissa bits are not changed during 
  datatype conversion by the HDF5 Library. On the other hand,
  the conversion of the 8-bit exponent to a 6-bit exponent
  is a little tricky:</p>
  
<dir>
  <p>The bias for the new exponent in the n-bit datatype is: </p>
      &nbsp;&nbsp;&nbsp;&nbsp;<code>2<sup>(n-1)</sup>-1</code> 
      <br>
  <p>The following formula is used for this exponent conversion:</p>
  
      
      &nbsp;&nbsp;&nbsp;&nbsp;
      <code>exp8 - (2<sup>(8-1)</sup>-1)</code> = 
      <code>exp6 - (2<sup>(6-1)</sup>-1)</code> = 
      <i>actual exponent value</i> 

      <br /><br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      where <code>exp8</code> is the stored decimal value 
      as represented by the 8-bit exponent,
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      and <code>exp6</code> is the stored decimal value 
      as represented by the 6-bit exponent
</dir>

<p>In this example, caution must be taken to ensure that, 
  after conversion, the actual exponent value is 
  within the range that can be represented by a 6-bit exponent. 
  For example, 
  an 8-bit exponent can represent values  from -127 to 128 while 
  a 6-bit exponent can represent values only from -31 to 32.</p>
  
<a name="Design">
<h4><em>N-bit Filter Behavior</em></h4>
</a>

  <p>The n-bit filter was designed to treat the incoming data byte by byte at 
  the lowest level. The purpose was to make the n-bit filter as generic as 
  possible so that no pointer cast related to the datatype is needed.</p>

  <p>Bitwise operations are employed for packing and unpacking at the byte 
  level.</p>

  <p>Recursive function calls are used to treat compound and array datatypes.</p>

<h5><em>N-bit Compression</em></h5>

  <p>The main idea of n-bit compression is to use a loop to compress each  
  data element in a chunk. Depending on the datatype of each element, 
  the n-bit filter will call one of four functions.  Each of these functions
  performs one of the following tasks:  </p>

    <ul>
      <li>Compress a data element of a no-op datatype</li>
      <li>Compress a data element of an atomic datatype</li>
      <li>Compress a data element of a compound datatype</li>
      <li>Compress a data element of an array datatype</li>
    </ul> 


<p><b>No-op datatypes:</b>
  The n-bit filter does not actually compress no-op datatypes.  
  Rather, it copies the data buffer of the no-op datatype from the 
  noncompressed buffer to the proper location in the compressed buffer; 
  the compressed buffer has no holes. The term &ldquo;compress&rdquo; 
  is used here simply to distinguish this function  from the function 
  that performs the reverse operation during decompression.</p>
  

<p><b>Atomic datatypes:</b>
  The n-bit filter will find the bytes where significant bits are 
  located and try to compress these bytes, one byte at a time, using a loop. 
  At this level, the filter needs the following information:</p>
  <ul>
    <li>The byte offset of the beginning of the current data element with 
        respect to the beginning of the input data buffer</li>
    <li>Datatype size, precision, offset, and byte order  </li>
  </ul>

<p>The n-bit filter compresses from the most significant byte containing 
  significant bits to the least significant byte.  
  For big-endian data, therefore, the loop index progresses from smaller
  to larger while for little-endian, the loop index progresses from larger
  to smaller.</p>

<p>In the extreme case of when the n-bit datatype has full precision,
  this function copies the content of the entire noncompressed datatype 
  to the compressed output buffer.</p>


<p><b>Compound datatypes:</b>
  The n-bit filter will compress each data member of the compound datatype. 
  If the member datatype is of an integer or floating-point datatype, 
  the n-bit filter will call the function described above<!-- in section 2.1.2-->. 
  If the member datatype is of a no-op datatype, 
  the filter will call the function described above<!-- in section 2.1.1-->. 
  If the member datatype is of a compound datatype, the filter will make a 
  recursive call to itself. 
<!--
  (i.e., to the function described in this section, 2.1.3). 
-->
  If the member datatype is of an array datatype, the filter will call the 
  function described below<!-- in section 2.1.4.--></p>


<p><b>Array datatypes:</b>
  The n-bit filter will use a loop to compress each array element in 
  the array. If the base datatype of array element is of an integer or 
  floating-point datatype, the n-bit filter will call the function described 
  above<!-- in section 2.1.2.--> 
  If the base datatype is of a no-op datatype, the filter will call the
  function described above<!-- in section 2.1.1.--> 
  If the base datatype is of a compound datatype, the filter will call the
  function described above<!-- in section 2.1.3-->. 
  If the member datatype is of an array datatype, the filter will make a 
  recursive call of itself.</p>
<!--
  (i.e., to the function described in this section, 2.1.4).
-->
  
<h5><em>N-bit Decompression</em></h5>

<p>The n-bit decompression algorithm is very similar to n-bit compression. 
  The only difference is that at the byte level, compression packs out all 
  padding bits and stores only significant bits into a continous buffer 
  (unsigned char) while decompression unpacks significant bits and inserts 
  padding bits (zeros) at the proper positions to recover the data bytes 
  as they existed before compression.</p>
  
<h5><em>Storing N-bit Parameters to Array</em> <code>cd_value[]</code></h5>

<p>All of the information, or parameters, required by the n-bit filter 
  are gathered and stored in the array <code>cd_values[]</code> by the 
  private function <code>H5Z_set_local_nbit</code> and are passed 
  to another private function, 
  <code>H5Z_filter_nbit</code>, by the HDF5 Library. </p>
  
<p>These parameters are as follows:</p>
  <ol>
    <li>Parameters related to the datatype</li>
    <li>The number of elements within the chunk</li>
    <li>A flag indicating whether compression is needed</li>
  </ol>

<p>The first and second parameters can be obtained using the HDF5 dataspace
  and datatype interface calls. </p>
<!--
  The third parameter is set during the storing process as described 
  in section 3.2.
-->

  <p>A compound datatype can have members of array or compound datatype. 
  An array datatype&rsquo;s base datatype can be a complex compound datatype. 
  Recursive calls are required to set parameters for these complex situations.</p>

  <p>Before setting the parameters, the number of parameters should be 
  calculated to dynamically allocate the array <code>cd_values[]</code>,
  which will be passed to the HDF5 Library. 
  This also requires recursive calls.</p>
  
<p>For an atomic datatype (integer or floating-point), parameters that will 
  be stored include the datatype&rsquo;s size, endianness, precision, and 
  offset. </p>
  
<p>For a no-op datatype, only the size is required.</p>

<p>For a compound datatype, parameters that will be stored include the 
  datatype&rsquo;s total size and number of members. For each member, 
  its member offset needs to be stored. Other parameters for members 
  will depends on the respective datatype class.</p>

<p>For an array datatype, the total size parameter should be stored. 
  Other parameters for the array&rsquo;s base type depend on the base 
  type&rsquo;s datatype class. </p>
  
<p>Further, to correctly retrieve the parameter for use of n-bit 
  compression or decompression later, parameters for distinguishing  
  between datatype classes should be stored.</p>
  
<a name="implementation">
<h4><em>Implementation</em></h4>
</a>

<p>Three filter callback functions were written for the n-bit filter:</p>
  <ul>
    <li><code>H5Z_can_apply_nbit</code></li>
    <li><code>H5Z_set_local_nbit</code></li>
    <li><code>H5Z_filter_nbit</code></li>
  </ul>
  <p>These functions are called internally by the HDF5 Library. 
  A number of utility functions were written for the function 
  <code>H5Z_set_local_nbit</code>. Compression and decompression functions 
  were written and are called by function <code>H5Z_filter_nbit</code>. 
  All these functions are included in the file <code>H5Znbit.c</code>.</p>

<p>The public function <code>H5Pset_nbit</code> is called by 
  the application to set up the use of the n-bit filter. 
  This function is included in the file <code>H5Pdcpl.c</code>. 
  The application does not need to supply any parameters.</p>
  
<h5><em>How N-bit Parameters are Stored</em></h5>

<p>A scheme of storing parameters required by the n-bit filter in the 
  array <code>cd_values[]</code> was developed utilizing recursive 
  function calls.</p>

<p>Four private utility functions were written for storing the parameters 
  associated with atomic (integer or floating-point), no-op, array, and 
  compound datatypes:</p>
  <ul>
  <li><code>H5Z_set_parms_atomic</code></li>
  <li><code>H5Z_set_parms_array</code></li>
  <li><code>H5Z_set_parms_nooptype</code></li>
  <li><code>H5Z_set_parms_compound</code> </li>
  </ul>
  
<!-- NEW PAGE -->
<p>The scheme is briefly described below.</p>

<dir>

  First, assign a numeric code for datatype class atomic (integer or float), 
  no-op, array, and compound datatype. The code is stored before other 
  datatype related parameters are stored.
  
<dl>
  <dd>
  <dt>The first three parameters of <code>cd_values[]</code> are reserved for:
    <ol>
      <li>The number of valid entries in the array <code>cd_values[]</code></li>
      <li>A flag indicating whether compression is needed</li>
      <li>The number of elements in the chunk</li>
    </ol>
  
    
  <dt>Throughout the balance of this explanation, 
    <code>i</code> represents the index of <code>cd_values[]</code>.
    <br>&nbsp;

  <dt>In the function <code>H5Z_set_local_nbit</code>:
  <dd>
      <ol>
        <li><code>i</code> = 2</li>
        <li>Get the number of elements in the chunk and store in
          <code>cd_value[i]</code>; increment <code>i</code></li>
        <li>Get the class of the datatype:
          <br>&nbsp;&nbsp;For an integer or floating-point datatype, call 
          <code>H5Z_set_parms_atomic</code>
          <br>&nbsp;&nbsp;For an array datatype, call 
            <code>H5Z_set_parms_array</code>
          <br>&nbsp;&nbsp;For a compound datatype, call 
            <code>H5Z_set_parms_compound</code>
          <br>&nbsp;&nbsp;For none of the above, call 
            <code>H5Z_set_parms_noopdatatype</code></li>
        <li>Store <code>i</code> in <code>cd_value[0]</code> and 
          flag in <code>cd_values[1]</code></li>
      </ol>
  </dd>
</dl>

<dl>
  <dt>In the function <code>H5Z_set_parms_atomic</code>:</dt>
    <dd>
      <ol>
        <li>Store the assigned numeric code for the atomic datatype in 
          <code>cd_value[i]</code>; increment <code>i</code></li>
        <li>Get the size of the atomic datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code></li>
        <li>Get the order of the atomic datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code></li>
        <li>Get the precision of the atomic datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code></li>
        <li>Get the offset of the atomic datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code></li>
        <li>Determine the need to do compression at this point</li>
      </ol>
  </dd>
</dl>

<dl>
  <dt>In the function <code>H5Z_set_parms_nooptype</code>:
  <dd>
      <ol>
        <li>Store the assigned numeric code for the no-op datatype in 
          <code>cd_value[i]</code>; increment <code>i</code></li>
        <li>Get the size of the no-op datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code></li>
      </ol>
  </dd>
</dl>

<dl>
  <dt>In the function <code>H5Z_set_parms_array</code>:
  <dd>
      <ol>
        <li>Store the assigned numeric code for the array datatype in 
          <code>cd_value[i]</code>; increment <code>i</code></li>
        <li>Get the size of the array datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code></li>
        <li>Get the class of the array'&rsquo;s base datatype.
          <br>&nbsp;&nbsp;For an integer or floating-point datatype, 
            call <code>H5Z_set_parms_atomic</code>
          <br>&nbsp;&nbsp;For an array datatype, call 
            <code>H5Z_set_parms_array</code>
          <br>&nbsp;&nbsp;For a compound datatype, call 
            <code>H5Z_set_parms_compound</code>
          <br>&nbsp;&nbsp;If none of the above, 
            call <code>H5Z_set_parms_noopdatatype</code></li>
      </ol>
  </dd>
</dl>

<dl>
  <dt>In the function <code>H5Z_set_parms_compound</code>:
  <dd>
      <ol>
        <li>Store the assigned numeric code for the compound datatype in 
          <code>cd_value[i]</code>; increment <code>i</code></li>
        <li>Get the size of the compound datatype and store in 
          <code>cd_value[i]</code>; increment <code>i</code></li>
        <li>Get the number of members and store in 
          <code>cd_values[i]</code>; increment <code>i</code></li>
        <li>For each member
          <br>&nbsp;&nbsp;Get the member offset and store in 
            <code>cd_values[i]</code>; increment <code>i</code>
          <br>&nbsp;&nbsp;Get the class of the member datatype
          <br>&nbsp;&nbsp;For an integer or floating-point datatype, 
            call <code>H5Z_set_parms_atomic</code>
          <br>&nbsp;&nbsp;For an array datatype, 
            call <code>H5Z_set_parms_array</code>
          <br>&nbsp;&nbsp;For a compound datatype, 
            call <code>H5Z_set_parms_compound</code>
          <br>&nbsp;&nbsp;If none of the above, 
            call <code>H5Z_set_parms_noopdatatype</code></li>
      </ol>
  </dd>
</dl>

</dir>

<h5><em>N-bit Compression and Decompression Functions</em></h5>

<p>The n-bit compression and decompression functions above are called 
  by the private HDF5 function <code>H5Z_filter_nbit</code>. 
  The compress and decompress functions retrieve the n-bit parameters
  from <code>cd_values[]</code> as it was passed by
  <code>H5Z_filter_nbit</code>. Parameters are retrieved in exactly the 
  same order in which they are stored and lower-level compression and 
  decompression functions for different datatype classes are called. </p>
<!--
  These functions are implementated according to the descriptions 
  in sections 2.1 and 2.2.
-->
  
<p>N-bit compression is not implemented in place. Due to the 
  difficulty of calculating actual output buffer size after compression, 
  the same space as that of the input buffer is allocated for the output 
  buffer as passed to the compression function. However, the size of the 
  output buffer passed by reference to the compression function will 
  be changed (smaller) after the compression is complete.</p>
  
<a name="examples">
<h4><em>Usage Examples</em></h4>
</a>

<p>The following code example illustrates the use of the n-bit filter 
  for writing and reading n-bit integer data.</p>


<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
<pre>
#include "hdf5.h"
#include "stdlib.h"
#include "math.h"
#define H5FILE_NAME  "nbit_test_int.h5"
#define DATASET_NAME "nbit_int"
#define NX 200
#define NY 300
#define CH_NX 10
#define CH_NY 15

int main(void)
{
   hid_t   file, dataspace, dataset, datatype, mem_datatype, dset_create_props;
   hsize_t dims[2], chunk_size[2];
   int     orig_data[NX][NY];
   int     new_data[NX][NY];
   int     i, j;
   size_t  precision, offset;


   /* Define dataset datatype (integer), and set precision, offset */
   datatype = H5Tcopy(H5T_NATIVE_INT);
   precision = 17; /* precision includes sign bit */
   if(H5Tset_precision(datatype,precision)&lt;0) {
      printf("Error: fail to set precision\n");
      return -1;
   }
   offset = 4;
   if(H5Tset_offset(datatype,offset)&lt;0) {
      printf("Error: fail to set offset\n");
      return -1;
   }


   /* Copy to memory datatype */
   mem_datatype = H5Tcopy(datatype);


   /* Set order of dataset datatype */
   if(H5Tset_order(datatype, H5T_ORDER_BE)&lt;0) {
      printf("Error: fail to set endianness\n");
      return -1;
   }


  /* Initiliaze data buffer with random data within correct range
   * corresponding to the memory datatype's precision and offset.
   */
   for (i=0; i &lt; NX; i++)
       for (j=0; j &lt; NY; j++)
           orig_data[i][j] = rand() % (int)pow(2, precision-1) &lt;&lt;offset;


   /* Describe the size of the array. */
   dims[0] = NX;
   dims[1] = NY;
   if((dataspace = H5Screate_simple (2, dims, NULL))&lt;0) {
      printf("Error: fail to create dataspace\n");
      return -1;
   }


  /*
   * Create a new file using read/write access, default file
   * creation properties, and default file access properties.
   */
   if((file = H5Fcreate (H5FILE_NAME, H5F_ACC_TRUNC,
                         H5P_DEFAULT, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create file\n");
      return -1;
   }


  /*
   * Set the dataset creation property list to specify that
   * the raw data is to be partitioned into 10 x 15 element
   * chunks and that each chunk is to be compressed.
   */
   chunk_size[0] = CH_NX;
   chunk_size[1] = CH_NY;
   if((dset_create_props = H5Pcreate (H5P_DATASET_CREATE))&lt;0) {
      printf("Error: fail to create dataset property\n");
      return -1;
   }
   if(H5Pset_chunk (dset_create_props, 2, chunk_size)&lt;0) {
      printf("Error: fail to set chunk\n");
      return -1;
   }


</pre><!-- NEW PAGE -->
<pre>
  /*
   * Set parameters for n-bit compression; check the description of
   * the H5Pset_nbit function in the HDF5 Reference Manual for more
   * information.
   */
   if(H5Pset_nbit (dset_create_props)&lt;0) {
      printf("Error: fail to set nbit filter\n");
      return -1;
   }


  /*
   * Create a new dataset within the file.  The datatype
   * and dataspace describe the data on disk, which may
   * be different from the format used in the application's
   * memory.
   */
   if((dataset = H5Dcreate(file, DATASET_NAME, datatype,
                          dataspace, H5P_DEFAULT, 
                          dset_create_props, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create dataset\n");
      return -1;
   }


  /*
   * Write the array to the file. The datatype and dataspace
   * describe the format of the data in the 'orig_data' buffer.
   * The raw data is translated to the format required on disk,
   * as defined above. We use default raw data transfer properties.
   */
   if(H5Dwrite (dataset, mem_datatype, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, orig_data)&lt;0) {
      printf("Error: fail to write to dataset\n");
      return -1;
   }


   H5Dclose (dataset);


   if((dataset = H5Dopen(file, DATASET_NAME, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to open dataset\n");
      return -1;
   }


  /*
   * Read the array. This is similar to writing data,
   * except the data flows in the opposite direction.
   * Note: Decompression is automatic.
   */
   if(H5Dread (dataset, mem_datatype, H5S_ALL, H5S_ALL,
               H5P_DEFAULT, new_data)&lt;0) {
      printf("Error: fail to read from dataset\n");
      return -1;
   }


</pre><!-- NEW PAGE -->
<pre>
   H5Tclose (datatype);
   H5Tclose (mem_datatype);
   H5Dclose (dataset);
   H5Sclose (dataspace);
   H5Pclose (dset_create_props);
   H5Fclose (file);

   return 0;
}</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 10. N-bit compression for integer data</b><br /> 
         Illustrates the use of the n-bit filter for writing and reading 
         n-bit integer data.
         <hr color="green" size="3"/></td>
        </tr>
</table>
<br />





<p>The following code example illustrates the use of the n-bit filter 
  for writing and reading n-bit floating-point data.</p>

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
<pre>
#include "hdf5.h"
#define H5FILE_NAME  "nbit_test_float.h5"
#define DATASET_NAME "nbit_float"
#define NX 2
#define NY 5
#define CH_NX 2
#define CH_NY 5


int main(void)
{
   hid_t   file, dataspace, dataset, datatype, dset_create_props;
   hsize_t dims[2], chunk_size[2];
  /* orig_data[] are initialized to be within the range that can be
   * represented by dataset datatype (no precision loss during
   * datatype conversion)
   */
   float   orig_data[NX][NY] = {{188384.00, 19.103516, -1.0831790e9,
   -84.242188, 5.2045898}, {-49140.000, 2350.2500, -3.2110596e-1,
   6.4998865e-5, -0.0000000}};
   float   new_data[NX][NY];
   size_t  precision, offset;


  /* Define single-precision floating-point type for dataset
   *-------------------------------------------------------------------
   * size=4 byte, precision=20 bits, offset=7 bits,
   * mantissa size=13 bits, mantissa position=7,
   * exponent size=6 bits, exponent position=20,
   * exponent bias=31.
   * It can be illustrated in little-endian order as:
   * (S - sign bit, E - exponent bit, M - mantissa bit,
   *  ? - padding bit)
   *
   *           3        2        1        0
   *       ?????SEE EEEEMMMM MMMMMMMM M???????
   *
   * To create a new floating-point type, the following
   * properties must be set in the order of
   *     set fields -> set offset -> set precision -> set size.
   * All these properties must be set before the type can function.
   * Other properties can be set anytime. Derived type size cannot
   * be expanded bigger than original size but can be decreased.
   * There should be no holes among the significant bits. Exponent
   * bias usually is set 2^(n-1)-1, where n is the exponent size.


*-------------------------------------------------------------------*/
   datatype = H5Tcopy(H5T_IEEE_F32BE);
   if(H5Tset_fields(datatype, 26, 20, 6, 7, 13)&lt;0) {
      printf("Error: fail to set fields\n");
      return -1;
   }
   offset = 7;
   if(H5Tset_offset(datatype,offset)&lt;0) {
      printf("Error: fail to set offset\n");
      return -1;
   }
   precision = 20;
   if(H5Tset_precision(datatype,precision)&lt;0) {
      printf("Error: fail to set precision\n");
      return -1;
   }
   if(H5Tset_size(datatype, 4)&lt;0) {
      printf("Error: fail to set size\n");
      return -1;
   }
   if(H5Tset_ebias(datatype, 31)&lt;0) {
      printf("Error: fail to set exponent bias\n");
      return -1;
   }


   /* Describe the size of the array. */
   dims[0] = NX;
   dims[1] = NY;
   if((dataspace = H5Screate_simple (2, dims, NULL))&lt;0) {
      printf("Error: fail to create dataspace\n");
      return -1;
   }


  /*
   * Create a new file using read/write access, default file
   * creation properties, and default file access properties.
   */
   if((file = H5Fcreate (H5FILE_NAME, H5F_ACC_TRUNC,
                         H5P_DEFAULT, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create file\n");
      return -1;
   }


  /*
   * Set the dataset creation property list to specify that
   * the raw data is to be partitioned into 2 x 5 element
   * chunks and that each chunk is to be compressed.
   */
   chunk_size[0] = CH_NX;
   chunk_size[1] = CH_NY;
   if((dset_create_props = H5Pcreate (H5P_DATASET_CREATE))&lt;0) {
      printf("Error: fail to create dataset property\n");
      return -1;
   }
   if(H5Pset_chunk (dset_create_props, 2, chunk_size)&lt;0) {
      printf("Error: fail to set chunk\n");
      return -1;
   }


  /*
   * Set parameters for n-bit compression; check the description
   * of the H5Pset_nbit function in the HDF5 Reference Manual
   * for more information.
   */
   if(H5Pset_nbit (dset_create_props)&lt;0) {
      printf("Error: fail to set nbit filter\n");
      return -1;
   }


  /*
   * Create a new dataset within the file.  The datatype
   * and dataspace describe the data on disk, which may
   * be different from the format used in the application's
   * memory.
   */
   if((dataset = H5Dcreate(file, DATASET_NAME, datatype,
                          dataspace, H5P_DEFAULT, 
                          dset_creat_plists, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create dataset\n");
      return -1;
   }


  /*
   * Write the array to the file. The datatype and dataspace
   * describe the format of the data in the 'orig_data' buffer.
   * The raw data is translated to the format required on disk,
   * as defined above. We use default raw data transfer properties.
   */
   if(H5Dwrite (dataset, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, orig_data)&lt;0) {
      printf("Error: fail to write to dataset\n");
      return -1;
   }


   H5Dclose (dataset);


   if((dataset = H5Dopen(file, DATASET_NAME, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to open dataset\n");
      return -1;
   }


  /*
   * Read the array. This is similar to writing data,
   * except the data flows in the opposite direction.
   * Note: Decompression is automatic.
   */
   if(H5Dread (dataset, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
               H5P_DEFAULT, new_data)&lt;0) {
      printf("Error: fail to read from dataset\n");
      return -1;
   }


   H5Tclose (datatype);
   H5Dclose (dataset);
   H5Sclose (dataspace);
   H5Pclose (dset_create_props);
   H5Fclose (file);


   return 0;
}</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 11. N-bit compression for floating-point data</b><br /> 
        Illustrates the use of the n-bit filter for writing and reading 
        n-bit floating-point data.
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />




<a name="limitations">
<h4><em>Limitations</em></h4>
</a>

<p>Because the array <code>cd_values[]</code> has to fit into an object 
  header message of 64K, the n-bit filter has an upper limit on the number 
  of n-bit parameters that can be stored in it. To be conservative, a maximum 
  of 4K is allowed for the number of parameters.</p>

<p>The n-bit filter currently only compresses n-bit datatypes or fields derived 
  from integer or floating-point datatypes. The n-bit filter assumes padding 
  bits of zero. This may not be true since the HDF5 user can set padding bit 
  to be zero, one, or leave the background alone. However, it is expected 
  the n-bit filter will be modified to adjust to such situations.</p>

<p>The n-bit filter does not have a way to handle the situation where the  
  fill value of a dataset is defined and the fill value is not of an n-bit 
  datatype although the dataset datatype is.</p>


<!-- NEW PAGE -->
<a name="ScaleOffset">
<h3>5.6.2. Using the Scale-offset Filter</h3>
</a> 

<p>Generally speaking, scale-offset compression performs a scale and/or 
  offset operation on each data value and truncates the resulting value 
  to a minimum number of bits (minimum-bits) before storing it. </p>

<p>The current scale-offset filter supports integer and floating-point 
  datatypes only. For the floating-point datatype, float and double are 
  supported, but long double is not supported.</p>

<p>Integer data compression uses a straight-forward algorithm. Floating-point 
  data compression adopts the GRiB data packing mechanism which offers 
  two alternate methods: a fixed minimum-bits method, and a variable 
  minimum-bits method. Currently, only the variable minimum-bits method 
  is implemented. <!-- 9.3.10, MEE: according to Kent, the fixed minimum-bits 
  method has not yet been implemented, and they do not have any plans to 
  implement it. --></p>

  <p>Like other I/O filters supported by the HDF5 Library, applications 
  using the scale-offset filter must store data with chunked storage.</p>
  
  <p><b><i>Integer type:</i></b>
  The minimum-bits of integer data can be determined by the filter. 
  For example, if the maximum value of data to be compressed is 7065 
  and the minimum value is 2970. Then the &ldquo;span&rdquo; of dataset 
  values is equal to (max-min+1), which is 4676. If no fill value is 
  defined for the dataset, the minimum-bits is: 
  <code>ceiling(log2(span)) = 12</code>. With fill value set, the 
  minimum-bits is: <code>ceiling(log2(span+1)) = 13</code>.</p>

  <p>HDF5 users can also set the minimum-bits. However, if the user gives 
  a minimum-bits that is less than that calculated by the filter, 
  the compression will be lossy.</p>

  <p><b><i>Floating-point type:</i></b>
  The basic idea of the scale-offset filter for the floating-point type is 
  to transform the data by some kind of scaling to integer data, and 
  then to follow the procedure of the scale-offset filter for the integer 
  type to do the data compression. Due to the data transformation from 
  floating-point to integer, the scale-offset filter is 
  lossy in nature. </p>

  <p>Two methods of scaling the floating-point data are used: the so-called 
  D-scaling and E-scaling. D-scaling is more straightforward and easy to 
  understand. For HDF5 1.8 release, only the D-scaling method has been 
  implemented. <!-- 9.3.10, MEE: According to Kent, E-scaling has not yet 
  been implemented, and they have no plans to implement it in the future. --></p>
  
<h4><em>Design</em></h4>

  <p>Before the filter does any real work, it needs to gather some information 
  from the HDF5 Library through API calls. The parameters the filter needs 
  are: </p>
  <ul>
    <li>The minimum-bits of the data value</li>
    <li>The number of data elements in the chunk</li>
    <li>The datatype class, size, sign (only for integer type), byte order, 
    and fill value 
    if defined</li> 
  </ul>
  
  <p>Size and sign are needed to determine what kind of pointer 
  cast to use when retrieving values from the data buffer.</p>
  <p>The pipeline of the filter can be divided into four parts: 
  (1)pre-compression; (2)compression; (3)decompression; 
  (4)post-decompression.</p>

  <p>Depending on whether a fill value is defined or not, the filter will 
  handle pre-compression and post-decompression differently. </p>

  <p>The scale-offset filter only needs the memory byte order, size of 
  datatype, and minimum-bits for compression and decompression.</p>

  <p>Since decompression has no access to the original data, the minimum-bits 
  and the minimum value need to be stored with the compressed data for 
  decompression and post-decompression.</p>
  

<h5><em>Integer Type</em></h5>

  <p><i>Pre-compression: </i>
  During pre-compression minimum-bits is calculated if it is not 
  set by the user. For more information on how minimum-bits are calculated, 
  see section 6.1. &ldquo;The N-bit Filter.&rdquo; </p>
 
  <p>If the fill value is defined, finding the maximum and minimum values 
  should ignore the data element whose value is equal to the fill value. </p>

  <p>If no fill value is defined, the value of each data element is subtracted 
  by the minimum value during this stage.</p>

  <p>If the fill value is defined, the fill value is assigned to the maximum 
  value. In this way minimum-bits can represent a data element whose value 
  is equal to the fill value and subtracts the minimum value from a data 
  element whose value is not equal to the fill value.</p>
<!-- 8.19.10, MEE: the paragraph belowis is Frank's revision of my editing -->
<!-- 9.3.10, MEE: Kent reviewed the paragraph below and said it was clear. -->
  <p>The fill value (if defined), the number of elements in a chunk, the 
  class of the datatype, the size of the datatype, the memory order of the 
  datatype, and other similar elements will be stored in the HDF5 object 
  header for the post-decompression usage.</p>

  <p>After pre-compression, all values are non-negative and are within the 
  range that can be stored by minimum-bits.</p>
  


  <p><i>Compression: </i>
  All modified data values after pre-compression are packed together 
  into the compressed data buffer. The number of bits for each data value 
  decreases from the number of bits of integer (32 for most platforms) to 
  minimum-bits. The value of minimum-bits and the minimum value are added to 
  the data buffer and the whole buffer is sent back to the library. In this 
  way, the number of bits for each modified value is no more than 
  the size of minimum-bits.</p>
  

  <p><i>Decompression: </i>
  In this stage, the number of bits for each data value is resumed from 
  minimum-bits to the number of bits of integer.</p>


  <p><i>Post-decompression: </i>
  For the post-decompression stage, the filter does the opposite 
  of what it does during pre-compression except that it does not calculate 
  the minimum-bits or the minimum value. These values were saved during 
  compression and can be retrieved through the resumed data buffer. If 
  no fill value is defined, the filter adds the minimum value back to 
  each data element.</p>

  <p>If the fill value is defined, the filter assigns the fill value to the 
  data element whose value is equal to the maximum value that minimum-bits can 
  represent and adds the minimum value back to each data element whose value 
  is not equal to the maximum value that minimum-bits can represent.</p>

<a name="SO_FloatingPoint"><p>&nbsp;</p></a>
  

<h5><em>Floating-point Type</em></h5>

  <p>The filter will do data transformation from floating-point type to 
  integer type and then handle the data by using the procedure for handling 
  the integer data inside the filter.  
  Insignificant bits of floating-point data will be cut off 
  during data transformation, so this filter is a lossy compression method.</p>

  <p>There are two scaling methods: D-scaling and E-scaling. 
  The HDF5 1.8 release only supports D-scaling. D-scaling is short for 
  decimal scaling. E-scaling should be similar conceptually. In order 
  to transform data from floating-point to 
  integer, a scale factor is introduced. The minimum value will be calculated. 
  Each data element value will subtract the minimum value. The modified data 
  will be multiplied by 10 (Decimal) to the power of <code>scale_factor</code>, 
  and only the integer part will be kept and manipulated through the routines 
  for the integer type of the filter during pre-compression and compression. 
  Integer data will be divided by 10 to the power of 
  <code>scale_factor</code> to transform back to floating-point data 
  during decompression and post-decompression.  
  Each data element value will then add the minimum value, and the 
  floating-point data are resumed. However, the resumed data will lose some 
  insignificant bits compared with the original value.</p>

  <p>For example, the following floating-point data are manipulated by the 
  filter, and the D-scaling factor is 2.</p>
  
  <code>{104.561, 99.459, 100.545, 105.644}</code>

  <p>The minimum value is 99.459, each data element subtracts 99.459, the 
  modified data is </p>
  
  <code>{5.102, 0, 1.086, 6.185}</code>

  <p>Since the D-scaling factor is 2, all floating-point data will be 
  multiplied by 10^2 with this result: </p>

  <code>{510.2, 0, 108.6, 618.5}</code>

  <p>The digit after decimal point will be rounded off, and then the set looks 
  like: </p>
  
  <code>{510 , 0, 109, 619}</code>

  <p>After decompression, each value will be divided by 10^2 and will be added 
  to the offset 99.459.</p>

<p>The floating-point data becomes </p>

  <code>{104.559, 99.459, 100.549, 105.649}</code>.

<p>The relative error for each value should be no more than 
  5* (10^(D-scaling factor +1)). D-scaling sometimes is also referred 
  as a variable minimum-bits method since for different datasets the 
  minimum-bits to represent the same decimal precision will vary. The 
  data value is modified to 2 to power of <code>scale_factor</code> for 
  E-scaling. E-scaling is also called fixed-bits method since for different 
  datasets the minimum-bits will always be fixed to the scale factor of 
  E-scaling. 
  Currently HDF5 ONLY supports D-scaling (variable minimum-bits) method.</p>
  
<h4><em>Implementation</em></h4>

<p>The scale-offset filter implementation was written and included in the file 
  <code>H5Zscaleoffset.c</code>. Function <code>H5Pset_scaleoffset</code> was 
  written and included in the file &ldquo;<code>H5Pdcpl.c</code>&rdquo;. The 
  HDF5 user can supply minimum-bits by calling function 
  <code>H5Pset_scaleoffset</code>.</p>

<!-- NEW PAGE -->
<p>The scale-offset filter was implemented based on the design outlined in 
  this section. However, the following factors need to be considered:</p>
  
<dl>
  <dd>
    <ol>
      <li>The filter needs the appropriate cast pointer whenever it needs 
        to retrieve data values.</li>
      <li>The HDF5 Library passes to the filter the to-be-compressed data 
        in the format of the dataset datatype, and the filter passes back the 
        decompressed data in the same format. If a fill value is defined, 
        it is also in dataset datatype format. 
        For example, if the byte order of the dataset datatype is different 
        from that of the memory datatype of the platform, compression or 
        decompression performs an endianness conversion of data buffer. 
        Moreover, it should be aware that memory byte order can be different 
        during compression and decompression.</li>
      <li>The difference of endianness and datatype between file and memory 
        should be considered when saving and retrieval of minimum-bits, 
        minimum value, and fill value.</li>
      <li>If the user sets the minimum-bits to full precision of the datatype, 
        no operation is needed at the filter side. If the full precision is 
        a result of calculation by the filter, then the minimum-bits needs 
        to be saved for decompression but no compression or decompression 
        is needed (only a copy of the input buffer is needed).</li>
      <li>If by calculation of the filter, the minimum-bits is equal to zero, 
        special handling is needed. Since it means all values are the same, 
        no compression or decompression is needed. But the minimum-bits 
        and minimum value still need to be saved during compression.</li>
      <li>For floating-point data, the minimum value of the dataset should 
        be calculated at first. Each data element value will then subtract 
        the minimum value to obtain the &ldquo;offset&rdquo; data. 
        The offset data will then follow the steps outlined above in the
        discussion of <a href="#SO_FloatingPoint">floating-point types</a>
        to do data transformation to integer and rounding.</li>
    </ol>
  </dd>
</dl>

<h4><em>Usage Examples</em></h4>

<p>The following code example illustrates the use of the scale-offset filter 
  for writing and reading integer data.</p>

<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
<pre>
#include "hdf5.h"
#include "stdlib.h"
#define H5FILE_NAME  "scaleoffset_test_int.h5"
#define DATASET_NAME "scaleoffset_int"
#define NX 200
#define NY 300
#define CH_NX 10
#define CH_NY 15
</pre>

<pre>
int main(void)
{
   hid_t   file, dataspace, dataset, datatype, dset_create_props;
   hsize_t dims[2], chunk_size[2];
   int     orig_data[NX][NY];
   int     new_data[NX][NY];   
   int     i, j, fill_val;   

   /* Define dataset datatype */
   datatype = H5Tcopy(H5T_NATIVE_INT);   
   
   /* Initiliaze data buffer */
   for (i=0; i &lt; NX; i++) 
       for (j=0; j &lt; NY; j++)
           orig_data[i][j] = rand() % 10000;

   /* Describe the size of the array. */
   dims[0] = NX;
   dims[1] = NY;
   if((dataspace = H5Screate_simple (2, dims, NULL))&lt;0) {
      printf("Error: fail to create dataspace\n");
      return -1;
   }

  /*
   * Create a new file using read/write access, default file
   * creation properties, and default file access properties.
   */
   if((file = H5Fcreate (H5FILE_NAME, H5F_ACC_TRUNC, 
                         H5P_DEFAULT, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create file\n");
      return -1;
   }

  /*
   * Set the dataset creation property list to specify that
   * the raw data is to be partitioned into 10 x 15 element
   * chunks and that each chunk is to be compressed.
   */
   chunk_size[0] = CH_NX;
   chunk_size[1] = CH_NY;
   if((dset_create_props = H5Pcreate (H5P_DATASET_CREATE))&lt;0) {
      printf("Error: fail to create dataset property\n");
      return -1;
   }
   if(H5Pset_chunk (dset_create_props, 2, chunk_size)&lt;0) {
      printf("Error: fail to set chunk\n");
      return -1;
   }

   /* Set the fill value of dataset */
   fill_val = 10000;
   if (H5Pset_fill_value(dset_create_props, H5T_NATIVE_INT, 
       &amp;fill_val)&lt;0) {
      printf("Error: can not set fill value for dataset\n");
      return -1;
   }

  /*
   * Set parameters for scale-offset compression. Check the 
   * description of the H5Pset_scaleoffset function in the 
   * HDF5 Reference Manual for more information [3].
   */
   if(H5Pset_scaleoffset (dset_create_props, H5Z_SO_INT, 
                          H5Z_SO_INT_MINIMUMBITS_DEFAULT)&lt;0) {
      printf("Error: fail to set scaleoffset filter\n");
      return -1;
   }

  /*
   * Create a new dataset within the file. The datatype
   * and dataspace describe the data on disk, which may
   * or may not be different from the format used in the 
   * application's memory.  The link creation and 
   * dataset access property list parameters are passed 
   * with default values.
   */
   if((dataset = H5Dcreate (file, DATASET_NAME, datatype,
                           dataspace, H5P_DEFAULT,
                           dset_create_props, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create dataset\n");
      return -1;
   }

  /*
   * Write the array to the file. The datatype and dataspace
   * describe the format of the data in the 'orig_data' buffer.
   * We use default raw data transfer properties.
   */
   if(H5Dwrite (dataset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, orig_data)&lt;0) {
      printf("Error: fail to write to dataset\n");
      return -1;
   }

   H5Dclose (dataset);

   if((dataset = H5Dopen(file, DATASET_NAME, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to open dataset\n");
      return -1;
   }   

  /*
   * Read the array. This is similar to writing data,
   * except the data flows in the opposite direction.
   * Note: Decompression is automatic.
   */
   if(H5Dread (dataset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL,
               H5P_DEFAULT, new_data)&lt;0) {
      printf("Error: fail to read from dataset\n");
      return -1;
   }

   H5Tclose (datatype);
   H5Dclose (dataset);
   H5Sclose (dataspace);
   H5Pclose (dset_create_props);
   H5Fclose (file);

   return 0;
}</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 12. Scale-offset compression integer data</b><br />
        Illustrates the use of the scale-offset filter for writing 
        and reading integer data.
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />

<!-- NEW PAGE -->
<p>The following code example illustrates the use of the scale-offset filter 
  (set for variable minimum-bits method) for writing and reading 
  floating-point data.</p>
  
<table width="600" cellspacing="0" align="center">
    <tr valign="top"> 
        <td align="left">
        <hr color="green" size="3"/>
<pre>
#include "hdf5.h"
#include "stdlib.h"
#define H5FILE_NAME  "scaleoffset_test_float_Dscale.h5"
#define DATASET_NAME "scaleoffset_float_Dscale"
#define NX 200
#define NY 300
#define CH_NX 10
#define CH_NY 15
</pre>

<pre>
int main(void)
{
   hid_t   file, dataspace, dataset, datatype, dset_create_props;
   hsize_t dims[2], chunk_size[2];
   float   orig_data[NX][NY];
   float   new_data[NX][NY];
   float   fill_val;   
   int     i, j;   

   /* Define dataset datatype */
   datatype = H5Tcopy(H5T_NATIVE_FLOAT);   
   
   /* Initiliaze data buffer */
   for (i=0; i &lt; NX; i++) 
       for (j=0; j &lt; NY; j++)
           orig_data[i][j] = (rand() % 10000) / 1000.0;

   /* Describe the size of the array. */
   dims[0] = NX;
   dims[1] = NY;
   if((dataspace = H5Screate_simple (2, dims, NULL))&lt;0) {
      printf("Error: fail to create dataspace\n");
      return -1;
   }

  /*
   * Create a new file using read/write access, default file
   * creation properties, and default file access properties.
   */
   if((file = H5Fcreate (H5FILE_NAME, H5F_ACC_TRUNC, 
                         H5P_DEFAULT, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create file\n");
      return -1;
   }

  /*
   * Set the dataset creation property list to specify that
   * the raw data is to be partitioned into 10 x 15 element
   * chunks and that each chunk is to be compressed.
   */
   chunk_size[0] = CH_NX;
   chunk_size[1] = CH_NY;
   if((dset_create_props = H5Pcreate (H5P_DATASET_CREATE))&lt;0) {
      printf("Error: fail to create dataset property\n");
      return -1;
   }
   if(H5Pset_chunk (dset_create_props, 2, chunk_size)&lt;0) {
      printf("Error: fail to set chunk\n");
      return -1;
   }

   /* Set the fill value of dataset */
   fill_val = 10000.0;
   if (H5Pset_fill_value(dset_create_props, H5T_NATIVE_FLOAT, 
       &amp;fill_val)<0) {
      printf("Error: can not set fill value for dataset\n");
      return -1;
   }

  /*
   * Set parameters for scale-offset compression; use variable
   * minimum-bits method, set decimal scale factor to 3. Check the 
   * description of the H5Pset_scaleoffset function in the HDF5 
   * Reference Manual for more information [3].
   */
   if(H5Pset_scaleoffset (dset_create_props, H5Z_SO_FLOAT_DSCALE, 3)&lt;0) {
      printf("Error: fail to set scaleoffset filter\n");
      return -1;
   }

  /*
   * Create a new dataset within the file. The datatype
   * and dataspace describe the data on disk, which may
   * or may not be different from the format used in the 
   * application's memory.
   */
   if((dataset = H5Dcreate (file, DATASET_NAME, datatype,
                            dataspace, H5P_DEFAULT, 
                            dset_create_props, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to create dataset\n");
      return -1;
   }

  /*
   * Write the array to the file. The datatype and dataspace
   * describe the format of the data in the 'orig_data' buffer.
   * We use default raw data transfer properties.
   */
   if(H5Dwrite (dataset, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, orig_data)&lt;0) {
      printf("Error: fail to write to dataset\n");
      return -1;
   }

   H5Dclose (dataset);

   if((dataset = H5Dopen(file, DATASET_NAME, H5P_DEFAULT))&lt;0) {
      printf("Error: fail to open dataset\n");
      return -1;
   }   

  /*
   * Read the array. This is similar to writing data,
   * except the data flows in the opposite direction.
   * Note: Decompression is automatic.
   */
   if(H5Dread (dataset, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
               H5P_DEFAULT, new_data)&lt;0) {
      printf("Error: fail to read from dataset\n");
      return -1;
   }

   H5Tclose (datatype);
   H5Dclose (dataset);
   H5Sclose (dataspace);
   H5Pclose (dset_create_props);
   H5Fclose (file);

   return 0;
}</pre></td>
        </tr>
    <tr><td><hr color="green" size="1" /></td></tr>
    <tr valign="top">
        <td align="left">
        <b>Example 13. Scale-offset compression floating-point data</b><br />
        Illustrates the use of the scale-offset filter for writing 
        and reading floating-point data.
        <hr color="green" size="3"/></td>
        </tr>
</table>
<br />




<h4><em>Limitations</em></h4>

  <p>For floating-point data handling, there are some algorithmic 
  limitations to the GRiB data packing mechanism:</p>

<dl>
  <dd>
    <ol>
      <li>Both the E-scaling and D-scaling methods are lossy compression</li>
      <li>For the D-scaling method, since data values have been rounded to 
        integer values (positive) before truncating to the minimum-bits, 
        their range is limited by the maximum value that can be represented 
        by the corresponding unsigned integer type (the same size as that of 
        the floating-point type)</li>
    </ol>
  </dd>
</dl>

<h4><em>Suggestions</em></h4>

<p>The following are some suggestions for using the filter for 
floating-point data:</p>

<dl>
  <dd>
    <ol>
      <li>It is better to convert the units of data so that the units are 
        within certain common range (for example, 1200m to 1.2km)</li>
      <li>If data values to be compressed are very near to zero, it 
        is strongly recommended that the user sets the fill value away 
        from zero (for example, a large positive number); if the user 
        does 
        nothing, the HDF5 Library will set the fill value to zero, and 
        this may cause undesirable compression results</li>
      <li>Users are not encouraged to use a very large decimal scale 
        factor (e.g. 100) for the D-scaling method; this can cause the 
        filter not to ignore the fill value when finding maximum and minimum 
        values, and they will get a much larger minimum-bits (poor 
        compression)</li>
    </ol>
  </dd>
</dl>



  

<a name="Szip">
<h3>5.6.3. Using the Szip Filter</h3>
</a>

  <p>See The HDF Group website for 
  <a href="http://www.hdfgroup.org/doc_resource/SZIP/" target="Ext1">further 
  information</a> regarding the Szip filter.</p>

<p>&nbsp;</p>
<p>&nbsp;</p>





<!-- HEADER RIGHT " " -->

</body>
</html>

  
