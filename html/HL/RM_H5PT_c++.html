<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title> Packet Table C++ Wrapper Reference Manual </title>
</head>

<body bgcolor="#FFFFFF">

<!-- HEADER RIGHT " " -->
<!-- HEADER RIGHT "Packet Table" -->

<a name="TopofRM">
&nbsp;</a><!-- #BeginLibraryItem "/ed_libs/NavBar_RMHL.lbi" --><hr>
<center>
<table border=0 width=98%>
<tr><td valign=top align=left>
<a href="../index.html">HDF5 documents and links</a>&nbsp;<br>
<a href="../H5.intro.html">Introduction to HDF5</a>&nbsp;<br>
<a href="http://hdf.ncsa.uiuc.edu/HDF5/doc/UG/index.html">HDF5 User Guide</a>&nbsp;<br>
<a href="index.html">Other High-level API documents</a>
<!--
<a href="Glossary.html">Glossary</a><br>
-->
</td>
<td valign=top align=right>
And in this document, the 
<a href="../RM/RM_H5Front.html">HDF5 Reference Manual</a>&nbsp;&nbsp;
<br>
<a href="RM_H5DS.html">H5DS</a>&nbsp;&nbsp;
<a href="RM_H5IM.html">H5IM</a>&nbsp;&nbsp;
<a href="RM_H5LT.html">H5LT</a>&nbsp;&nbsp;
<a href="RM_H5PT.html">H5PT</a>&nbsp;&nbsp;
<a href="RM_H5TB.html">H5TB</a>&nbsp;&nbsp;
<br>
<a href="../RM/RM_H5.html">H5</a>&nbsp;&nbsp;
<a href="../RM/RM_H5A.html">H5A</a>&nbsp;&nbsp;
<a href="../RM/RM_H5D.html">H5D</a>&nbsp;&nbsp;
<a href="../RM/RM_H5E.html">H5E</a>&nbsp;&nbsp;
<a href="../RM/RM_H5F.html">H5F</a>&nbsp;&nbsp;
<a href="../RM/RM_H5G.html">H5G</a>&nbsp;&nbsp;
<a href="../RM/RM_H5I.html">H5I</a>&nbsp;&nbsp;
<a href="../RM/RM_H5P.html">H5P</a>&nbsp;&nbsp;
<br>
<a href="../RM/RM_H5R.html">H5R</a>&nbsp;&nbsp;
<a href="../RM/RM_H5S.html">H5S</a>&nbsp;&nbsp;
<a href="../RM/RM_H5T.html">H5T</a>&nbsp;&nbsp;
<a href="../RM/RM_H5Z.html">H5Z</a>&nbsp;&nbsp;
<a href="../RM/Tools.html">Tools</a>&nbsp;&nbsp;
<a href="../RM/PredefDTypes.html">Datatypes</a>&nbsp;&nbsp;
</td></tr>
</table>
</center>
<hr>
<!-- #EndLibraryItem --><h1 align="center">H5PT: HDF5 Packet Table<br>C++ Wrappers</h1>

<!--
<h2>Draft</h2>
-->

<br>
<strong>Classes:</strong>

<ul>
<li><strong>PacketTable</strong> - functions shared by all packet tables
<li><strong>FL_PacketTable</strong> - a packet table storing fixed-length packets
<li><strong>VL_PacketTable</strong> - a packet table storing variable-length packets
</ul>

  <strong>Functions</strong> (none are static; all must be called on an object):  

  <br><br> <hr><strong>Packet Table:</strong> <hr>
  
  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong>
        Null Constructor
  <dt><strong>Signature:</strong></dt>
        <dd>PacketTable( )</dd>
  <dt><strong>Purpose:</strong></dt>
        <dd>Creates an invalid packet table object.</dd>
  <dt><strong>Description:</strong></dt>
        <dd>The object created with this call will return false if IsValid() is
            called on it.  To create a valid packet table, use the
            FL_Packet_Table or VL_Packet_Table constructors.
            This function does not make any change to the underlying HDF5 file.
    </dd>
  </dl>
  <hr>

  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong>
	"Open" Constructor
  <dt><strong>Signature:</strong></dt>
	<dd>PacketTable(hid_t fileID, char* name)</dd>
  <dt><strong>Purpose:</strong></dt>
	<dd>Opens an existing packet table.</dd>
  <dt><strong>Description:</strong></dt>
	<dd>Opens an existing packet table, which can contain either fixed-length 
	    or variable-length packets.</dd>
  <dt><strong>Parameters:</strong></dt>
    <dl>
	<dt>hid_t fileID</dt>
		<dd>IN:  file or group in which the packet table is located</dd>
	<dt>char* name</dt>
		<dd>IN:  the packet table's name</dd>
    </dl>
  </dl>
  
<!-- NEW PAGE -->
  <hr>
  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong>
	Destructor
  <dt><strong>Signature:</strong></dt>
	<dd>~PacketTable()</dd>
  <dt><strong>Description:</strong></dt>
	<dd>The destructor closes the packet table in the file, so a packet 
	    table created or opened with the C++ wrapper does not 
		need to be closed manually.</dd>	
  </dl>
  <hr>

  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong> IsValid
  <dt><strong>Signature:</strong></dt>
	<dd>bool IsValid()</dd>
  <dt><strong>Purpose:</strong></dt>
	<dd>Determines if this is an valid packet table.</dd>
  <dt><strong>Description:</strong></dt>
	<dd>This function is used to ensure that a PacketTable object 
	    corresponds to an open packet table in the file.  It should be 
		called after the constructor to check that there were no errors 
		creating or opening the packet table.</dd>
  <dt><strong>Returns:</strong></dt>
	<dd>Returns true if this is an open packet table, false otherwise.</dd>
  </dl>
  <hr>	

  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong> IsVariableLength
  <dt><strong>Signature:</strong></dt>
	<dd>int IsVariableLength()</dd>
  <dt><strong>Purpose:</strong></dt>
	<dd>Determines if this is a variable-length packet table.</dd>
  <dt><strong>Description:</strong></dt>
	<dd>The PacketTable class has no functions to read from or write to the file.  
	However, this function can be used to determine whether an unknown packet 
	table should be opened using the FL_PacketTable or VL_PacketTable class.</dd>
  <dt><strong>Returns:</strong></dt>
	<dd>Returns 1 if this is a variable-length packet table, 0 if it is fixed-length.  
	If the table is invalid (not open), returns a negative value.</dd>
  </dl>
  <hr>

  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong> ResetIndex
  <dt><strong>Signature:</strong></dt>
	<dd>void ResetIndex()</dd>
  <dt><strong>Purpose:</strong></dt>
	<dd>Resets the packet table's index to point to the first packet.</dd>
  <dt><strong>Description:</strong></dt>
	<dd>A packet table keeps track of the user's current location in the table 
	    so that the user can iterate through packets.  This function should be 
            called before using GetNextPacket.</dd>
  </dl>
  
<!-- NEW PAGE -->  
  <hr>
  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong> SetIndex
  <dt><strong>Signature:</strong></dt>
	<dd>int SetIndex(unsigned int index);</dd>
  <dt><strong>Purpose:</strong></dt>
	<dd>Sets a packet table's current index.</dd>
  <dt><strong>Description:</strong></dt>
	<dd>This function allows the user to begin iterating through packets 
	    starting from any arbitrary index.  Packet tables are zero-indexed, 
	    so packet 0 is the first packet.</dd>
  <dt><strong>Parameters:</strong></dt>
	<dl>
	<dt>unsigned int index</dt>
		<dd>IN: The value to which the packet table's index should be set</dd>
	</dl>
  <dt><strong>Returns:</strong></dt>
	<dd>Returns non-negative on success, negative on error.</dd>
  </dl>
  <hr>

  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong> GetPacketCount
  <dt><strong>Signatures:</strong></dt>
	<dd>unsigned int GetPacketCount()</dd>
	<dd>unsigned int GetPacketCount(int&amp; error)</dd>
  <dt><strong>Purpose:</strong></dt>
	<dd>Retrieves the number of packets in the packet table.</dd>
  <dt><strong>Description:</strong></dt>
	<dd>This function is overloaded so that it can be called with or 
	    without returning an error value.  If <code>error</code> is not
            supplied, any error value is ignored.  Using this parameter allows
            the user to distinguish between an open packet table with 0
            packets and an invalid packet table.</dd>
  <dt><strong>Parameters:</strong></dt>
	<dl>
	<dt>int&amp; error  (optional)</dt>
		<dd>OUT: Non-negative if packet count was successfully retrieved, 
		    negative if packet table is invalid.</dd>
	</dl>
  <dt><strong>Returns:</strong></dt>
	<dd>Number of packets in packet table.  Returns 0 if packet table 
	    contains zero packets or on error.</dd>
  </dl>
  
<!-- NEW PAGE -->
<!-- HEADER RIGHT "FL_Packet_Table" -->
  <hr>
<strong>FL_Packet_Table:</strong><hr>

  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong> "Create" Constructor
  <dt><strong>Signature:</strong></dt>
	<dd>FL_PacketTable(hid_t fileID, char* name, hid_t dtypeID, int chunkSize)</dd>
  <dt><strong>Purpose:</strong></dt>
	<dd>Creates a new packet table for storing fixed-length packets.</dd>
  <dt><strong>Description:</strong></dt>
	<dd>This constructor creates and opens a packet table in the file 
	    specified by <code>fileID</code> named <code>name</code>.  Packets
	    will be of the datatype specified by <code>dtypeID</code>.</dd>
  <dt><strong>Parameters:</strong></dt>
	<dl>
	<dt>hid_t fileID</dt>
	<dd>IN: Identifier of the file or group to create the table within.</dd> 
	<dt>const char * dset_name</dt> 
	<dd>IN: The name of the packet table to create.</dd> 
	<dt>hid_t dtype_id</dt> 
	<dd>IN: The datatype of a packet.</dd> 
	<dt>hsize_t chunkSize</dt> 
	<dd>IN: The packet table uses HDF5 chunked storage to allow it to grow. 
	    This value allows the user to set the size of a chunk. 
	    The chunk size affects performance.</dd>
    </dl>
  </dl>
  <hr>

  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong> "Open" Constructor
  <dt><strong>Signature:</strong></dt>
	<dd>FL_PacketTable(hid_t fileID, char* name)</dd>
  <dt><strong>Purpose:</strong></dt>
	<dd>Opens a fixed-length packet table.</dd>
  <dt><strong>Description:</strong></dt>
	<dd>This constructor opens an existing packet table named
	 <code>name</code> in the location <code>fileID</code>.  This packet
	table must be fixed-length.</dd>
  <dt><strong>Parameters:</strong></dt>
    <dl>
	<dt>hid_t fileID</dt>
	<dd>IN: Identifier of the file or group containing the packet table.</dd> 
	<dt>const char * dset_name</dt> 
	<dd>IN: The name of the packet table to open.</dd>
    </dl>
  </dl>
  <hr>

  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong> AppendPacket /
        AppendPackets
  <dt><strong>Signature:</strong></dt>
	<dd>int AppendPacket(void * data)</dd>
	<dd>int AppendPackets(unsigned int numPackets, void *data)</dd>
  <dt><strong>Purpose:</strong></dt>
	<dd>Appends fixed-length packets to the packet table.</dd>
  <dt><strong>Description:</strong></dt>
	<dd>This function writes packets to the end of the packet table.  
	    If only one argument is given, it is assumed that only a single 
	    packet is being written.</dd>
<!-- NEW PAGE -->
  <dt><strong>Parameters:</strong></dt>
	<dl>
	<dt>unsigned int numPackets (optional)</dt>
	<dd>IN: Number of packets to add.  Default is one.</dd>
	<dt>void * data:</dt>
	<dd>IN: Data to write.  Must be a buffer of packets of the packet
            table's datatype.</dd>
	</dl>
  <dt><strong>Returns:</strong></dt>
	<dd>Returns non-negative value on success, negative on error.</dd>
  </dl>
  <hr>

  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong> GetPacket /
        GetPackets
  <dt><strong>Signatures:</strong></dt>
	<dd>int GetPacket(unsigned int index, void * data)</dd>
	<dd>int GetPackets(unsigned int startIndex, unsigned int endIndex, void * data)</dd>
  <dt><strong>Purpose:</strong></dt>
	<dd>Reads packets from the packet table.</dd>
  <dt><strong>Description:</strong></dt>
	<dd>This function fills a buffer, <code>data</code>, with fixed-length
            packets from the packet table.  The one-argument function can be
            called to retrieve a single packet at the given index, or the
            two-argument function used to read a range of packets
            (zero-indexed, inclusive).</dd>
  <dt><strong>Parameters:</strong></dt>
	<dl>
	<dt>unsigned int index (single packet)</dt>
		<dd>IN: Index of the single packet to be read</dd>
	<dt>unsigned int startIndex (multiple packets)</dt>
		<dd>IN: Index at which to start reading packets</dd>
	<dt>unsigned int endIndex (multiple packets)</dt>
		<dd>IN: Index at which to stop reading packets</dd>
	<dt>void * data</dt>
		<dd>OUT: Buffer for packets being retrieved</dd>
	</dl>
  <dt><strong>Returns:</strong></dt>
	<dd>Returns non-negative on success, negative on error.</dd>
  </dl>
  <hr>

  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong> GetNextPacket /
        Get Next Packets
  <dt><strong>Signatures:</strong></dt>
	<dd>int GetNextPacket(void * data)</dd>
	<dd>int GetNextPackets(unsigned int numPackets, void * data)</dd>
  <dt><strong>Purpose:</strong></dt>
	<dd>Iterates through packets from the packet table.</dd>
  <dt><strong>Description:</strong></dt>
	<dd>This function reads packets starting from the current index in the 
	    packet table and updates the index.  It can be used with the ResetIndex 
	    and SetIndex functions to iterate through the packet table.  
	    There are versions of this function that can be called with or
            without the <code>numPackets</code> argument; if this argument is
            not supplied, it defaults to one.</dd>
  <dt><strong>Parameters:</strong></dt>
	<dl>
	<dt>unsigned int numPackets (optional)</dt>
		<dd>IN:  How many packets to read.  Defaults to one.</dd>
	<dt>void * data</dt>
		<dd>OUT: Buffer to hold packets being read.</dd>
	</dl>
  <dt><strong>Returns:</strong></dt>
	<dd>Returns non-negative on success, negative on error.</dd>
  </dl>
  
<!-- NEW PAGE -->
<!-- HEADER RIGHT "VL_Packet_Table" -->
  <hr>
<strong>VL_Packet_Table:</strong><hr>

  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong> "Create" Constructor
  <dt><strong>Signature:</strong></dt>
	<dd>VL_PacketTable(hid_t fileID, char* name, int chunkSize)</dd>
  <dt><strong>Purpose:</strong></dt>
	<dd>Creates a new packet table for storing variable-length packets.</dd>
  <dt><strong>Description:</strong></dt>
	<dd>This constructor creates and opens a packet table in the file 
	    specified by <code>fileID</code> named <code>name</code>.</dd>
  <dt><strong>Parameters:</strong></dt>
	<dl>
	<dt>hid_t fileID</dt>
	<dd>IN: Identifier of the file or group to create the table within.</dd> 
	<dt>const char * dset_name</dt>
	<dd>IN: The name of the packet table to create.</dd>
	<dt>hsize_t chunkSize</dt>
	<dd>IN: The packet table uses HDF5 chunked storage to allow it to grow. 
	    This value allows the user to set the size of a chunk. 
	    The chunk size affects performance.</dd>
	</dl>
  </dl>
  <hr>

  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong> "Open" Constructor
  <dt><strong>Signature:</strong></dt>
	<dd>VL_PacketTable(hid_t fileID, char* name)</dd>
  <dt><strong>Purpose:</strong></dt>
	<dd>Opens a variable-length packet table.</dd>
  <dt><strong>Description:</strong></dt>
	<dd>This constructor opens an existing packet table named
	    <code>name</code> in the location <code>fileID</code>.  This packet
	    table must be variable-length.</dd>
  <dt><strong>Parameters:</strong></dt>
	<dl>
	<dt>hid_t fileID</dt>
	<dd>IN: Identifier of the file or group containing the packet table.</dd> 
	<dt>const char * dset_name</dt>
	<dd>IN: The name of the packet table to open.</dd>
	</dl>
  </dl>
  <hr>

  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong> AppendPacket (single packet)
  <dt><strong>Signature:</strong></dt>
	<dd>int AppendPacket(void * data, unsigned int length)</dd>
  <dt><strong>Purpose:</strong></dt>
	<dd>Appends a single variable-length packet to the packet table.</dd>
  <dt><strong>Description:</strong></dt>
	<dd>This function writes a packet to the end of the packet table.  
	    The length of the packet must be specified, since it is not 
	    known beforehand.</dd>
  <dt><strong>Parameters:</strong></dt>
	<dl>
	<dt>void * data:</dt>
	<dd>IN: Buffer holding a single packet to be written.</dd>
	<dt>unsigned int length</dt>
	<dd>IN: Length of the packet being added in bytes.</dd>
	</dl>
<!-- NEW PAGE -->
  <dt><strong>Returns:</strong></dt>
	<dd>Returns non-negative value on success, negative on error.</dd>
  </dl>
  <hr>

  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong> AppendPackets(multiple packets)
  <dt><strong>Signature:</strong></dt>
	<dd>int AppendPackets(unsigned int numPackets, hvl_t *data)</dd>
  <dt><strong>Purpose:</strong></dt>
	<dd>Appends multiple variable-length packets to the packet table.</dd>
  <dt><strong>Description:</strong></dt>
	<dd>This function writes packets to the end of the packet table.  
	    The packets must be packaged as an array of hvl_t structs, which contain 
	    a pointer to the packet and its length.</dd>
  <dt><strong>Parameters:</strong></dt>
	<dl>
	<dt>unsigned int numPackets</dt>
	<dd>IN: Number of packets to append.</dd>
	<dt>hvl_t* data:</dt>
	<dd>IN: An array of hvl_t structs containing pointers to the packets to be written.</dd>
	</dl>
  <dt><strong>Returns:</strong></dt>
	<dd>Returns non-negative value on success, negative on error.</dd>
  </dl>
  <hr>

  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong> GetPacket
  <dt><strong>Signatures:</strong></dt>
	<dd>int GetPacket(unsigned int index, hvl_t * data)</dd>
	<dd>int GetPackets(unsigned int startIndex, unsigned int endIndex, hvl_t * data)</dd>
  <dt><strong>Purpose:</strong></dt>
	<dd>Reads variable-length packets from the packet table.</dd>
  <dt><strong>Description:</strong></dt>
	<dd>This function fills a buffer of hvl_t structs with variable-length
	    packets from the packet table.  A function can be called with one
	    argument to retrieve a single packet at the given index, or the
	    two-argument function can be used to read a range of packets
	    (zero-indexed, inclusive).</dd>
  <dt><strong>Parameters:</strong></dt>
	<dl>
	<dt>unsigned int index (single packet)</dt>
	<dd>IN: Index of the single packet to be read</dd>
	<dt>unsigned int startIndex (multiple packets)</dt>
	<dd>IN: Index at which to start reading packets</dd>
	<dt>unsigned int endIndex (multiple packets)</dt>
	<dd>IN: Index at which to stop reading packets</dd>
	<dt>hvl_t * data</dt>
	<dd>OUT: Buffer of hvl_t structs for packets being retrieved</dd>
	</dl>
  <dt><strong>Returns:</strong></dt>
	<dd>Returns non-negative on success, negative on error.</dd>
  </dl>
  <hr>

  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong> GetNextPacket
  <dt><strong>Signatures:</strong></dt>
	<dd>int GetNextPacket(hvl_t * data)</dd>
	<dd>int GetNextPacket(unsigned int numPackets, hvl_t * data)</dd>
  <dt><strong>Purpose:</strong></dt>
	<dd>Iterates through packets from the packet table.</dd>
<!-- NEW PAGE -->
  <dt><strong>Description:</strong></dt>
	<dd>This function reads packets starting from the current index in the 
	    packet table and updates the index.  It can be used with the 
	    ResetIndex and SetIndex functions to iterate through the packet
	    table.  Different versions of this function can be called with or
	    without the numPackets argument; if this argument is not supplied,
	    it defaults to one.</dd>
  <dt><strong>Parameters:</strong></dt>
	<dl>
	<dt>unsigned int numPackets (optional)</dt>
	<dd>IN:  How many packets to read.  Defaults to one.</dd>
	<dt>hvl_t * data</dt>
	<dd>OUT: Buffer of hvl_t structs to hold packets being read.</dd>
	</dl>
  <dt><strong>Returns:</strong></dt>
	<dd>Returns non-negative on success, negative on error.</dd>
  </dl>
  <hr>

  <dl>
  <dt style="background-color: #CCCCFF"><strong>Name:</strong> FreeReadbuff
  <dt><strong>Signature:</strong></dt>
	<dd>int FreeReadbuff(unsigned int numStructs, hvl_t * buffer)</dd>
  <dt><strong>Purpose:</strong></dt>
	<dd>Frees buffers used to hold variable-length packets</dd>
  <dt><strong>Description:</strong></dt>
	<dd>When variable-length packets are read, memory must be allocated 
	    to hold them; hvl_t structs hold pointers to this memory.  This memory 
	    should be freed by passing the array of hvl_t structs used in reading 
	    to this function, along with the size of the array.</dd>
  <dt><strong>Parameters:</strong></dt>
	<dl>
	<dt>unsigned int numStructs</dt>
	<dd>IN:  Number of hvl_t structs in the array.</dd>
	<dt>hvl_t * buffer</dt>
	<dd>IN:  Buffer used to read packets whose memory should now be freed.</dd>
	</dl>
  <dt><strong>Returns:</strong></dt>
	<dd>Returns non-negative on success, negative on error.</dd>
  </dl>

<!-- #BeginLibraryItem "/ed_libs/NavBar_RMHL.lbi" --><hr>
<center>
<table border=0 width=98%>
<tr><td valign=top align=left>
<a href="../index.html">HDF5 documents and links</a>&nbsp;<br>
<a href="../H5.intro.html">Introduction to HDF5</a>&nbsp;<br>
<a href="http://hdf.ncsa.uiuc.edu/HDF5/doc/UG/index.html">HDF5 User Guide</a>&nbsp;<br>
<a href="index.html">Other High-level API documents</a>
<!--
<a href="Glossary.html">Glossary</a><br>
-->
</td>
<td valign=top align=right>
And in this document, the 
<a href="../RM/RM_H5Front.html">HDF5 Reference Manual</a>&nbsp;&nbsp;
<br>
<a href="RM_H5DS.html">H5DS</a>&nbsp;&nbsp;
<a href="RM_H5IM.html">H5IM</a>&nbsp;&nbsp;
<a href="RM_H5LT.html">H5LT</a>&nbsp;&nbsp;
<a href="RM_H5PT.html">H5PT</a>&nbsp;&nbsp;
<a href="RM_H5TB.html">H5TB</a>&nbsp;&nbsp;
<br>
<a href="../RM/RM_H5.html">H5</a>&nbsp;&nbsp;
<a href="../RM/RM_H5A.html">H5A</a>&nbsp;&nbsp;
<a href="../RM/RM_H5D.html">H5D</a>&nbsp;&nbsp;
<a href="../RM/RM_H5E.html">H5E</a>&nbsp;&nbsp;
<a href="../RM/RM_H5F.html">H5F</a>&nbsp;&nbsp;
<a href="../RM/RM_H5G.html">H5G</a>&nbsp;&nbsp;
<a href="../RM/RM_H5I.html">H5I</a>&nbsp;&nbsp;
<a href="../RM/RM_H5P.html">H5P</a>&nbsp;&nbsp;
<br>
<a href="../RM/RM_H5R.html">H5R</a>&nbsp;&nbsp;
<a href="../RM/RM_H5S.html">H5S</a>&nbsp;&nbsp;
<a href="../RM/RM_H5T.html">H5T</a>&nbsp;&nbsp;
<a href="../RM/RM_H5Z.html">H5Z</a>&nbsp;&nbsp;
<a href="../RM/Tools.html">Tools</a>&nbsp;&nbsp;
<a href="../RM/PredefDTypes.html">Datatypes</a>&nbsp;&nbsp;
</td></tr>
</table>
</center>
<hr>
<!-- #EndLibraryItem --><SCRIPT LANGUAGE="JAVASCRIPT">
<!--
document.writeln(' \
<address> \
</address> \
<table width=100% border=0> \
<tr><td align=left valign=top> \
<a href="mailto:hdfhelp@ncsa.uiuc.edu">HDF Help Desk</a> \
<br> \
Last modified: 21 November 2005 \
</td></tr> \
</table> \
');
-->
</SCRIPT>
  
</body>
  </html>
