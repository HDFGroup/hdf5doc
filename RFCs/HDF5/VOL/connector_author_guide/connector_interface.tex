\section{VOL Connector Interface Reference}
\label{sec:vol}
Each VOL connector should be of type \texttt{H5VL\_class\_t}, Listing \ref{lst:VOLclass}.

\hfill

\begin{lstlisting}[caption={VOL connector class, H5VLpublic.h},captionpos=b, label={lst:VOLclass}]
/* Class information for each VOL driver */
typedef struct H5VL_class_t {
    /* Overall connector fields & callbacks */
    unsigned           version;          /**< VOL connector class struct version #     */
    H5VL_class_value_t value;            /**< Value to identify connector              */
    const char *       name;             /**< Connector name (MUST be unique!)         */
    unsigned           conn_version;     /**< Version # of connector                   */
    unsigned           cap_flags;        /**< Capability flags for connector           */
    herr_t (*initialize)(hid_t vipl_id); /**< Connector initialization callback        */
    herr_t (*terminate)(void);           /**< Connector termination callback           */

    /* VOL framework */
    H5VL_info_class_t info_cls; /**< VOL info fields & callbacks  */
    H5VL_wrap_class_t wrap_cls; /**< VOL object wrap / retrieval callbacks */

    /* Data Model */
    H5VL_attr_class_t     attr_cls;     /**< Attribute (H5A*) class callbacks */
    H5VL_dataset_class_t  dataset_cls;  /**< Dataset (H5D*) class callbacks   */
    H5VL_datatype_class_t datatype_cls; /**< Datatype (H5T*) class callbacks  */
    H5VL_file_class_t     file_cls;     /**< File (H5F*) class callbacks      */
    H5VL_group_class_t    group_cls;    /**< Group (H5G*) class callbacks     */
    H5VL_link_class_t     link_cls;     /**< Link (H5L*) class callbacks      */
    H5VL_object_class_t   object_cls;   /**< Object (H5O*) class callbacks    */

    /* Infrastructure / Services */
    H5VL_introspect_class_t introspect_cls; /**< Container/connector introspection class callbacks */
    H5VL_request_class_t    request_cls;    /**< Asynchronous request class callbacks */
    H5VL_blob_class_t       blob_cls;       /**< 'Blob' class callbacks */
    H5VL_token_class_t      token_cls;      /**< VOL connector object token class callbacks */

    /* Catch-all */
    herr_t (*optional)(void *obj, H5VL_optional_args_t *args, hid_t dxpl_id,
                       void **req); /**< Optional callback */
} H5VL_class_t;

\end{lstlisting}

The \texttt{version} field is the version of the \texttt{H5VL\_class\_t} struct. This is identical to how the \texttt{version} field is used in the \texttt{H5Z\_class2\_t} struct for filters. 

The \texttt{value} field is a unique integer identifier that should be between 512 and 65535 for external, non-library connectors..

The \texttt{name} field is a string that uniquely identifies the VOL connector name.

The \texttt{conn\_version} is the connector version. This is currently not used by the library.

The \texttt{cap\_flags} holds bitwise capability/feature flags that determine which operations and capabilities are supported by a the VOL connector. These fields were enumerated in the previous section.

The \texttt{initialize} field is a function pointer to a routine that a connector implements to set up or initialize access to the connector. Implementing this function by the connector is not required since some connectors do not require any set up to start accessing the connector. In that case, the value of the function pointer should be set to NULL. Connector specific variables that are required to be passed from users should be passed through the VOL initialize property list. Generic properties can be added to this property class for user-defined connectors that cannot modify the HDF5 library to add internal properties. For more information consult the property list reference manual pages.

The \texttt{terminate} field is a function pointer to a routine that a connector implements to terminate or finalize access to the connector. Implementing this function by the connector is not required since some connectors do not require any termination phase to the connector. In that case, the value of the function pointer should be set to NULL.

The rest of the fields in the \texttt{H5VL\_class\_t} struct are "subclasses'' that define all the VOL function callbacks that
are mapped to from the HDF5 API layer. Those subclasses are categorized into three categories, VOL Framework, Data Model, and Infrastructure / Services.

VOL Framework classes provide functionality for working with the VOL connectors themselves (e.g., working with connector strings) and with wrapping and unwrapping objects for passthrough connectors.

Data Model classes are those that provide functionality for accessing an HDF5 container and objects in that container as defined by the HDF5 data model.

Infrastructure / Service classes are those that provide services for users that are not related to the data model specifically. Asynchronous operations, for example, are a service that most connectors can implement, so we add a class for it in the VOL structure.

If a service becomes generic enough and common among many connectors, a class for it should be added to the VOL structure. However, many connectors can/will provide services that are not shared by other connectors. A good way to support these services is through an optional callback in the VOL structure which can be a hook from the API to the connector that provides those services, passing any necessary arguments needed without the HDF5 library having to worry about supporting that service. A similar API operation to allow users to use that service will be added. This API call would be similar to an “ioctl” call where any kind of operation can be supported and passed down to the connector that has enough knowledge from the user to interpret the type of the operation. All classes and their defined callbacks will be detailed in the following sub-sections.

To handle that large set of API routines, each class in the Data Model category has three generic callbacks, \texttt{get}, \texttt{specific}, and \texttt{optional} to handle the three set of API operations outline above respectively. To handle the varying parameters that can be passed to the callback, each callback will take a struct parameter that includes an enum {\tt get/specific} or integer {\tt optional} field indicating the operation and a union of the possible parameters {\tt get/specific} or void pointer to the parameters {\tt optional}.

The optional args struct used for all optional operations:
\begin{lstlisting}
/* Struct for all 'optional' callbacks */
typedef struct H5VL_optional_args_t {
    int   op_type; /* Operation to perform */
    void *args;    /* Pointer to operation's argument struct */
} H5VL_optional_args_t;
\end{lstlisting}

The {\tt opt\_type} member is the value assigned by the library when the optional operation was registered (or {\tt \#define}d in the case of the native VOL connector) and the {\tt args} member is a pointer to the optional operation's parameters (usually passed in as a struct).


Note that this differs from the HDF5 1.12.x scheme, which used {\tt va\_list}s.

The \texttt{optional} callback is a free for all callback where anything from the API layer is passed in directly. This callback is used to support connector specific operations in the API that other connectors should or would not know about. More information about types and the arguments for each type will be detailed in the corresponding class arguments.

\subsection{Mapping the API to the Callbacks}
\label{sec:map}

The callback interface defined for the VOL has to be general enough to
handle all the HDF5 API operations that would access the
file. Furthermore, it has to capture future additions to the HDF5
library with little to no changes to the callback interface. Changing
the interface often whenever new features are added would be
discouraging to connector developers since that would mean reworking
their VOL connector structure. To remedy this issue, every callback will
contain two parameters:
\begin{itemize}
\item A data transfer property list (DXPL) which allows that API to
  put some properties on for the connectors to retrieve if they have to
  for particular operations, without having to add arguments to the
  VOL callback function.
\item A pointer to a request (\texttt{void **req}) to handle asynchronous
  operations if the HDF5 library adds support for them in future
  releases. That pointer is set by the VOL
  connector to a request object it creates to manage progress on that
  asynchronous operation. If the \texttt{req} is \texttt{NULL}, that means
  that the API operation is blocking and so the connector would not
  execute the operation asynchronously. If the connector does not support
  asynchronous operations, it needs not to worry about this field and
  leaves it unset.
\end{itemize}

In order to keep the number of the VOL object classes and callbacks
concise and readable, it was decided not to have a one-to-one mapping
between API operation and callbacks. The parameter names and types will be
detailed when describing each callback in their respective sections.

The HDF5 library provides several routines to access an object in the
container. For example, to open an attribute on a group object, the
user could use \texttt{H5Aopen()} and pass the group identifier directly
where the attribute needs to be opened. Alternatively, the user could
use \texttt{H5Aopen\_by\_name()} or \texttt{H5Aopen\_by\_idx()} to open the
attribute, which provides a more flexible way of locating the
attribute, whether by a starting object location and a path or an
index type and traversal order. All those types of accesses usually
map to one VOL callback with a parameter that indicates the access
type. In the example of opening an attribute, the three API open
routine will map to the same VOL open callback but with a different
location parameter. The same applies to all types of routines that
have multiple types of accesses.  The location parameter is a
structure defined in Listing \ref{lst:ObjLocclass}.

\begin{lstlisting}[caption={Structure to hold parameters for object locations, H5VLconnector.h}, captionpos=b, label={lst:ObjLocclass}]
/* 
 * Structure to hold parameters for object locations.
 * either: BY_SELF, BY_NAME, BY_IDX, BY_TOKEN
 */

typedef struct H5VL_loc_params_t {
    H5I_type_t obj_type; /* The object type of the location object */
    H5VL_loc_type_t type; /* The location type */
    union { /* parameters of the location */
        H5VL_loc_by_token_t     loc_by_token;                                    
        H5VL_loc_by_name_t      loc_by_name;                                     
        H5VL_loc_by_idx_t       loc_by_idx;  
    }loc_data;
} H5VL_loc_params_t

/* 
 * Types for different ways that objects are located in an 
 * HDF5 container.
 */
typedef enum H5VL_loc_type_t {
    /* starting location is the target object */
    H5VL_OBJECT_BY_SELF, 

    /* location defined by object and path in H5VL_loc_by_name_t */
    H5VL_OBJECT_BY_NAME, 

    /* location defined by object, path, and index in H5VL_loc_by_idx_t */
    H5VL_OBJECT_BY_IDX,

    /* location defined by token (e.g. physical address) in H5VL_loc_by_token_t */
    H5VL_OBJECT_BY_TOKEN,
} H5VL_loc_type_t;

typedef struct H5VL_loc_by_name {
    const char *name; /* The path relative to the starting location */
    hid_t lapl_id; /* The link access property list */
}H5VL_loc_by_name_t;

typedef struct H5VL_loc_by_idx {
    const char *name; /* The path relative to the starting location */
    H5_index_t idx_type; /* Type of index */
    H5_iter_order_t order; /* Index traversal order */
    hsize_t n; /* Position in index */
    hid_t lapl_id; /* The link access property list */
}H5VL_loc_by_idx_t;

typedef struct H5VL_loc_by_token {
    void *token; /* arbitrary token (physical address of location in native VOL) */
}H5VL_loc_by_token_t;
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONNECTOR INFORMATION CALLBACKS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Connector Information Callbacks}

This section's callbacks involve the connector-specific information that will be associated with the VOL in the fapl via \texttt{H5Pset\_fapl()} et al. This data is copied into the fapl so the library needs these functions to manage this in a way that prevents resource leaks.

The \texttt{to\_str} and \texttt{from\_str} callbacks are used to convert the connector-specific data to and from a configuration string. There is no official way to construct VOL configuration strings, so the format used (JSON, XML, getopt-style processing, etc.) is up to the connector author. These connector configuration strings can be used to set up a VOL connector via mechanisms like command-line parameters and environment variables.

\begin{lstlisting}[caption={Info class for connector information routines, H5VLconnector.h}, captionpos=b, label={lst:Infoclass}]
typedef struct H5VL_info_class_t {                                               
    size_t size;
    void * (*copy)(const void *info);
    herr_t (*cmp)(int *cmp_value, const void *info1, const void *info2);
    herr_t (*free)(void *info);
    herr_t (*to_str)(const void *info, char **str);
    herr_t (*from_str)(const char *str, void **info);
} H5VL_info_class_t;
\end{lstlisting}

\subsubsection{info: size}
The \texttt{size} field indicates the size required to store any special information that the connector needs.

If the connector requires no special information, set this field to zero.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    size_t size;
\end{lstlisting}
\end{mdframed}

\subsubsection{info: copy}
The \texttt{copy} callback is invoked when the connector is selected for use with \texttt{H5Pset\_fapl()}, the connector-specific set call, etc. Where possible, the information should be deep copied in such a way that the original data can be freed.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    void * (*copy)(const void *info);
\end{lstlisting}
\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{info} & (IN): The connector-specific info to copy.\\
\end{tabular}
\end{mdframed}

\subsubsection{info: cmp}
The \texttt{cmp} callback is uesd to determine if two connector-specific data structs are identical and helps the library manage connector resources.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*cmp)(int *cmp_value, const void *info1, const void *info2);
\end{lstlisting}
\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{cmp\_value} & (OUT): A strcmp-like compare value.\\
  \texttt{info1} & (IN): The 1st connector-specific info to copy.\\
  \texttt{info2} & (IN): The 2nd connector-specific info to copy.\\
\end{tabular}
\end{mdframed}

\subsubsection{info: free}
The \texttt{free} callback is used to clean up the connector-specific information that was copied when set in the fapl via the \texttt{copy} callback.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*free)(void *info);
\end{lstlisting}
\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{info} & (IN): The connector-specific info to free.\\
\end{tabular}
\end{mdframed}

\subsubsection{info: to\_str}
The \texttt{to\_str} callback converts a connector-specific information structure to a connector-specific configuration string. It is the opposite of the \texttt{from\_str} callback.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*to_str)(const void *info, char **str);
\end{lstlisting}
\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{info} & (IN): The connector-specific info to convert to a configuration string.\\
  \texttt{str} & (OUT): The constructed configuration string.\\
\end{tabular}
\end{mdframed}

\subsubsection{info: from\_str}
The \texttt{to\_str} callback converts a connector-specific configuration string to a connector-specific information structure. It is the opposite of the \texttt{to\_str} callback.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*from_str)(const char *str, void **info);
\end{lstlisting}
\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{str} & (IN): The connector-specific configuration string.\\
  \texttt{info} & (OUT): The connector-specific info generated from the configuration string.\\
\end{tabular}
\end{mdframed}


%%%%%%%%%%%%%%%%%%%%%%%%%
% OBJECT WRAP CALLBACKS %
%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Object Wrap Callbacks}
The object wrap callbacks are used by passthrough connectors to wrap/unwrap
objects and contexts when passing them up and down the VOL chain.

\begin{lstlisting}[caption={Wrap class for object wrapping routines, H5VLconnector.h}, captionpos=b, label={lst:Wrapclass}]
typedef struct H5VL_wrap_class_t {                                               
    void * (*get_object)(const void *obj);
    herr_t (*get_wrap_ctx)(const void *obj, void **wrap_ctx);
    void * (*wrap_object)(void *obj, H5I_type_t obj_type, void *wrap_ctx);
    void * (*unwrap_object)(void *obj);
    herr_t (*free_wrap_ctx)(void *wrap_ctx);
} H5VL_wrap_class_t; 
\end{lstlisting}

\subsubsection{wrap: get\_object}
Retrieves an underlying object.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    void * (*get_object)(const void *obj);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): Object being unwrapped.\\
\end{tabular}
\end{mdframed}


\subsubsection{wrap: get\_wrap\_ctx}
Get a VOL connector's object wrapping context.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*get_wrap_ctx)(const void *obj, void **wrap_ctx);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): Object for which we need a context.\\
  \texttt{wrap\_ctx} & (OUT): Context.\\
\end{tabular}
\end{mdframed}

\subsubsection{wrap: wrap\_object}
Asks a connector to wrap an underlying object.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    void * (*wrap_object)(void *obj, H5I_type_t obj_type, void *wrap_ctx);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): Object being wrapped.\\
  \texttt{obj\_type} & (IN): Object type (see \texttt{H5Ipublic.h}).\\
  \texttt{wrap\_ctx} & (IN): Context.\\
\end{tabular}
\end{mdframed}

\subsubsection{wrap: unwrap\_object}
Unwrap an object from connector.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    void * (*unwrap_object)(void *obj);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): Object being unwrapped.\\
\end{tabular}
\end{mdframed}

\subsubsection{wrap: free\_wrap\_ctx}
Release a VOL connector's object wrapping context.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*free_wrap_ctx)(void *wrap_ctx);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{wrap\_ctx} & (IN): Context to be freed.\\
\end{tabular}
\end{mdframed}


%%%%%%%%%%%%%%%%%%%%%%%
% ATTRIBUTE CALLBACKS %
%%%%%%%%%%%%%%%%%%%%%%%

\subsection{The Attribute Function Callbacks}
The attribute API routines (H5A) allow HDF5 users to create and manage
HDF5 attributes. All the H5A API routines that modify the HDF5
container map to one of the attribute callback routines in this
class that the connector needs to implement.

\begin{lstlisting}[caption={Structure for attribute callback routines, H5VLconnector.h}, captionpos=b, label={lst:ATTRclass}]
typedef struct H5VL_attr_class_t {                                               
    void *(*create)(void *obj, const H5VL_loc_params_t *loc_params, const char *attr_name, hid_t type_id, hid_t space_id, hid_t acpl_id, hid_t aapl_id, hid_t dxpl_id, void **req);
    void *(*open)(void *obj, const H5VL_loc_params_t *loc_params, const char *attr_name, hid_t aapl_id, hid_t dxpl_id, void **req);
    herr_t (*read)(void *attr, hid_t mem_type_id, void *buf, hid_t dxpl_id, void **req);
    herr_t (*write)(void *attr, hid_t mem_type_id, const void *buf, hid_t dxpl_id, void **req);
    herr_t (*get)(void *obj, H5VL_attr_get_args_t *args, hid_t dxpl_id, void **req);
    herr_t (*specific)(void *obj, const H5VL_loc_params_t *loc_params, H5VL_attr_specific_args_t *args, hid_t dxpl_id, void **req);            
    herr_t (*optional)(void *obj, H5VL_optional_args_t *args, hid_t dxpl_id, void **req); 
    herr_t (*close) (void *attr, hid_t dxpl_id, void **req);                     
} H5VL_attr_class_t; 
\end{lstlisting}

\subsubsection{attr: create}
The \texttt{create} callback in the attribute class creates an
attribute object in the container of the location object and
returns a pointer to the attribute structure containing information to
access the attribute in future calls. \bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    void *(*create)(void *obj, H5VL_loc_params_t *loc_params, 
        const char *attr_name, hid_t type_id, hid_t space_id,
        hid_t acpl_id, hid_t aapl_id, 
        hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): Pointer to an object where the attribute needs
  to be created or where the look-up of the target object needs to
  start.\\
  \texttt{loc\_params} & (IN): Pointer to the location parameters as explained in
  Section~\ref{sec:map}.\\
  \texttt{attr\_name} & (IN): The name of the attribute to be created.\\
  \texttt{type\_id} & (IN): The datatype of the attribute.\\
  \texttt{space\_id} & (IN): The dataspace of the attribute.\\
  \texttt{acpl\_id} & (IN): The attribute creation property list.\\
  \texttt{aapl\_id} & (IN): The attribute access property list.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\subsubsection{attr: open}
The \texttt{open} callback in the attribute class opens an
attribute object in the container of the location object and returns a
pointer to the attribute structure containing information to access
the attribute in future calls. \bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    void *(*open)(void *obj, H5VL_loc_params_t *loc_params, 
        const char *attr_name, hid_t aapl_id, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): Pointer to an object where the attribute needs to be
  opened or where the look-up of the target object needs to start.\\
  \texttt{loc\_params} & (IN): Pointer to the location parameters as explained in
  Section~\ref{sec:map}.\\
  \texttt{attr\_name} & (IN): The name of the attribute to be opened.\\
  \texttt{aapl\_id} & (IN): The attribute access property list.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\subsubsection{attr: read}
The \texttt{read} callback in the attribute class reads data from
the attribute object and returns an \texttt{herr\_t} indicating success or
failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*read)(void *attr, hid_t mem_type_id, void *buf, 
        hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{attr} & (IN): Pointer to the attribute object.\\
  \texttt{mem\_type\_id} & (IN): The memory datatype of the attribute.\\
  \texttt{buf} & (OUT): Data buffer to be read into.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\subsubsection{attr: write}
The \texttt{write} callback in the attribute class writes data to
the attribute object and returns an \texttt{herr\_t} indicating success or
failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*write)(void *attr, hid_t mem_type_id, const void *buf, 
        hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{attr} & (IN): Pointer to the attribute object.\\
  \texttt{mem\_type\_id} & (IN): The memory datatype of the attribute.\\
  \texttt{buf} & (IN): Data buffer to be written.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\subsubsection{attr: get}
The \texttt{get} callback in the attribute class retrieves
information about the attribute as specified in the \texttt{get\_type}
parameter.It returns an \texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*get)(void *obj, H5VL_attr_get_args_t *args, hid_t dxpl_id, 
        void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): An attribute or location object where information
  needs to be retrieved from.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\begin{lstlisting}
/* Values for attribute 'get' operations */
typedef enum H5VL_attr_get_t {
    H5VL_ATTR_GET_ACPL,         /* creation property list              */
    H5VL_ATTR_GET_INFO,         /* info                                */
    H5VL_ATTR_GET_NAME,         /* access property list                */
    H5VL_ATTR_GET_SPACE,        /* dataspace                           */
    H5VL_ATTR_GET_STORAGE_SIZE, /* storage size                        */
    H5VL_ATTR_GET_TYPE          /* datatype                            */
} H5VL_attr_get_t;

/* Parameters for attribute 'get_name' operation */
typedef struct H5VL_attr_get_name_args_t {
    H5VL_loc_params_t loc_params;    /* Location parameters for object access */
    size_t            buf_size;      /* Size of attribute name buffer */
    char *            buf;           /* Buffer for attribute name (OUT) */
    size_t *          attr_name_len; /* Actual length of attribute name (OUT) */
} H5VL_attr_get_name_args_t;

/* Parameters for attribute 'get_info' operation */
typedef struct H5VL_attr_get_info_args_t {
    H5VL_loc_params_t loc_params; /* Location parameters for object access */
    const char *      attr_name;  /* Attribute name (for get_info_by_name) */
    H5A_info_t *      ainfo;      /* Attribute info (OUT) */
} H5VL_attr_get_info_args_t;

/* Parameters for attribute 'get' operations */
typedef struct H5VL_attr_get_args_t {
    H5VL_attr_get_t op_type; /* Operation to perform */

    /* Parameters for each operation */
    union {
        /* H5VL_ATTR_GET_ACPL */
        struct {
            hid_t acpl_id; /* Attribute creation property list ID (OUT) */
        } get_acpl;

        /* H5VL_ATTR_GET_INFO */
        H5VL_attr_get_info_args_t get_info; /* Attribute info */

        /* H5VL_ATTR_GET_NAME */
        H5VL_attr_get_name_args_t get_name; /* Attribute name */

        /* H5VL_ATTR_GET_SPACE */
        struct {
            hid_t space_id; /* Dataspace ID (OUT) */
        } get_space;

        /* H5VL_ATTR_GET_STORAGE_SIZE */
        struct {
            hsize_t *data_size; /* Size of attribute in file (OUT) */
        } get_storage_size;

        /* H5VL_ATTR_GET_TYPE */
        struct {
            hid_t type_id; /* Datatype ID (OUT) */
        } get_type;
    } args;
} H5VL_attr_get_args_t;
\end{lstlisting}

\subsubsection{attr: specific}
The \texttt{specific} callback in the attribute class implements specific operations on HDF5 attributes as specified in the \texttt{specific\_type} parameter. It returns an \texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
	herr_t (*specific)(void *obj, H5VL_loc_params_t *loc_params, H5VL_attr_specific_args_t *args, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The location object  where the operation needs to happen.\\
  \texttt{loc\_params} & (IN): A pointer to the location parameters as explained in Section~\ref{sec:map}.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\begin{lstlisting}
/* Values for attribute 'specific' operation */
typedef enum H5VL_attr_specific_t {
    H5VL_ATTR_DELETE,        /* H5Adelete(_by_name)  */
    H5VL_ATTR_DELETE_BY_IDX, /* H5Adelete_by_idx     */
    H5VL_ATTR_EXISTS,        /* H5Aexists(_by_name)  */
    H5VL_ATTR_ITER,          /* H5Aiterate(_by_name) */
    H5VL_ATTR_RENAME         /* H5Arename(_by_name)  */
} H5VL_attr_specific_t;

/* Parameters for attribute 'iterate' operation */
typedef struct H5VL_attr_iterate_args_t {
    H5_index_t      idx_type; /* Type of index to iterate over */
    H5_iter_order_t order;    /* Order of index iteration */
    hsize_t *       idx;      /* Start/stop iteration index (IN/OUT) */
    H5A_operator2_t op;       /* Iteration callback function */
    void *          op_data;  /* Iteration callback context */
} H5VL_attr_iterate_args_t;

/* Parameters for attribute 'delete_by_idx' operation */
typedef struct H5VL_attr_delete_by_idx_args_t {
    H5_index_t      idx_type; /* Type of index to iterate over */
    H5_iter_order_t order;    /* Order of index iteration */
    hsize_t         n;        /* Iteration index */
} H5VL_attr_delete_by_idx_args_t;

/* Parameters for attribute 'specific' operations */
typedef struct H5VL_attr_specific_args_t {
    H5VL_attr_specific_t op_type; /* Operation to perform */

    /* Parameters for each operation */
    union {
        /* H5VL_ATTR_DELETE */
        struct {
            const char *name; /* Name of attribute to delete */
        } del;

        /* H5VL_ATTR_DELETE_BY_IDX */
        H5VL_attr_delete_by_idx_args_t delete_by_idx;

        /* H5VL_ATTR_EXISTS */
        struct {
            const char *name;   /* Name of attribute to check */
            hbool_t *   exists; /* Whether attribute exists (OUT) */
        } exists;

        /* H5VL_ATTR_ITER */
        H5VL_attr_iterate_args_t iterate;

        /* H5VL_ATTR_RENAME */
        struct {
            const char *old_name; /* Name of attribute to rename */
            const char *new_name; /* New attribute name */
        } rename;
    } args;
} H5VL_attr_specific_args_t;
\end{lstlisting}

\subsubsection{attr: optional}
The \texttt{optional} callback in the attribute class implements connector specific operations on an HDF5 attribute. It returns an \texttt{herr\_t} indicating success or failure. \bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*optional)(void *obj, H5VL_optional_args_t *args, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The container or object where the operation needs to happen.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the operation created by the connector.\\
\end{tabular}
\end{mdframed}

Each connector that requires connector-specific operations should compare the
value of the {\tt op\_type} field of the {\tt H5VL\_optional\_args\_t} struct
with the values returned from calling {\tt H5VLregister\_opt\_operation} to
determine how to handle the optional call and interpret the arguments passed
in the struct.

\subsubsection{attr: close}
The \texttt{close} callback in the attribute class terminates
access to the attribute object and free all resources it was
consuming, and returns an \texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*close)(void *attr, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{attr} & (IN): Pointer to the attribute object.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

%%%%%%%%%%%%%%%%%%%%%
% DATASET CALLBACKS %
%%%%%%%%%%%%%%%%%%%%%

\subsection{Dataset Callbacks}
The dataset API routines (H5D) allow HDF5 users to create and manage
HDF5 datasets. All the H5D API routines that modify the HDF5 container
map to one of the dataset callback routines in this class that the
connector needs to implement.

\begin{lstlisting}[caption={Structure for dataset callback routines, H5VLconnector.h}, captionpos=b, label={lst:DSclass}]
typedef struct H5VL_dataset_class_t {                                            
    void *(*create)(void *obj, const H5VL_loc_params_t *loc_params, const char *name, hid_t lcpl_id, hid_t type_id, hid_t space_id, hid_t dcpl_id, hid_t dapl_id, hid_t dxpl_id, void **req);
    void *(*open)(void *obj, const H5VL_loc_params_t *loc_params, const char *name, hid_t dapl_id, hid_t dxpl_id, void **req);
    herr_t (*read)(void *dset, hid_t mem_type_id, hid_t mem_space_id, hid_t file_space_id, hid_t dxpl_id, void * buf, void **req);
    herr_t (*write)(void *dset, hid_t mem_type_id, hid_t mem_space_id, hid_t file_space_id, hid_t dxpl_id, const void * buf, void **req);
    herr_t (*get)(void *obj, H5VL_dataset_get_args_t *args, hid_t dxpl_id, void **req);
    herr_t (*specific)(void *obj, H5VL_dataset_specific_args_t *args, hid_t dxpl_id, void **req);
    herr_t (*optional)(void *obj, H5VL_optional_args_t *args, hid_t dxpl_id, void **req);
    herr_t (*close) (void *dset, hid_t dxpl_id, void **req);
} H5VL_dataset_class_t; 
\end{lstlisting}

\subsubsection{dataset: create}
The \texttt{create} callback in the dataset class creates a dataset
object in the container of the location object and returns a pointer
to the dataset structure containing information to access the dataset
in future calls.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    void *(*create)(void *obj, H5VL_loc_params_t *loc_params, const char *name, hid_t lcpl_id, hid_t type_id, hid_t space_id, hid_t dcpl_id, hid_t dapl_id, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): Pointer to an object where the dataset needs
  to be created or where the look-up of the target object needs to
  start.\\
  \texttt{loc\_params} & (IN): Pointer to the location parameters as explained in
  Section~\ref{sec:map}. The type can be only \texttt{H5VL\_OBJECT\_BY\_SELF} in this callback. \\
  \texttt{name} & (IN): The name of the dataset to be created.\\
  \texttt{lcpl\_id} & (IN): The link creation property list.\\
  \texttt{type\_id} & (IN): The datatype of the dataset.\\
  \texttt{space\_id} & (IN): The dataspace of the dataset.\\
  \texttt{dcpl\_id} & (IN): The dataset creation property list.\\
  \texttt{dapl\_id} & (IN): The dataset access property list.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\subsubsection{dataset: open}
The \texttt{open} callback in the dataset class opens a dataset
object in the container of the location object and returns a pointer
to the dataset structure containing information to access the dataset
in future calls.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    void *(*open)(void *obj, H5VL_loc_params_t *loc_params, const char *name, hid_t dapl_id, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): Pointer to an object where the dataset needs to be
  opened or where the look-up of the target object needs to start.\\
  \texttt{loc\_params} & (IN): Pointer to the location parameters as explained in
  Section~\ref{sec:map}. The type can be only \texttt{H5VL\_OBJECT\_BY\_SELF} in this callback. \\
  \texttt{name} & (IN): The name of the dataset to be opened.\\
  \texttt{dapl\_id} & (IN): The dataset access property list.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\subsubsection{dataset: read}
The \texttt{read} callback in the dataset class  reads data from
the dataset object and returns an \texttt{herr\_t} indicating success or
failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*read)(void *dset, hid_t mem_type_id, hid_t mem_space_id, 
        hid_t file_space_id, hid_t dxpl_id, void *buf, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{dset} & (IN): Pointer to the dataset object.\\
  \texttt{mem\_type\_id} & (IN): The memory datatype of the data.\\
  \texttt{mem\_space\_id} & (IN): The memory dataspace selection.\\
  \texttt{file\_space\_id} & (IN): The file dataspace selection.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{buf} & (OUT): Data buffer to be read into.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\subsubsection{dataset: write}
The \texttt{write} callback in the dataset class writes data to
the dataset object and returns an \texttt{herr\_t} indicating success or
failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*write)(void *dset, hid_t mem_type_id, hid_t mem_space_id, 
        hid_t file_space_id, hid_t dxpl_id, const void *buf, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{dset} & (IN): Pointer to the dataset object.\\
  \texttt{mem\_type\_id} & (IN): The memory datatype of the data.\\
  \texttt{mem\_space\_id} & (IN): The memory dataspace selection.\\
  \texttt{file\_space\_id} & (IN): The file dataspace selection.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{buf} & (IN): Data buffer to be written from.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\subsubsection{dataset: get}
The \texttt{get} callback in the dataset class retrieves
information about the dataset as specified in the \texttt{get\_type}
parameter.It returns an \texttt{herr\_t} indicating success or failure.
\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*get)(void *dset, H5VL_dataset_get_args_t *args, 
        hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{dset} & (IN): The dataset object where information needs to be
  retrieved from.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\begin{lstlisting}
/* Values for dataset 'get' operation */
typedef enum H5VL_dataset_get_t {
    H5VL_DATASET_GET_DAPL,         /* access property list                */
    H5VL_DATASET_GET_DCPL,         /* creation property list              */
    H5VL_DATASET_GET_SPACE,        /* dataspace                           */
    H5VL_DATASET_GET_SPACE_STATUS, /* space status                        */
    H5VL_DATASET_GET_STORAGE_SIZE, /* storage size                        */
    H5VL_DATASET_GET_TYPE          /* datatype                            */
} H5VL_dataset_get_t;

/* Parameters for dataset 'get' operations */
typedef struct H5VL_dataset_get_args_t {
    H5VL_dataset_get_t op_type; /* Operation to perform */

    /* Parameters for each operation */
    union {
        /* H5VL_DATASET_GET_DAPL */
        struct {
            hid_t dapl_id; /* Dataset access property list ID (OUT) */
        } get_dapl;

        /* H5VL_DATASET_GET_DCPL */
        struct {
            hid_t dcpl_id; /* Dataset creation property list ID (OUT) */
        } get_dcpl;

        /* H5VL_DATASET_GET_SPACE */
        struct {
            hid_t space_id; /* Dataspace ID (OUT) */
        } get_space;

        /* H5VL_DATASET_GET_SPACE_STATUS */
        struct {
            H5D_space_status_t *status; /* Storage space allocation status (OUT) */
        } get_space_status;

        /* H5VL_DATASET_GET_STORAGE_SIZE */
        struct {
            hsize_t *storage_size; /* Size of dataset's storage (OUT) */
        } get_storage_size;

        /* H5VL_DATASET_GET_TYPE */
        struct {
            hid_t type_id; /* Datatype ID (OUT) */
        } get_type;
    } args;
} H5VL_dataset_get_args_t;
\end{lstlisting}


\subsubsection{dataset: specific}
The \texttt{specific} callback in the dataset class implements specific operations on HDF5 datasets as specified in the \texttt{specific\_type} parameter. It returns an \texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*specific)(void *obj, H5VL_file_specific_args_t *args, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The dset  where the operation needs
  to happen.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\begin{lstlisting}
/* Values for dataset 'specific' operation */
typedef enum H5VL_dataset_specific_t {
    H5VL_DATASET_SET_EXTENT, /* H5Dset_extent                       */
    H5VL_DATASET_FLUSH,      /* H5Dflush                            */
    H5VL_DATASET_REFRESH     /* H5Drefresh                          */
} H5VL_dataset_specific_t;

/* Parameters for dataset 'specific' operations */
typedef struct H5VL_dataset_specific_args_t {
    H5VL_dataset_specific_t op_type; /* Operation to perform */

    /* Parameters for each operation */
    union {
        /* H5VL_DATASET_SET_EXTENT */
        struct {
            const hsize_t *size; /* New dataspace extent */
        } set_extent;

        /* H5VL_DATASET_FLUSH */
        struct {
            hid_t dset_id; /* Dataset ID (IN) */
        } flush;

        /* H5VL_DATASET_REFRESH */
        struct {
            hid_t dset_id; /* Dataset ID (IN) */
        } refresh;
    } args;
} H5VL_dataset_specific_args_t;
\end{lstlisting}

\subsubsection{dataset: optional}
The \texttt{optional} callback in the dataset class implements connector specific operations on an HDF5 dataset. It returns an \texttt{herr\_t} indicating success or failure. \bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*optional)(void *obj, H5VL_optional_args_t *args, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The container or object where the operation needs to happen.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the operation created by the connector.\\
\end{tabular}
\end{mdframed}

Each connector that requires connector-specific operations should compare the
value of the {\tt op\_type} field of the {\tt H5VL\_optional\_args\_t} struct
with the values returned from calling {\tt H5VLregister\_opt\_operation} to
determine how to handle the optional call and interpret the arguments passed
in the struct.

\subsubsection{dataset: close}
The \texttt{close} callback in the dataset class terminates access
to the dataset object and free all resources it was consuming and
returns an \texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*close)(void *dset, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{dset} & (IN): Pointer to the dataset object.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

%%%%%%%%%%%%%%%%%%%%%%
% DATATYPE CALLBACKS %
%%%%%%%%%%%%%%%%%%%%%%

\subsection{Datatype Callbacks}
The HDF5 datatype routines (H5T) allow users to create and manage HDF5
datatypes. Those routines are divided into two categories. One that
operates on all types of datatypes but do not modify the contents of
the container (all in memory), and others that operate on named
datatypes by accessing the container. When a user creates an HDF5
datatype, it is still an object in memory space (transient datatype)
that has not been added to the HDF5 containers. Only when a user
commits the HDF5 datatype, it becomes persistent in the
container. Those are called named/committed datatypes. The transient
H5T routines should work on named datatypes nevertheless. 

All the H5T API routines that modify the HDF5 container map to one of
the named datatype callback routines in this class that the connector needs to
implement.

\begin{lstlisting}[caption={Structure for datatype callback routines, H5VLconnector.h}, captionpos=b, label={lst:H5Tclass}]
typedef struct H5VL_datatype_class_t {                                           
    void *(*commit)(void *obj, const H5VL_loc_params_t *loc_params, const char *name, hid_t type_id, hid_t lcpl_id, hid_t tcpl_id, hid_t tapl_id, hid_t dxpl_id, void **req);
    void *(*open)(void *obj, const H5VL_loc_params_t *loc_params, const char * name, hid_t tapl_id, hid_t dxpl_id, void **req);
    herr_t (*get)   (void *obj, H5VL_datatype_get_args_t *args, hid_t dxpl_id, void **req);
    herr_t (*specific)(void *obj, H5VL_datatype_specific_args_t *args, hid_t dxpl_id, void **req);            
    herr_t (*optional)(void *obj, H5VL_optional_args_t *args, hid_t dxpl_id, void **req); 
    herr_t (*close) (void *dt, hid_t dxpl_id, void **req);                       
} H5VL_datatype_class_t; 
\end{lstlisting}

\subsubsection{datatype: commit}
The \texttt{commit} callback in the named datatype class creates a datatype object in the container of the location object and
returns a pointer to the datatype structure containing information to access the datatype in future calls.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    void *(*commit)(void *obj, H5VL_loc_params_t *loc_params, 
        const char *name, hid_t type_id, hid_t lcpl_id, hid_t tcpl_id, 
        hid_t tapl_id, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): Pointer to an object where the datatype needs
  to be committed or where the look-up of the target object needs to
  start.\\
  \texttt{loc\_params} & (IN): Pointer to location parameters as explained in
  Section~\ref{sec:map}. In this call, the location type is always \texttt{H5VL\_OBJECT\_BY\_SELF}. \\
  \texttt{name} & (IN): The name of the datatype to be created.\\
  \texttt{type\_id} & (IN): The transient datatype identifier to be
  committed. \\
  \texttt{lcpl\_id} & (IN): The link creation property list. \\
  \texttt{tcpl\_id} & (IN): The datatype creation property list.\\
  \texttt{tapl\_id} & (IN): The datatype access property list.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\subsubsection{datatype: open}
The \texttt{open} callback in the named datatype class opens a
previously committed datatype object in the container of the location
object and returns a pointer to the datatype structure containing
information to access the datatype in future calls.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    void *(*open) (void *obj, H5VL_loc_params_t *loc_params, 
        const char * name, hid_t tapl_id, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): Pointer to an object where the datatype needs
  to be opened or where the look-up of the target object needs to
  start.\\
  \texttt{loc\_params} & (IN): Pointer to location parameters as explained in
  Section~\ref{sec:map}. In this call, the location type is always \texttt{H5VL\_OBJECT\_BY\_SELF}. \\
  \texttt{name} & (IN): The name of the datatype to be opened.\\
  \texttt{tapl\_id} & (IN): The datatype access property list.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\subsubsection{datatype: get}
The \texttt{get} callback in the named datatype class retrieves
information about the named datatype as specified in the \texttt{get\_type}
parameter.It returns an \texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*get) (void *obj, H5VL_datatype_get_args_t *args, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The named datatype to retrieve information from.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\begin{lstlisting}
/* Values for datatype 'get' operation */
typedef enum H5VL_datatype_get_t {
    H5VL_DATATYPE_GET_BINARY_SIZE, /* Get size of serialized form of transient type */
    H5VL_DATATYPE_GET_BINARY,      /* Get serialized form of transient type         */
    H5VL_DATATYPE_GET_TCPL         /* Datatype creation property list               */
} H5VL_datatype_get_t;

/* Parameters for datatype 'get' operations */
typedef struct H5VL_datatype_get_args_t {
    H5VL_datatype_get_t op_type; /* Operation to perform */

    /* Parameters for each operation */
    union {
        /* H5VL_DATATYPE_GET_BINARY_SIZE */
        struct {
            size_t *size; /* Size of serialized form of datatype (OUT) */
        } get_binary_size;

        /* H5VL_DATATYPE_GET_BINARY */
        struct {
            void * buf;      /* Buffer to store serialized form of datatype (OUT) */
            size_t buf_size; /* Size of serialized datatype buffer */
        } get_binary;

        /* H5VL_DATATYPE_GET_TCPL */
        struct {
            hid_t tcpl_id; /* Named datatype creation property list ID (OUT) */
        } get_tcpl;
    } args;
} H5VL_datatype_get_args_t;
\end{lstlisting}

\subsubsection{datatype: specific}
The \texttt{specific} callback in the datatype class implements specific operations on HDF5 named datatypes as specified in the \texttt{specific\_type} parameter. It returns an \texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
	herr_t (*specific)(void *obj, H5VL_loc_params_t *loc_params, H5VL_object_specific_args_t *args, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The container or object where the operation needs to happen.\\
  \texttt{loc\_params} & (IN): Pointer to location parameters as explained in Section~\ref{sec:map}.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\begin{lstlisting}
/* Values for datatype 'specific' operation */
typedef enum H5VL_datatype_specific_t {
    H5VL_DATATYPE_FLUSH,  /* H5Tflush */
    H5VL_DATATYPE_REFRESH /* H5Trefresh */
} H5VL_datatype_specific_t;

/* Parameters for datatype 'specific' operations */
typedef struct H5VL_datatype_specific_args_t {
    H5VL_datatype_specific_t op_type; /* Operation to perform */

    /* Parameters for each operation */
    union {
        /* H5VL_DATATYPE_FLUSH */
        struct {
            hid_t type_id; /* Named datatype ID (IN) */
        } flush;

        /* H5VL_DATATYPE_REFRESH */
        struct {
            hid_t type_id; /* Named datatype ID (IN) */
        } refresh;
    } args;
} H5VL_datatype_specific_args_t;
\end{lstlisting}

\subsubsection{datatype: optional}
The \texttt{optional} callback in the datatype class implements connector specific operations on an HDF5 datatype. It returns an \texttt{herr\_t} indicating success or failure.\bigskip 

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*optional)(void *obj, H5VL_optional_args_t *args, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The container or object where the operation needs to happen.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the operation created by the connector.\\
\end{tabular}
\end{mdframed}

Each connector that requires connector-specific operations should compare the
value of the {\tt op\_type} field of the {\tt H5VL\_optional\_args\_t} struct
with the values returned from calling {\tt H5VLregister\_opt\_operation} to
determine how to handle the optional call and interpret the arguments passed
in the struct.

\subsubsection{datatype: close}
The \texttt{close} callback in the named datatype class terminates
access to the datatype object and free all resources it was
consuming and returns an \texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*close) (void *dt, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{dt} & (IN): Pointer to the datatype object.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

%%%%%%%%%%%%%%%%%%
% FILE CALLBACKS %
%%%%%%%%%%%%%%%%%%


\subsection{File Callbacks}
The file API routines (H5F) allow HDF5 users to create and manage HDF5
containers. All the H5F API routines that modify the HDF5 container
map to one of the file callback routines in this class that the connector
needs to implement.

\begin{lstlisting}[caption={File class for file API routines, H5VLconnector.h}, captionpos=b, label={lst:Fileclass}]
typedef struct H5VL_file_class_t {                                               
    void *(*create)(const char *name, unsigned flags, hid_t fcpl_id, hid_t fapl_id, hid_t dxpl_id, void **req);                   
    void *(*open)(const char *name, unsigned flags, hid_t fapl_id, hid_t dxpl_id, void **req);
    herr_t (*get)(void *obj, H5VL_file_get_args_t *args, hid_t dxpl_id, void **req);
    herr_t (*specific)(void *obj, H5VL_file_specific_args_t *args, hid_t dxpl_id, void **req);            
    herr_t (*optional)(void *obj, H5VL_optional_args_t *args, hid_t dxpl_id, void **req);
    herr_t (*close) (void *file, hid_t dxpl_id, void **req);
} H5VL_file_class_t; 
\end{lstlisting}


\subsubsection{file: create}
The \texttt{create} callback in the file class should create a container
and returns a pointer to the file structure created by the connector containing information to
access the container in future calls.\medskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    void *(*create)(const char *name, unsigned flags, hid_t fcpl_id, hid_t fapl_id, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{name} & (IN): The name of the container to be created.\\
  \texttt{flags} & (IN): The creation flags of the container.\\
  \texttt{fcpl\_id} & (IN): The file creation property list.\\
  \texttt{fapl\_id} & (IN): The file access property list.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\hspace*{\fill}

\subsubsection{file: open}
The \texttt{open} callback in the file class should open a container and
returns a pointer to the file structure created by the connector containing information to
access the container in future calls.\bigskip

\begin{mdframed}[style=bgbox] 
\textbf{Signature:}
\begin{lstlisting}
    void *(*open)(const char *name, unsigned flags, hid_t fapl_id, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{name} & (IN): The name of the container to open.\\
  \texttt{flags} & (IN): The open flags of the container.\\
  \texttt{fapl\_id} & (IN): The file access property list.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\subsubsection{file: get}
The \texttt{get} callback in the file class should retrieve
information about the container as specified in the \texttt{get\_type}
parameter. It returns an \texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox] 
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*get)(void *obj, H5VL_file_get_args_t *args, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The container or object where information needs to be
  retrieved from.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\begin{lstlisting}
/* Info for H5VL_FILE_GET_CONT_INFO */
typedef struct H5VL_file_cont_info_t {
    unsigned version;       /* version information (keep first) */
    uint64_t feature_flags; /* Container feature flags          */
                            /* (none currently defined)         */
    size_t token_size;      /* Size of tokens                   */
    size_t blob_id_size;    /* Size of blob IDs                 */
} H5VL_file_cont_info_t;

/* Values for file 'get' operation */
typedef enum H5VL_file_get_t {
    H5VL_FILE_GET_CONT_INFO, /* file get container info              */
    H5VL_FILE_GET_FAPL,      /* file access property list            */
    H5VL_FILE_GET_FCPL,      /* file creation property list          */
    H5VL_FILE_GET_FILENO,    /* file number                          */
    H5VL_FILE_GET_INTENT,    /* file intent                          */
    H5VL_FILE_GET_NAME,      /* file name                            */
    H5VL_FILE_GET_OBJ_COUNT, /* object count in file                 */
    H5VL_FILE_GET_OBJ_IDS    /* object ids in file                   */
} H5VL_file_get_t;

/* Parameters for file 'get_name' operation */
typedef struct H5VL_file_get_name_args_t {
    H5I_type_t type;          /* ID type of object pointer */
    size_t     buf_size;      /* Size of file name buffer (IN) */
    char *     buf;           /* Buffer for file name (OUT) */
    size_t *   file_name_len; /* Actual length of file name (OUT) */
} H5VL_file_get_name_args_t;

/* Parameters for file 'get_obj_ids' operation */
typedef struct H5VL_file_get_obj_ids_args_t {
    unsigned types;    /* Type of objects to count */
    size_t   max_objs; /* Size of array of object IDs */
    hid_t *  oid_list; /* Array of object IDs (OUT) */
    size_t * count;    /* # of objects (OUT) */
} H5VL_file_get_obj_ids_args_t;

/* Parameters for file 'get' operations */
typedef struct H5VL_file_get_args_t {
    H5VL_file_get_t op_type; /* Operation to perform */

    /* Parameters for each operation */
    union {
        /* H5VL_FILE_GET_CONT_INFO */
        struct {
            H5VL_file_cont_info_t *info; /* Container info (OUT) */
        } get_cont_info;

        /* H5VL_FILE_GET_FAPL */
        struct {
            hid_t fapl_id; /* File access property list (OUT) */
        } get_fapl;

        /* H5VL_FILE_GET_FCPL */
        struct {
            hid_t fcpl_id; /* File creation property list (OUT) */
        } get_fcpl;

        /* H5VL_FILE_GET_FILENO */
        struct {
            unsigned long *fileno; /* File "number" (OUT) */
        } get_fileno;

        /* H5VL_FILE_GET_INTENT */
        struct {
            unsigned *flags; /* File open/create intent flags (OUT) */
        } get_intent;

        /* H5VL_FILE_GET_NAME */
        H5VL_file_get_name_args_t get_name;

        /* H5VL_FILE_GET_OBJ_COUNT */
        struct {
            unsigned types; /* Type of objects to count */
            size_t * count; /* # of objects (OUT) */
        } get_obj_count;

        /* H5VL_FILE_GET_OBJ_IDS */
        H5VL_file_get_obj_ids_args_t get_obj_ids;
    } args;
} H5VL_file_get_args_t;

\end{lstlisting}

\subsubsection{file: specific}
The \texttt{specific} callback in the file class implements specific operations on HDF5 files as specified in the \texttt{specific\_type} parameter. It returns an \texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox] 
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*specific)(void *obj, H5VL_file_specific_args_t *args, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The container or object where the operation needs
  to happen.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\begin{lstlisting}
/* Values for file 'specific' operation */
typedef enum H5VL_file_specific_t {
    H5VL_FILE_FLUSH,         /* Flush file                       */
    H5VL_FILE_REOPEN,        /* Reopen the file                  */
    H5VL_FILE_IS_ACCESSIBLE, /* Check if a file is accessible    */
    H5VL_FILE_DELETE,        /* Delete a file                    */
    H5VL_FILE_IS_EQUAL       /* Check if two files are the same  */
} H5VL_file_specific_t;

/* Parameters for file 'specific' operations */
typedef struct H5VL_file_specific_args_t {
    H5VL_file_specific_t op_type; /* Operation to perform */

    /* Parameters for each operation */
    union {
        /* H5VL_FILE_FLUSH */
        struct {
            H5I_type_t  obj_type; /* Type of object to use */
            H5F_scope_t scope;    /* Scope of flush operation */
        } flush;

        /* H5VL_FILE_REOPEN */
        struct {
            void **file; /* File object for new file (OUT) */
        } reopen;

        /* H5VL_FILE_IS_ACCESSIBLE */
        struct {
            const char *filename;   /* Name of file to check */
            hid_t       fapl_id;    /* File access property list to use */
            hbool_t *   accessible; /* Whether file is accessible with FAPL settings (OUT) */
        } is_accessible;

        /* H5VL_FILE_DELETE */
        struct {
            const char *filename; /* Name of file to delete */
            hid_t       fapl_id;  /* File access property list to use */
        } del;

        /* H5VL_FILE_IS_EQUAL */
        struct {
            void *   obj2;      /* Second file object to compare against */
            hbool_t *same_file; /* Whether files are the same (OUT) */
        } is_equal;
    } args;
} H5VL_file_specific_args_t;
\end{lstlisting}

\subsubsection{file: optional}
The \texttt{optional} callback in the file class implements connector specific operations on an HDF5 container. It returns an 
\texttt{herr\_t} indicating success or failure. \bigskip
\begin{mdframed}[style=bgbox] 
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*optional)(void *obj, H5VL_optional_args_t *args, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The container or object where the operation needs to happen.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the operation created by the connector.\\
\end{tabular}
\end{mdframed}

Each connector that requires connector-specific operations should compare the
value of the {\tt op\_type} field of the {\tt H5VL\_optional\_args\_t} struct
with the values returned from calling {\tt H5VLregister\_opt\_operation} to
determine how to handle the optional call and interpret the arguments passed
in the struct.

\subsubsection{file: close}
The \texttt{close} callback in the file class should terminate access to
the file object and free all resources it was consuming, and returns
an \texttt{herr\_t} indicating success or failure.\bigskip\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*close)(void *file, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{file} & (IN): Pointer to the file.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

%%%%%%%%%%%%%%%%%%%
% GROUP CALLBACKS %
%%%%%%%%%%%%%%%%%%%

\subsection{Group Callbacks}
The group API routines (H5G) allow HDF5 users to create and manage
HDF5 groups. All the H5G API routines that modify the HDF5 container
map to one of the group callback routines in this class that the
connector needs to implement.

\begin{lstlisting}[caption={Structure for group callback routines, H5VLconnector.h}, captionpos=b, label={lst:Groupclass}]
typedef struct H5VL_group_class_t {                                              
    void *(*create)(void *obj, const H5VL_loc_params_t *loc_params, const char *name, hid_t lcpl_id, hid_t gcpl_id, hid_t gapl_id, hid_t dxpl_id, void **req);
    void *(*open)(void *obj, const H5VL_loc_params_t *loc_params, const char *name, hid_t gapl_id, hid_t dxpl_id, void **req);
    herr_t (*get)(void *obj, H5VL_group_get_args_t *args, hid_t dxpl_id, void **req);
    herr_t (*specific)(void *obj, H5VL_group_specific_args_t *args, hid_t dxpl_id, void **req);
    herr_t (*optional)(void *obj, H5VL_optional_args_t *args, hid_t dxpl_id, void **req);
    herr_t (*close) (void *grp, hid_t dxpl_id, void **req);
} H5VL_group_class_t; 
\end{lstlisting}

\subsubsection{group: create}
The \texttt{create} callback in the group class creates a group
object in the container of the location object and returns a pointer
to the group structure containing information to access the group in
future calls.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    void *(*create)(void *obj, H5VL_loc_params_t *loc_params, const char *name, hid_t gcpl_id, hid_t gapl_id, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): Pointer to an object where the group needs
  to be created or where the look-up of the target object needs to
  start.\\
  \texttt{loc\_params} & (IN): Pointer to the location parameters as explained in
  Section~\ref{sec:map}. The type can be only \texttt{H5VL\_OBJECT\_BY\_SELF} in this callback. \\
  \texttt{name} & (IN): The name of the group to be created.\\
  \texttt{dcpl\_id} & (IN): The group creation property list. It contains
  all the group creation properties in addition to the link creation
  property list of the create operation (an \texttt{hid\_t}) that can be
  retrieved with the property \texttt{H5VL\_GRP\_LCPL\_ID}.\\
  \texttt{gapl\_id} & (IN): The group access property list.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\subsubsection{group: open}
The \texttt{open} callback in the group class opens a group object
in the container of the location object and returns a pointer to the
group structure containing information to access the group in future
calls.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    void *(*open)(void *obj, H5VL_loc_params_t *loc_params, 
        const char*name, hid_t gapl_id, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): Pointer to an object where the group needs to be
  opened or where the look-up of the target object needs to start.\\
  \texttt{loc\_params} & (IN): Pointer to the location parameters as explained in
  Section~\ref{sec:map}. The type can be only \texttt{H5VL\_OBJECT\_BY\_SELF} in this callback. \\
  \texttt{name} & (IN): The name of the group to be opened.\\
  \texttt{dapl\_id} & (IN): The group access property list.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\subsubsection{group: get}
The \texttt{get} callback in the group class retrieves information
about the group as specified in the \texttt{get\_type} parameter. It
returns an \texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*get)(void *obj, H5VL_group_get_args_t *args, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The group object where information needs to be
  retrieved from.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\begin{lstlisting}
/* Values for group 'get' operation */
typedef enum H5VL_group_get_t {
    H5VL_GROUP_GET_GCPL, /* group creation property list     */
    H5VL_GROUP_GET_INFO  /* group info                       */
} H5VL_group_get_t;

/* Parameters for group 'get_info' operation */
typedef struct H5VL_group_get_info_args_t {
    H5VL_loc_params_t loc_params; /* Location parameters for object access */
    H5G_info_t *      ginfo;      /* Group info (OUT) */
} H5VL_group_get_info_args_t;

/* Parameters for group 'get' operations */
typedef struct H5VL_group_get_args_t {
    H5VL_group_get_t op_type; /* Operation to perform */

    /* Parameters for each operation */
    union {
        /* H5VL_GROUP_GET_GCPL */
        struct {
            hid_t gcpl_id; /* Group creation property list (OUT) */
        } get_gcpl;

        /* H5VL_GROUP_GET_INFO */
        H5VL_group_get_info_args_t get_info; /* Group info */
    } args;
} H5VL_group_get_args_t;

\end{lstlisting}

\subsubsection{group: specific}
The \texttt{specific} callback in the group class implements specific operations on HDF5 groups as specified in the \texttt{specific\_type} parameter. It returns an \texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
	herr_t (*specific)(void *obj, H5VL_loc_params_t *loc_params, H5VL_object_specific_args_t *args, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The container or object where the operation needs to happen.\\
  \texttt{loc\_params} & (IN): Pointer to the location parameters as explained in Section~\ref{sec:map}.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\begin{lstlisting}
/* Values for group 'specific' operation */
typedef enum H5VL_group_specific_t {
    H5VL_GROUP_MOUNT,   /* Mount a file on a group          */
    H5VL_GROUP_UNMOUNT, /* Unmount a file on a group        */
    H5VL_GROUP_FLUSH,   /* H5Gflush                         */
    H5VL_GROUP_REFRESH  /* H5Grefresh                       */
} H5VL_group_specific_t;

/* Parameters for group 'mount' operation */
typedef struct H5VL_group_spec_mount_args_t {
    const char *name;       /* Name of location to mount child file */
    void *      child_file; /* Pointer to child file object */
    hid_t       fmpl_id;    /* File mount property list to use */
} H5VL_group_spec_mount_args_t;

/* Parameters for group 'specific' operations */
typedef struct H5VL_group_specific_args_t {
    H5VL_group_specific_t op_type; /* Operation to perform */

    /* Parameters for each operation */
    union {
        /* H5VL_GROUP_MOUNT */
        H5VL_group_spec_mount_args_t mount;

        /* H5VL_GROUP_UNMOUNT */
        struct {
            const char *name; /* Name of location to unmount child file */
        } unmount;

        /* H5VL_GROUP_FLUSH */
        struct {
            hid_t grp_id; /* Group ID (IN) */
        } flush;

        /* H5VL_GROUP_REFRESH */
        struct {
            hid_t grp_id; /* Group ID (IN) */
        } refresh;
    } args;
} H5VL_group_specific_args_t;

\end{lstlisting}

\subsubsection{group: optional}
The \texttt{optional} callback in the group class implements connector specific operations on an HDF5 group. It returns an \texttt{herr\_t} indicating success or failure. \bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*optional)(void *obj, H5VL_optional_args_t *args, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The container or object where the operation needs to happen.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the operation created by the connector.\\
\end{tabular}
\end{mdframed}

Each connector that requires connector-specific operations should compare the
value of the {\tt op\_type} field of the {\tt H5VL\_optional\_args\_t} struct
with the values returned from calling {\tt H5VLregister\_opt\_operation} to
determine how to handle the optional call and interpret the arguments passed
in the struct.

\subsubsection{group: close}
The \texttt{close} callback in the group class terminates access to
the group object and frees all resources it was consuming, and returns
an \texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*close)(void *group, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{group} & (IN): Pointer to the group object.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

%%%%%%%%%%%%%%%%%%
% LINK CALLBACKS %
%%%%%%%%%%%%%%%%%%

\subsection{Link Callbacks}
The link API routines (H5L) allow HDF5 users to create and manage
HDF5 links. All the H5L API routines that modify the HDF5 container
map to one of the link callback routines in this class that the
connector needs to implement.

\begin{lstlisting}[caption={Structure for link callback routines, H5VLconnector.h}, captionpos=b, label={lst:H5Lclass}]
typedef struct H5VL_link_class_t {                                               
    herr_t (*create)(H5VL_link_create_args_t *args, void *obj, const H5VL_loc_params_t *loc_params, hid_t lcpl_id, hid_t lapl_id, hid_t dxpl_id, void **req);
    herr_t (*copy)(void *src_obj, const H5VL_loc_params_t *loc_params1, void *dst_obj, const H5VL_loc_params_t *loc_params2, hid_t lcpl_id, hid_t lapl_id, hid_t dxpl_id, void **req);           
    herr_t (*move)(void *src_obj, const H5VL_loc_params_t *loc_params1, void *dst_obj, const H5VL_loc_params_t *loc_params2, hid_t lcpl_id, hid_t lapl_id, hid_t dxpl_id, void **req);           
    herr_t (*get)(void *obj, const H5VL_loc_params_t *loc_params, H5VL_link_get_args_t *args, hid_t dxpl_id, void **req);                 
    herr_t (*specific)(void *obj, const H5VL_loc_params_t *loc_params, H5VL_link_specific_args_t *args, hid_t dxpl_id, void **req);            
    herr_t (*optional)(void *obj, const H5VL_loc_params_t *loc_params, H5VL_optional_args_t *args, hid_t dxpl_id, void **req); 
} H5VL_link_class_t;   
\end{lstlisting}


\subsubsection{link: create}
The \texttt{create} callback in the group class creates a hard,
soft, external, or user-defined link in the container. It returns an
\texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*create)(H5VL_link_create_args_t *args, void *obj,
        H5VL_loc_params_t *loc_params, hid_t lcpl_id, 
        hid_t lapl_id, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{obj} & (IN): Pointer to an object where the link needs to be
  created from.\\
  \texttt{loc\_params} & (IN): Pointer to the location parameters as explained in
  Section~\ref{sec:map} for the source object. \\
  \texttt{lcpl\_id} & (IN): The link creation property list. It contains
  all the link creation properties in addition to other API parameters
  depending on the creation type, which will be detailed next.\\
  \texttt{lapl\_id} & (IN): The link access property list.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\begin{lstlisting}
/* Link create types for VOL */
typedef enum H5VL_link_create_t {
    H5VL_LINK_CREATE_HARD,
    H5VL_LINK_CREATE_SOFT,
    H5VL_LINK_CREATE_UD
} H5VL_link_create_t;

/* Parameters for link 'create' operations */
typedef struct H5VL_link_create_args_t {
    H5VL_link_create_t op_type; /* Operation to perform */

    /* Parameters for each operation */
    union {
        /* H5VL_LINK_CREATE_HARD */
        struct {
            void *            curr_obj;        /* Current object */
            H5VL_loc_params_t curr_loc_params; /* Location parameters for current object */
        } hard;

        /* H5VL_LINK_CREATE_SOFT */
        struct {
            const char *target; /* Target of soft link */
        } soft;

        /* H5VL_LINK_CREATE_UD */
        struct {
            H5L_type_t  type;     /* Type of link to create */
            const void *buf;      /* Buffer that contains link info */
            size_t      buf_size; /* Size of link info buffer */
        } ud;
    } args;
} H5VL_link_create_args_t;

\end{lstlisting}

\subsubsection{link: copy}
The \texttt{copy} callback in the link class copies a link within the HDF5 container. It returns an \texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*copy)(void *src_obj, H5VL_loc_params_t *loc_params1, void *dst_obj, H5VL_loc_params_t *loc_params2, hid_t lcpl_id, hid_t lapl_id, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{src\_obj} & (IN): original/source object or file. \\
  \texttt{loc\_params1} & (IN): Pointer to the location parameters for the source
  object as explained in Section~\ref{sec:map}. The type can be only \texttt{H5VL\_OBJECT\_BY\_NAME} in this callback. \\
  \texttt{dst\_obj} & (IN): destination object or file. \\
  \texttt{loc\_params1} & (IN): Pointer to the location parameters for the destination
  object as explained in Section~\ref{sec:map}. The type can be only \texttt{H5VL\_OBJECT\_BY\_NAME} in this callback. \\
  \texttt{lcpl\_id} & (IN): The link creation property list.\\
  \texttt{lapl\_id} & (IN): The link access property list.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\subsubsection{link: move}
The \texttt{move} callback in the link class moves a link within the HDF5 container. It returns an \texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*move)(void *src_obj, H5VL_loc_params_t *loc_params1, void *dst_obj, H5VL_loc_params_t *loc_params2, hid_t lcpl_id, hid_t lapl_id, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{src\_obj} & (IN): original/source object or file. \\
  \texttt{loc\_params1} & (IN): Pointer to the location parameters for the source
  object as explained in Section~\ref{sec:map}. The type can be only \texttt{H5VL\_OBJECT\_BY\_NAME} in this callback. \\
  \texttt{dst\_obj} & (IN): destination object or file. \\
  \texttt{loc\_params1} & (IN): Pointer to the location parameters for the destination
  object as explained in Section~\ref{sec:map}. The type can be only \texttt{H5VL\_OBJECT\_BY\_NAME} in this callback. \\
  \texttt{lcpl\_id} & (IN): The link creation property list.\\
  \texttt{lapl\_id} & (IN): The link access property list.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\subsubsection{link: get}
The \texttt{get} callback in the link class retrieves information
about links as specified in the \texttt{get\_type} parameter. It
returns an \texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*get)(void *obj, H5VL_loc_params_t *loc_params, 
        H5VL_link_get_args_t *args, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The file or group object where information needs to be
  retrieved from.\\
  \texttt{loc\_params} & (IN): Pointer to the location parameters for the source
  object as explained in Section~\ref{sec:map}. The type can be only \texttt{H5VL\_OBJECT\_BY\_NAME} or \texttt{H5VL\_OBJECT\_BY\_IDX} in this
  callback.\\ 
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\begin{lstlisting}
/* Values for link 'get' operation */
typedef enum H5VL_link_get_t {
    H5VL_LINK_GET_INFO, /* link info                         */
    H5VL_LINK_GET_NAME, /* link name                         */
    H5VL_LINK_GET_VAL   /* link value                        */
} H5VL_link_get_t;

/* Parameters for link 'get' operations */
typedef struct H5VL_link_get_args_t {
    H5VL_link_get_t op_type; /* Operation to perform */

    /* Parameters for each operation */
    union {
        /* H5VL_LINK_GET_INFO */
        struct {
            H5L_info2_t *linfo; /* Pointer to link's info (OUT) */
        } get_info;

        /* H5VL_LINK_GET_NAME */
        struct {
            size_t  name_size; /* Size of link name buffer (IN) */
            char *  name;      /* Buffer for link name (OUT) */
            size_t *name_len;  /* Actual length of link name (OUT) */
        } get_name;

        /* H5VL_LINK_GET_VAL */
        struct {
            size_t buf_size; /* Size of link value buffer (IN) */
            void * buf;      /* Buffer for link value (OUT) */
        } get_val;
    } args;
} H5VL_link_get_args_t;
\end{lstlisting}

\subsubsection{link: specific}
The \texttt{specific} callback in the link class implements specific operations on HDF5 links as specified in the \texttt{specific\_type} parameter. It returns an \texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
	herr_t (*specific)(void *obj, H5VL_loc_params_t *loc_params, H5VL_link_specific_args_t *args, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The location object  where the operation needs to happen.\\
  \texttt{loc\_params} & (IN): Pointer to the location parameters as explained in Section~\ref{sec:map}.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\begin{lstlisting}
/* Values for link 'specific' operation */
typedef enum H5VL_link_specific_t {
    H5VL_LINK_DELETE, /* H5Ldelete(_by_idx)                */
    H5VL_LINK_EXISTS, /* link existence                    */
    H5VL_LINK_ITER    /* H5Literate/visit(_by_name)              */
} H5VL_link_specific_t;

/* Parameters for link 'iterate' operation */
typedef struct H5VL_link_iterate_args_t {
    hbool_t         recursive; /* Whether iteration is recursive */
    H5_index_t      idx_type;  /* Type of index to iterate over */
    H5_iter_order_t order;     /* Order of index iteration */
    hsize_t *       idx_p;     /* Start/stop iteration index (OUT) */
    H5L_iterate2_t  op;        /* Iteration callback function */
    void *          op_data;   /* Iteration callback context */
} H5VL_link_iterate_args_t;

/* Parameters for link 'specific' operations */
typedef struct H5VL_link_specific_args_t {
    H5VL_link_specific_t op_type; /* Operation to perform */

    /* Parameters for each operation */
    union {
        /* H5VL_LINK_DELETE */
        /* No args */

        /* H5VL_LINK_EXISTS */
        struct {
            hbool_t *exists; /* Whether link exists (OUT) */
        } exists;

        /* H5VL_LINK_ITER */
        H5VL_link_iterate_args_t iterate;
    } args;
} H5VL_link_specific_args_t;

\end{lstlisting}

\subsubsection{link: optional}
The \texttt{optional} callback in the link class implements connector specific operations on an HDF5 link. It returns an \texttt{herr\_t} indicating success or failure.\bigskip 

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*optional)(void *obj, const H5VL_loc_params_t *loc_params, H5VL_optional_args_t *args, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The container or object where the operation needs to happen.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the operation created by the connector.\\
\end{tabular}
\end{mdframed}

Each connector that requires connector-specific operations should compare the
value of the {\tt op\_type} field of the {\tt H5VL\_optional\_args\_t} struct
with the values returned from calling {\tt H5VLregister\_opt\_operation} to
determine how to handle the optional call and interpret the arguments passed
in the struct.


%%%%%%%%%%%%%%%%%%%%
% OBJECT CALLBACKS %
%%%%%%%%%%%%%%%%%%%%

\subsection{Object Callbacks}
The object API routines (H5O) allow HDF5 users to manage HDF5 group,
dataset, and named datatype objects. All the H5O API routines that
modify the HDF5 container map to one of the object callback routines
in this class that the connector needs to implement.

\begin{lstlisting}[caption={Structure for object callback routines, H5VLconnector.h}, captionpos=b, label={lst:H5Oclass}]
typedef struct H5VL_object_class_t {                                             
    void *(*open)(void *obj, const H5VL_loc_params_t *loc_params, H5I_type_t *opened_type, hid_t dxpl_id, void **req);                                    
    herr_t (*copy)(void *src_obj, const H5VL_loc_params_t *loc_params1, const char *src_name, void *dst_obj, const H5VL_loc_params_t *loc_params2, const char *dst_name, hid_t ocpypl_id, hid_t lcpl_id, hid_t dxpl_id, void **req);   
    herr_t (*get)(void *obj, const H5VL_loc_params_t *loc_params, H5VL_object_get_args_t *args, hid_t dxpl_id, void **req);                 
    herr_t (*specific)(void *obj, const H5VL_loc_params_t *loc_params, H5VL_object_specific_args_t *args, hid_t dxpl_id, void **req);            
    herr_t (*optional)(void *obj, const H5VL_loc_params_t *loc_params, H5VL_optional_args_t *args, hid_t dxpl_id, void **req); 
} H5VL_object_class_t; 
\end{lstlisting}

\subsubsection{object: open}
The \texttt{open} callback in the object class opens the object in
the container of the location object and returns a pointer to the
object structure containing information to access the object in future
calls.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    void *(*open)(void *obj, H5VL_loc_params_t *loc_params, 
        H5I_type_t *opened_type, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): Pointer to a file or group where the objecy needs to be
  opened or where the look-up of the target object needs to start.\\
  \texttt{loc\_params} & (IN): Pointer to location parameters as explained in
  Section~\ref{sec:map}.\\
  \texttt{opened\_type} & (OUT): buffer to return the type of the object
  opened (\texttt{H5I\_GROUP} or \texttt{H5I\_DATASET} or \texttt{H5I\_DATATYPE}).\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\subsubsection{object: copy}
The \texttt{copy} callback in the object class  copies the object
from the source object to the destination object. It returns an \texttt{
  herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*copy)(void *src_obj, H5VL_loc_params_t *loc_params1, 
        const char *src_name, void *dst_obj, 
        H5VL_loc_params_t *loc_params2, const char *dst_name,
        hid_t ocpypl_id, hid_t lcpl_id, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{src\_obj} & (IN): Pointer to location of the source object to
  be copied.\\
  \texttt{loc\_params1} & (IN): Pointer to location parameters as explained in
  Section~\ref{sec:map}. The type should only be \texttt{H5VL\_OBJECT\_BY\_SELF} for this callback.\\
  \texttt{src\_name} & (IN): Name of the source object to
  be copied.\\
  \texttt{dst\_obj} & (IN): Pointer to location of the destination
  object.\\
  \texttt{loc\_params2} & (IN): Pointer to location parameters as explained in
  Section~\ref{sec:map}. The type should only be \texttt{H5VL\_OBJECT\_BY\_SELF} for this callback.\\
  \texttt{dst\_name} & (IN): Name to be assigned to the new copy.\\
  \texttt{ocpypl\_id} & (IN): The object copy property list.\\
  \texttt{lcpl\_id} & (IN): The link creation property list.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\subsubsection{object: get}
The \texttt{get} callback in the object class retrieves information
about the object as specified in the \texttt{get\_type} parameter.It
returns an \texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*get)(void *obj, H5VL_loc_params_t *loc_params, 
        H5VL_object_get_args_t *args, hid_t dxpl_id, 
        void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): A location object where information needs to be
  retrieved from.\\
  \texttt{loc\_params} & (IN): Pointer to location parameters as
  explained in Section~\ref{sec:map}.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\begin{lstlisting}
/* Values for object 'get' operation */
typedef enum H5VL_object_get_t {
    H5VL_OBJECT_GET_FILE, /* object file                       */
    H5VL_OBJECT_GET_NAME, /* object name                       */
    H5VL_OBJECT_GET_TYPE, /* object type                       */
    H5VL_OBJECT_GET_INFO  /* H5Oget_info(_by_idx|name)         */
} H5VL_object_get_t;

/* Parameters for object 'get' operations */
typedef struct H5VL_object_get_args_t {
    H5VL_object_get_t op_type; /* Operation to perform */

    /* Parameters for each operation */
    union {
        /* H5VL_OBJECT_GET_FILE */
        struct {
            void **file; /* File object (OUT) */
        } get_file;

        /* H5VL_OBJECT_GET_NAME */
        struct {
            size_t  buf_size; /* Size of name buffer (IN) */
            char *  buf;      /* Buffer for name (OUT) */
            size_t *name_len; /* Actual length of name (OUT) */
        } get_name;

        /* H5VL_OBJECT_GET_TYPE */
        struct {
            H5O_type_t *obj_type; /* Type of object (OUT) */
        } get_type;

        /* H5VL_OBJECT_GET_INFO */
        struct {
            unsigned     fields; /* Flags for fields to retrieve */
            H5O_info2_t *oinfo;  /* Pointer to object info (OUT) */
        } get_info;
    } args;
} H5VL_object_get_args_t;
\end{lstlisting}

\subsubsection{object: specific}
The \texttt{specific} callback in the object class implements specific operations on HDF5 objects as specified in the \texttt{specific\_type} parameter. It returns an \texttt{herr\_t} indicating success or failure.\bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
	herr_t (*specific)(void *obj, H5VL_loc_params_t *loc_params, H5VL_object_specific_args_t *args, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The location object  where the operation needs to happen.\\
  \texttt{loc\_params} & (IN): Pointer to location parameters as explained in Section~\ref{sec:map}.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the
  operation created by the connector.\\
\end{tabular}
\end{mdframed}

\begin{lstlisting}
/* Values for object 'specific' operation */
typedef enum H5VL_object_specific_t {
    H5VL_OBJECT_CHANGE_REF_COUNT, /* H5Oincr/decr_refcount             */
    H5VL_OBJECT_EXISTS,           /* H5Oexists_by_name                 */
    H5VL_OBJECT_LOOKUP,           /* Lookup object                     */
    H5VL_OBJECT_VISIT,            /* H5Ovisit(_by_name)                */
    H5VL_OBJECT_FLUSH,            /* H5{D|G|O|T}flush                  */
    H5VL_OBJECT_REFRESH           /* H5{D|G|O|T}refresh                */
} H5VL_object_specific_t;

/* Parameters for object 'visit' operation */
typedef struct H5VL_object_visit_args_t {
    H5_index_t      idx_type; /* Type of index to iterate over */
    H5_iter_order_t order;    /* Order of index iteration */
    unsigned        fields;   /* Flags for fields to provide in 'info' object for 'op' callback */
    H5O_iterate2_t  op;       /* Iteration callback function */
    void *          op_data;  /* Iteration callback context */
} H5VL_object_visit_args_t;

/* Parameters for object 'specific' operations */
typedef struct H5VL_object_specific_args_t {
    H5VL_object_specific_t op_type; /* Operation to perform */

    /* Parameters for each operation */
    union {
        /* H5VL_OBJECT_CHANGE_REF_COUNT */
        struct {
            int delta; /* Amount to modify object's refcount */
        } change_rc;

        /* H5VL_OBJECT_EXISTS */
        struct {
            hbool_t *exists; /* Whether object exists (OUT) */
        } exists;

        /* H5VL_OBJECT_LOOKUP */
        struct {
            H5O_token_t *token_ptr; /* Pointer to token for lookup (OUT) */
        } lookup;

        /* H5VL_OBJECT_VISIT */
        H5VL_object_visit_args_t visit;

        /* H5VL_OBJECT_FLUSH */
        struct {
            hid_t obj_id; /* Object ID (IN) */
        } flush;

        /* H5VL_OBJECT_REFRESH */
        struct {
            hid_t obj_id; /* Object ID (IN) */
        } refresh;
    } args;
} H5VL_object_specific_args_t;
\end{lstlisting}

\subsubsection{object: optional}
The \texttt{optional} callback in the object class implements connector specific operations on an HDF5 object. It returns an \texttt{herr\_t} indicating success or failure. \bigskip

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*optional)(void *obj, const H5VL_loc_params_t *loc_params, H5VL_optional_args_t *args, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The container or object where the operation needs to happen.\\
  \texttt{loc\_params} & (IN): Pointer to location parameters as explained in Section~\ref{sec:map}.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the operation created by the connector.\\
\end{tabular}
\end{mdframed}

Each connector that requires connector-specific operations should compare the
value of the {\tt op\_type} field of the {\tt H5VL\_optional\_args\_t} struct
with the values returned from calling {\tt H5VLregister\_opt\_operation} to
determine how to handle the optional call and interpret the arguments passed
in the struct.


%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTROSPECTION CALLBACKS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Introspection Callbacks}

\begin{lstlisting}[caption={Structure for VOL connector introspection callback routines, H5VLconnector.h}, captionpos=b, label={lst:Introspectclass}]
typedef struct H5VL_introspect_class_t {                                            
    herr_t (*get_conn_cls)(void *obj, H5VL_get_conn_lvl_t lvl, const struct H5VL_class_t **conn_cls);
    herr_t (*get_cap_flags)(const void *info, unsigned *cap_flags);
    herr_t (*opt_query)(void *obj, H5VL_subclass_t cls, int opt_type, hbool_t *supported);
} H5VL_introspect_class_t;
\end{lstlisting}

\subsubsection{introspect: get\_conn\_cls}
Get a connector's H5VL\_class\_t struct.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*get_conn_cls)(void *obj, H5VL_get_conn_lvl_t lvl, const struct H5VL_class_t **conn_cls);
\end{lstlisting}

The \texttt{lvl} argument is an \texttt{enum}:
\begin{lstlisting}
/* "Levels" for 'get connector class' introspection callback */                  
typedef enum H5VL_get_conn_lvl_t {
    H5VL_GET_CONN_LVL_CURR,         /* Get "current" connector (for this object) */
    H5VL_GET_CONN_LVL_TERM          /* Get "terminal" connector (for this object) */
                                    /* (Recursively called, for pass-through connectors) */
                                    /* (Connectors that "split" must choose which connector to return) */
} H5VL_get_conn_lvl_t;
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The VOL object.\\
  \texttt{lvl} & (IN): Current or terminal connector.\\
  \texttt{cls} & (OUT): A const pointer to the connector.\\
\end{tabular}
\end{mdframed}

\subsubsection{introspect: get\_cap\_flags}
Get a connector's capability flags.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*get_cap_flags)(const void *info, unsigned *cap_flags);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{info} & (IN): A const pointer to pertinent VOL info.\\
  \texttt{cap\_flags} & (OUT): A pointer to capability flags.\\
\end{tabular}
\end{mdframed}


\subsubsection{introspect: opt\_query}
Query a class for a capability or functionality.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*opt_query)(void *obj, H5VL_subclass_t cls, int opt_type, hbool_t *supported);
\end{lstlisting}

The \texttt{lvl} argument is an \texttt{enum}:
\begin{lstlisting}
/* Enum type for each VOL subclass */
/* (Used for various queries, etc) */
typedef enum H5VL_subclass_t {
    H5VL_SUBCLS_NONE,                   /* Operations outside of a subclass */
    H5VL_SUBCLS_INFO,                   /* 'Info' subclass */
    H5VL_SUBCLS_WRAP,                   /* 'Wrap' subclass */
    H5VL_SUBCLS_ATTR,                   /* 'Attribute' subclass */
    H5VL_SUBCLS_DATASET,                /* 'Dataset' subclass */
    H5VL_SUBCLS_DATATYPE,               /* 'Named datatype' subclass */
    H5VL_SUBCLS_FILE,                   /* 'File' subclass */
    H5VL_SUBCLS_GROUP,                  /* 'Group' subclass */
    H5VL_SUBCLS_LINK,                   /* 'Link' subclass */
    H5VL_SUBCLS_OBJECT,                 /* 'Object' subclass */
    H5VL_SUBCLS_REQUEST,                /* 'Request' subclass */
    H5VL_SUBCLS_BLOB,                   /* 'Blob' subclass */
    H5VL_SUBCLS_TOKEN                   /* 'Token' subclass */
} H5VL_subclass_t;
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The VOL object.\\
  \texttt{cls} & (IN): The VOL 'class' to query.\\
  \texttt{opt\_type} & (IN): The specific option to query.\\
  \texttt{supported} & (OUT): Whether the operation is supported or not.\\
\end{tabular}
\end{mdframed}


%%%%%%%%%%%%%%%%%%%%%
% REQUEST CALLBACKS %
%%%%%%%%%%%%%%%%%%%%%

\subsection{Request (Async) Callbacks}

\begin{lstlisting}[caption={Structure for async request callback routines, H5VLconnector.h}, captionpos=b, label={lst:Requestclass}]
typedef struct H5VL_request_class_t {
    herr_t (*wait)(void *req, uint64_t timeout, H5VL_request_status_t *status);
    herr_t (*notify)(void *req, H5VL_request_notify_t cb, void *ctx);
    herr_t (*cancel)(void *req, H5VL_request_status_t *status);
    herr_t (*specific)(void *req, H5VL_request_specific_args_t *args);
    herr_t (*optional)(void *req, H5VL_optional_args_t *args);
    herr_t (*free)(void *req);
} H5VL_request_class_t;
\end{lstlisting}

\subsubsection{request: wait}
Wait (with a timeout) for an async operation to complete. Releases the request if the operation has completed and the connector callback succeeds.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*wait)(void *req, uint64_t timeout, H5ES_status_t *status);          
\end{lstlisting}

The \texttt{status} argument is an \texttt{enum} (from \texttt{H5ESpublic.h}):
\begin{lstlisting}
/* Asynchronous operation status */                                              
typedef enum H5ES_status_t {                                                     
    H5ES_STATUS_IN_PROGRESS,   /* Operation has not yet completed                       */
    H5ES_STATUS_SUCCEED,       /* Operation has completed, successfully                 */
    H5ES_STATUS_FAIL,          /* Operation has completed, but failed                   */
    H5ES_STATUS_CANCELED       /* Operation has not completed and was canceled          */
} H5ES_status_t;
\end{lstlisting} 
    
\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{req} & (IN): The async request on which to wait.\\
  \texttt{timeout} & (IN): The timeout value.\\
  \texttt{status} & (IN): The status.\\
\end{tabular}
\end{mdframed}

\subsubsection{request: notify}
Registers a user callback to be invoked when an asynchronous operation completes. Releases the request if connector callback succeeds.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*notify)(void *req, H5VL_request_notify_t cb, void *ctx);            
\end{lstlisting}

The \texttt{cb} argument is a function pointer:
\begin{lstlisting}
    typedef herr_t (*H5VL_request_notify_t)(void *ctx, H5ES_status_t status);
\end{lstlisting} 

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{req} & (IN): The async request that will receive the notify callback.\\
  \texttt{cb} & (IN): The notify callback for the request.\\
  \texttt{ctx} & (IN): The request's context.\\
\end{tabular}
\end{mdframed}

\subsubsection{request: cancel}
Cancels an asynchronous operation. Releases the request if connector callback succeeds.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*cancel)(void *req);                                                 
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{req} & (IN): The async request to be cancelled.\\
\end{tabular}
\end{mdframed}

\subsubsection{request: specific}
Perform a specific operation on an asynchronous request.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*specific)(void *req, H5VL_request_specific_args_t *args);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{req} & (IN): The async request on which to perform the operation.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
\end{tabular}
\end{mdframed}

\begin{lstlisting}
/* Values for async request 'specific' operation */
typedef enum H5VL_request_specific_t {
    H5VL_REQUEST_GET_ERR_STACK, /* Retrieve error stack for failed operation */
    H5VL_REQUEST_GET_EXEC_TIME  /* Retrieve execution time for operation */
} H5VL_request_specific_t;

/* Parameters for request 'specific' operations */
typedef struct H5VL_request_specific_args_t {
    H5VL_request_specific_t op_type; /* Operation to perform */

    /* Parameters for each operation */
    union {
        /* H5VL_REQUEST_GET_ERR_STACK */
        struct {
            hid_t err_stack_id; /* Error stack ID for operation (OUT) */
        } get_err_stack;

        /* H5VL_REQUEST_GET_EXEC_TIME */
        struct {
            uint64_t *exec_ts;   /* Timestamp for start of task execution (OUT) */
            uint64_t *exec_time; /* Duration of task execution (in ns) (OUT) */
        } get_exec_time;
    } args;
} H5VL_request_specific_args_t;

\end{lstlisting}

\subsubsection{request: optional}
Perform a connector-specific operation for a request.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*optional)(void *req, H5VL_optional_args_t *args);                            
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{req} & (IN): The async request on which to perform the operation.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
\end{tabular}
\end{mdframed}

Each connector that requires connector-specific operations should compare the
value of the {\tt op\_type} field of the {\tt H5VL\_optional\_args\_t} struct
with the values returned from calling {\tt H5VLregister\_opt\_operation} to
determine how to handle the optional call and interpret the arguments passed
in the struct.


\subsubsection{request: free}
Frees an asynchronous request.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*free)(void *req);                                                   
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{req} & (IN): The async request to be freed.\\
\end{tabular}
\end{mdframed}


%%%%%%%%%%%%%%%%%%%
% BLOB CALLBACKS %
%%%%%%%%%%%%%%%%%%%

\subsection{Blob Callbacks}
\begin{lstlisting}[caption={Structure for blob callback routines, H5VLconnector.h}, captionpos=b, label={lst:Blobclass}]
typedef struct H5VL_blob_class_t {                                               
    herr_t (*put)(void *obj, const void *buf, size_t size, void *blob_id, void *ctx);
    herr_t (*get)(void *obj, const void *blob_id, void *buf, size_t size, void *ctx);
    herr_t (*specific)(void *obj, void *blob_id, H5VL_blob_specific_args_t *args);
    herr_t (*optional)(void *obj, void *blob_id, H5VL_optional_args_t *args);
} H5VL_blob_class_t; 
\end{lstlisting}

\subsubsection{blob: put}
Put a blob through the VOL.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*put)(void *obj, const void *buf, size_t size, void *blob_id, void *ctx);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): Pointer to the blob container.\\
  \texttt{buf} & (IN): Pointer to the blob.\\
  \texttt{size} & (IN): Size of the blob.\\
  \texttt{blob\_id} & (OUT): Pointer to the blob's connector-specific ID.\\
  \texttt{ctx} & (IN): Connector-specific blob context.\\
\end{tabular}
\end{mdframed}

\subsubsection{blob: get}
Get a blob through the VOL.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*get)(void *obj, const void *blob_id, void *buf, size_t size, void *ctx);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): Pointer to the blob container.\\
  \texttt{blob\_id} & (IN): Pointer to the blob's connector-specific ID.\\
  \texttt{buf} & (IN/OUT): Pointer to the blob.\\
  \texttt{size} & (IN): Size of the blob.\\
  \texttt{ctx} & (IN): Connector-specific blob context.\\
\end{tabular}
\end{mdframed}

\subsubsection{blob: specific}
Perform a defined operation on a blob via the VOL.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*specific)(void *obj, void *blob_id, H5VL_blob_specific_args_t *args);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): Pointer to the blob container.\\
  \texttt{blob\_id} & (IN): Pointer to the blob's connector-specific ID.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
\end{tabular}
\end{mdframed}

\begin{lstlisting}
/* Values for 'blob' 'specific' operation */
typedef enum H5VL_blob_specific_t {
    H5VL_BLOB_DELETE, /* Delete a blob (by ID) */
    H5VL_BLOB_ISNULL, /* Check if a blob ID is "null" */
    H5VL_BLOB_SETNULL /* Set a blob ID to the connector's "null" blob ID value */
} H5VL_blob_specific_t;

/* Parameters for blob 'specific' operations */
typedef struct H5VL_blob_specific_args_t {
    H5VL_blob_specific_t op_type; /* Operation to perform */

    /* Parameters for each operation */
    union {
        /* H5VL_BLOB_DELETE */
        /* No args */

        /* H5VL_BLOB_ISNULL */
        struct {
            hbool_t *isnull; /* Whether blob ID is "null" (OUT) */
        } is_null;

        /* H5VL_BLOB_SETNULL */
        /* No args */
    } args;
} H5VL_blob_specific_args_t;
\end{lstlisting}

\subsubsection{blob: optional}
Perform a connector-specific operation on a blob via the VOL.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*optional)(void *obj, void *blob_id, H5VL_optional_args_t *args);             
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): Pointer to the blob container.\\
  \texttt{blob\_id} & (IN): Pointer to the blob's connector-specific ID.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
\end{tabular}
\end{mdframed}

Each connector that requires connector-specific operations should compare the
value of the {\tt op\_type} field of the {\tt H5VL\_optional\_args\_t} struct
with the values returned from calling {\tt H5VLregister\_opt\_operation} to
determine how to handle the optional call and interpret the arguments passed
in the struct.


%%%%%%%%%%%%%%%%%%%
% TOKEN CALLBACKS %
%%%%%%%%%%%%%%%%%%%

\subsection{Token Callbacks}

\begin{lstlisting}[caption={Structure for token callback routines, H5VLconnector.h}, captionpos=b, label={lst:Tokenclass}]
typedef struct H5VL_token_class_t { 
    herr_t (*cmp)(void *obj, const H5O_token_t *token1, const H5O_token_t *token2, int *cmp_value);
    herr_t (*to_str)(void *obj, H5I_type_t obj_type, const H5O_token_t *token, char **token_str);
    herr_t (*from_str)(void *obj, H5I_type_t obj_type, const char *token_str, H5O_token_t *token);
} H5VL_token_class_t;
\end{lstlisting}

\subsubsection{token: cmp}
Compares two tokens and outputs a value like strcmp.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*cmp)(void *obj, const H5O_token_t *token1, const H5O_token_t *token2, int *cmp_value);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The underlying VOL object.\\
  \texttt{token1} & (IN): The first token to compare.\\
  \texttt{token2} & (IN): The second token to compare.\\
  \texttt{cmp\_value} & (OUT): A value like strcmp.\\
\end{tabular}
\end{mdframed}

\subsubsection{token: to\_str}
Converts a token to a string representation.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*to_str)(void *obj, H5I_type_t obj_type, const H5O_token_t *token, char **token_str);
\end{lstlisting}

The \texttt{obj\_type} argument is an \texttt{enum} (from \texttt{H5Ipublic.h}):
\begin{lstlisting}
typedef enum H5I_type_t {                                                        
    H5I_UNINIT      = (-2),     /* uninitialized type                           */
    H5I_BADID       = (-1),     /* invalid Type                                 */
    H5I_FILE        = 1,        /* type ID for File objects                     */
    H5I_GROUP,                  /* type ID for Group objects                    */
    H5I_DATATYPE,               /* type ID for Datatype objects                 */
    H5I_DATASPACE,              /* type ID for Dataspace objects                */
    H5I_DATASET,                /* type ID for Dataset objects                  */
    H5I_MAP,                    /* type ID for Map objects                      */
    H5I_ATTR,                   /* type ID for Attribute objects                */
    H5I_VFL,                    /* type ID for virtual file layer               */
    H5I_VOL,                    /* type ID for virtual object layer             */
    H5I_GENPROP_CLS,            /* type ID for generic property list classes    */
    H5I_GENPROP_LST,            /* type ID for generic property lists           */
    H5I_ERROR_CLASS,            /* type ID for error classes                    */
    H5I_ERROR_MSG,              /* type ID for error messages                   */
    H5I_ERROR_STACK,            /* type ID for error stacks                     */
    H5I_SPACE_SEL_ITER,         /* type ID for dataspace selection iterator     */
    H5I_NTYPES                  /* number of library types, MUST BE LAST!       */
} H5I_type_t;
\end{lstlisting}
The only values which should be used for this call are:
\begin{itemize}
    \item \texttt{H5I\_GROUP}
    \item \texttt{H5I\_DATATYPE}
    \item \texttt{H5I\_DATASET}
    \item \texttt{H5I\_MAP}
\end{itemize}
as these are the only objects for which tokens are valid.

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The underlying VOL object.\\
  \texttt{obj\_type} & (IN): The type of the object.\\
  \texttt{token} & (IN): The token to turn into a string representation.\\
  \texttt{token\_str} & (OUT): The string representation of the token.\\
\end{tabular}
\end{mdframed}

\subsubsection{token: from\_str}
Converts a string representation of a token to a token.

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*from_str)(void *obj, H5I_type_t obj_type, const char *token_str, H5O_token_t *token);
\end{lstlisting}

The \texttt{obj\_type} argument is an \texttt{enum} (from \texttt{H5Ipublic.h}):
\begin{lstlisting}
typedef enum H5I_type_t {                                                        
    H5I_UNINIT      = (-2),     /* uninitialized type                           */
    H5I_BADID       = (-1),     /* invalid Type                                 */
    H5I_FILE        = 1,        /* type ID for File objects                     */
    H5I_GROUP,                  /* type ID for Group objects                    */
    H5I_DATATYPE,               /* type ID for Datatype objects                 */
    H5I_DATASPACE,              /* type ID for Dataspace objects                */
    H5I_DATASET,                /* type ID for Dataset objects                  */
    H5I_MAP,                    /* type ID for Map objects                      */
    H5I_ATTR,                   /* type ID for Attribute objects                */
    H5I_VFL,                    /* type ID for virtual file layer               */
    H5I_VOL,                    /* type ID for virtual object layer             */
    H5I_GENPROP_CLS,            /* type ID for generic property list classes    */
    H5I_GENPROP_LST,            /* type ID for generic property lists           */
    H5I_ERROR_CLASS,            /* type ID for error classes                    */
    H5I_ERROR_MSG,              /* type ID for error messages                   */
    H5I_ERROR_STACK,            /* type ID for error stacks                     */
    H5I_SPACE_SEL_ITER,         /* type ID for dataspace selection iterator     */
    H5I_NTYPES                  /* number of library types, MUST BE LAST!       */
} H5I_type_t;
\end{lstlisting}
The only values which should be used for this call are:
\begin{itemize}
    \item \texttt{H5I\_GROUP}
    \item \texttt{H5I\_DATATYPE}
    \item \texttt{H5I\_DATASET}
    \item \texttt{H5I\_MAP}
\end{itemize}
as these are the only objects for which tokens are valid.

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The underlying VOL object.\\
  \texttt{obj\_type} & (IN): The type of the object.\\
  \texttt{token\_str} & (IN): The string representation of the token.\\
  \texttt{token} & (OUT): The token created from the string representation.\\
\end{tabular}
\end{mdframed}

%%%%%%%%%%%%%%%%%%%%%
% OPTIONAL CALLBACK %
%%%%%%%%%%%%%%%%%%%%%

\subsection{Optional Generic Callback}
A generic optional callback is provided for services that are specific to a connector.

The \texttt{optional} callback has the following definition. It returns an \texttt{herr\_t} indicating success or failure.\bigskip 

\begin{mdframed}[style=bgbox]
\textbf{Signature:}
\begin{lstlisting}
    herr_t (*optional)(void *obj, H5VL_optional_args_t *args, hid_t dxpl_id, void **req);
\end{lstlisting}

\textbf{Arguments:}\\
\begin{tabular}{l p{13.5cm}}
  \texttt{obj} & (IN): The container or object where the operation needs to happen.\\
  \texttt{args} & (IN/OUT): A pointer to the arguments struct.\\
  \texttt{dxpl\_id} & (IN): The data transfer property list.\\
  \texttt{req} & (IN/OUT): A pointer to the asynchronous request of the operation created by the connector.\\
\end{tabular}
\end{mdframed}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
