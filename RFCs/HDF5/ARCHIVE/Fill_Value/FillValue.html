<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="author" content="Quincey Koziol">
   <title>HDF5 Fill Values & Dataset Storage Allocation Issues</title>
</head>

<body text="#000000" bgcolor="#FFFFFF">
<STYLE type="text/css">
OL.loweralpha { list-style-type: lower-alpha }
OL.upperalpha { list-style-type: upper-alpha }
OL.upperroman { list-style-type: upper-roman }
OL.lowerroman { list-style-type: lower-roman }
OL.arabic     { list-style-type: arabic }
</STYLE>

<CENTER><H1>Fill Value and Dataset Storage Allocation Issues in HDF5</H1></CENTER>
<CENTER><H3>Quincey Koziol<BR>
            koziol@ncsa.uiuc.edu<BR>
            October 9, 2002
</H3></CENTER>

<ol class="upperroman">

<li><h3><u>Document's Audience:</u></h3>
         
<ul>
    <li>Current H5 library designers and knowledgable external developers.</li>
</ul>

<li><h3><u>Background Reading:</u></h3>
         
<ul>
    <li>Previous versions of this document:
        <ul>
            <li>
                <dt><a href="old.020109/index.html">January 9, 2002</a>.
            </li>
            <li>
                <dt><a href="old.020726/FillValue.html">July 26, 2002</a>.
            </li>
            <li>
                <dt><a href="old.020906/FillValue.html">September 6, 2002</a>.
            </li>
        </ul>
    </li>
</ul>

<li><h3><u>Introduction:</u></h3>
<dl>
    <dt>What is a fill-value?</dt>
        <DD>
        <P>A fill-value is the value retrieved for a dataset element in HDF5
            when no application data has been written to that element.  The
            fill-value may be stored explicitly in the dataset by HDF5 or it
            may be implied in some way.
        </P>
        </DD> <BR>

    <dt>What does a dataset storage allocation mean?</dt>
        <DD>
        <P>Dataset storage allocation is a term used to indicate that space
            in a file has been reserved for the raw data of a dataset.
        </P>
        </DD> <BR>

    <DT>How are fill-values and dataset storage allocation handled currently in
        HDF4 and HDF5?</DT>
        <DD>
        <ol class="upperalpha">
            <li><h4><u>HDF4</u></h4>
            <P>These issues are specific to how the SD*() API functions operate
                in the latest version of HDF4, other portions of the HDF4
                library may operate in different ways.  Only the normal (i.e.
                "contiguous") and chunked storage methods are discussed, other
                storage methods (like external file storage, or linked-block
                storage) are treated as normal storage in HDF4.
            </P>

            <ol class="arabic">
                <li><u>Dataset Storage Allocation</u>
                <P>Allocating space to store a dataset is deferred until
                    the space is needed.  Space is only needed when
                    application data is written to a dataset.  This allows
                    for very large datasets to be defined, and if they are
                    not written to, the file size can stay very small.  This
                    applies to both contiguous and chunked data.
                </P>
                </LI>

                <li><u>Fill-values</u>
                <ol class="loweralpha">
                    <li><u>Metadata</u>
                    <P>Metadata documenting the fill-value is always
                        written to a file.  Either the default
                        fill-value (of zero) or the user's fill-value
                        is written as an attribute of the dataset.
                    </P>
                    </LI>

                    <li><u>Reading</u>
                    <P>If storage for the dataset or chunk is not
                        allocated yet, the fill-value is used to fill
                        the buffer to return to the application and the
                        file data is not read.
                    </P>
                    </LI>

                    <li><u>Writing</u>
                    <P>Fill-values are only written to the dataset or
                        chunk when the entire dataset or chunk is not
                        going to be written in a single I/O request.
                        For example: in a contiguously stored dataset,
                        if a hyperslab in the middle of the dataset is
                        written by the user (and this is the first
                        piece of data to be written to the dataset),
                        fill-values are written to the dataset and then
                        the user's data is written in the hyperslab
                        location.  However, if the entire dataset is
                        going to be written in one write call, then
                        the fill-value writing step is skipped, since
                        they would all be immediately over-written with
                        the actual data.
                    </P>

                    <P>Note: Writing fill-values in HDF4 can be turned
                        off completely by a user who either "knows" that
                        they will be writing the entire dataset in
                        successive calls, or who doesn't care about
                        data outside the region(s) they are writing to
                        in the dataset.
                    </P>
                    </LI>
                </ol>
                </LI>
            </ol>
            </LI>

            <li><h4><u>HDF5</u></h4>
            <P>These issues apply to all datasets in HDF5.  Only the contiguous
                and chunked storage methods are discussed, other storage
                methods (such as external file storage) are treated as
                contiguous storage in HDF5.
            </P>

            <ol class="arabic">
                <li><u>Dataset Storage Allocation</u>
                <P>Space for contiguously stored data is always allocated
                    during the creation of the dataset.  Space for chunk stored
                    data is allocated as needed, when data needs to be written
                    to the portion of the dataset that the chunk occupies.
                    (Except in the case of parallel I/O, where all the chunks
                    for a dataset are allocated at creation time also).
                </P>
                </LI>

                <li><u>Fill-values</u>
                <ol class="loweralpha">
                    <li><u>Metadata</u>
                    <P>Metadata documenting the fill-value for a dataset is
                        only written out if the user explicitly set a fill-value
                        for the dataset during creation.  Although there is an
                        implicit zero fill-value assumed for the dataset, this
                        is not enforced or recorded.
                    </P>
                    </LI>

                    <li><u>Reading</u>
                    <P>Fill-values are only used for chunked storage datasets
                        when an unallocated chunk is read from.  Because
                        contiguously stored data always allocates space in the
                        file, the library assumes that there is always valid
                        data to read for contiguous data.
                    </P>
                    </LI>

                    <li><u>Writing</u>
                    <P>Fill-values are only written to contiguously stored data
                        when a dataset is created (and only if the user has set
                        a fill-value).  This occurs irregardless of how the
                        fill-values will be overwritten by future writes to the
                        dataset.
                    </P>

                    <P>Fill-values for chunked storage data are somewhat more
                        controlled, they are written only when data is actually
                        written to a particular chunk.  This occurs irregardless
                        of how the fill-values will be overwritten by future
                        writes to the chunk.
                    </P>
                    </LI>
                </LI>
                </ol>
                </LI>
            </ol>
            </LI>
        </ol>

        </DD> <BR>

    <dt>Why these issues need to be faced now?</dt>
        <dd>
        <P> Although we've been aware of differences between the way
        storage space is allocated in a file and how fill-values are treated
        between HDF4 and HDF5 for a while, this hasn't been an especially
        burning problem that needed to be dealt with.  Unfortunately, there is
        a bug with the way that memory for variable-length (VL) data is being
        leaked in the file when the data elements are overwritten, and it is
        tied to these storage and fill-value issues.
        </P>

        <P>Currently, when VL data elements are over-written in a dataset, the
        space for the previous piece of VL data is not released to the file to
        be re-used, it is instead leaked and not reused.  Because the previous
        value for the VL data would need to be read from the file dataset in
        order to be properly released, it ties in with the fill-values stored
        in the file.  (For the current library design, since a heap ID is
        stored in the dataset for the location of the VL data, not the VL data
        itself, a heap ID set to all zeros is used to indicate that there is no
        VL data for a paticular location.  So currently, the only valid
        fill-value for VL data is an all zero value, indicating that no VL data
        has been stored in the heap.)
        </P>
         
        <P>If fill-values are not written to the file, then there is the
        potential for junk data to be read from the file as the VL data to be
        released and errors to occur.  Currently, the library relies on the
        filesystem to zero-fill blocks allocated to the file when there is no
        fill-value set for the dataset.  We've already seen this assumption
        break down under Win9x, where the OS does not zero-fill file blocks
        with zeros and users report "junk" in datasets which have been created,
        but not written to.
        </P>

        <P>So, VL data requires valid fill-values to be present in the file in
        order to be certain that reading the VL data to be overwritten is valid
        and contains the correct information to either free the previous VL
        data (in the case of non-NULL valued VL data) or not to try to free the
        previous VL data (for NULL valued VL data).  Having junk (or the
        potential for junk) in the data read from the file opens the possibility
        for corrupting data in the file if that junk data is used to try to
        free the previous VL data.
        </P>
    </dd> <br>

    <DT>How do fill-values and VL datatypes interact?</DT>
        <DD>Currently, the only valid fill-value for a VL datatype is specifying
            an all zero (0) valid, to indicate that there is no VL sequence for
            an element.
        </DD> <BR>

    <DT>How do fill-values and composite datatypes interact?</DT>
        <DD>When a fill-value is stored for a composite datatype (compound,
            array or variable-length), the value stored in the "new" fill-value
            header message (detailed below) is exactly the same how the values
            in the dataset elements are stored.
        </DD> <BR>

    <DT>How do fill-values and compound datatypes interact?</DT>
        <DD>It is possible to write to only one (out of potentially many) field
            in a compound dataset.  This has no affect on the operation which
            fills in the elements of the dataset, as all the elements of a
            dataset have the fill-value written to them, then they are
            overwritten with the application values specified, which are only a
            part of each element in this case.
        </DD> <BR>
</dl>

<li><h3><u>Design Goals:</u></h3>
                                                                 
<ul>
    <li>Provide a method for controlling when and how fill-values are written
        to a dataset.
    </li>
    <li>Provide a method for controlling when space is allocated for storing
        a dataset.
    </li>
</ul>
                                                                 
<li><h3><u>Primary Users:</u></h3>
                                                                 
<dl>
    <dt>Current HDF5 users</dt>
        <dd>Existing HDF5 users who are storing VL data and re-writing that
            data will need to stop leaking file data.  Existing HDF5 users who
            desire more control over how fill-values are written to their
            datasets and when space is allocated to store their raw date would
            benefit also.
        </dd>

    <dt>New users</dt>
        <dd>Additionally, there may be other users who have chosen not to use
            HDF5 due to the lack of the controls available, especially if they
            are currently using HDF4 and find these features important.
        </dd>
</dl>
                                                                 
<li><h3><u>Requirements:</u></h3>
                                             
<ul>
    <li>The library's performance and stability should not be impacted as a
        result of these new features.
    </li>
    <li>Changes from these new features must operation correctly and efficiently
        in a parallel programming environment as well as a serial environment.
    </LI>
    <li>Make as small of a set of changes to the HDF5 file format and
        programming API as possible by implementing this feature.
    </LI>
</ul>
                                             
<li><h3><u>Proposed Changes to Library Behavior:</u></h3>

<P> At the very minimum, to be able to fix the VL data memory leak, valid data
    should be available for all datasets with VL datatypes.  This is handled by
    requiring a fill value to be written for all datasets with VL datatype.
    This means that calls to H5Dcreate with a datatype which contains a VL
    datatype (either directly, or as part of a compound or array datatype) and
    have set the fill-value to "undefined" will fail.
</P>

<P>We can provide users with three properties to control the fill-value and
    allocation strategies of the library.  They are "when to allocate space",
    "when to write the fill-value" and the actual fill-value to write.
</P>

<P>
Each property is described below:

<ul>
<li>When to allocate space:
    <ol>
    <li>Early - during dataset create call.  Allocate storage for the dataset
                immediately when the dataset is created.
                Certain VFDs (like MPI-I/O and MPI-posix) require
                space to be allocated when a dataset is created, which will
                override the setting chosen by a user.
                </li>
    <li>Late  - during first write to dataset.  Defer allocating
                space for storing the dataset until the dataset is written to.
                Choosing incremental allocation for compact dataset storage is
                an error.
                </li>
    <li>Incremental  - during first write to chunk.  Defer allocating
                space for storing each chunk until the chunk is written to.
                Choosing incremental allocation for contiguous dataset storage
                is treated as late allocation.
                Choosing incremental allocation for compact dataset storage is
                an error.
                </li>
    <li>Default - Allocate storage for the dataset as appropriate for the
                storage method and access method.  The defaults are shown here:
                <TABLE BORDER="1">
                <TR>
                    <TD>
                    </TD>
                    <TD>Serial I/O
                    </TD>
                    <TD>Parallel I/O
                    </TD>
                </TR>
                <TR>
                    <TD>Contiguous Storage
                    </TD>
                    <TD>Late
                    </TD>
                    <TD>Early
                    </TD>
                </TR>
                <TR>
                    <TD>Chunked Storage
                    </TD>
                    <TD>Incremental
                    </TD>
                    <TD>Early
                    </TD>
                </TR>
                <TR>
                    <TD>Compact Storage
                    </TD>
                    <TD>Early
                    </TD>
                    <TD>Early
                    </TD>
                </TR>
                </TABLE>
                </li>
    </ol>
</li>

<li>When to write fill value:
    <ol>
    <li>Never - Fill value will never be written to dataset's storage.
        </li>
    <li>Allocation - Fill value is written when space is allocated.  This is
        the default for both chunked and contiguous data storage.
        </li>
    </ol> 
</li>

<li>What fill value to write:
    <ol>
    <li>Undefined - no value stored.
        </li>
    <li>Default   - library defined.  By default, the library defines a
        fill-value of all zero bytes (whatever that means for the datatype).
        </li>
    <li>User-defined - user defined value.
        </li>
    </ol>
</li>
</ul>

<P>By using these three properties, the library's behavior of fill value 
writing is listed in the table below during the dataset create-write-close 
cycle.

<P>
<table border cellspacing=0 cellpadding=5>
  <tr>
     <th>When to allocate space</th>
     <th>When to write fill value</th>
     <th>What fill value to write</th>
     <th>Library create-write-close behavior</th>
  </tr>
  <tr>
     <td>Early</td>
     <td>Never</td>
     <td>-----</td>
     <td>Library allocates space when dataset is created, but never writes
         fill value to dataset.</td>
  </tr>
  <tr>
     <td>Late </td>
     <td>Never</td>
     <td>-----</td>
     <td>Library allocates space when dataset is written to, but never 
         writes fill value to dataset.</td>
  </tr>
  <tr>
     <td>Incremental </td>
     <td>Never</td>
     <td>-----</td>
     <td>Library allocates space when dataset or chunk (whichever is smallest
        unit of space) is written to, but never 
         writes fill value to dataset or chunk.</td>
  </tr>
  <tr>
     <td>-----</td>
     <td>Allocation</td>
     <td>undefined</td>
     <td>Error on creating dataset, dataset not created.</td>
  </tr>
  <tr>
     <td>Early</td>
     <td>Allocation</td>
     <td>default or user-defined</td>
     <td>Allocate space for dataset when dataset is created.  Write fill 
         value (default or user-defined) to entire dataset when dataset is
         created.</td>
  </tr>
  <tr>
     <td>Late</td>
     <td>Allocation</td>
     <td>default or user-defined</td>
     <td>Doesn't allocate space for dataset until user's data values are
         written to dataset.  Write fill value to entire dataset before 
         writing user's data value.
  </tr>
  <tr>
     <td>Incremental</td>
     <td>Allocation</td>
     <td>default or user-defined</td>
     <td>Doesn't allocate space for dataset until user's data values are
         written to dataset or chunk (whichever is smallest unit of space).
         Write fill value to entire dataset or chunk before 
         writing user's data value.
  </tr>
</table>
----- stands for any value.<br><br>

During the H5Dread function call, the library behavior depends on whether
space has been allocated, whether fill value has been written to storage, 
how fill value is defined, and when to write fill value.<br><br>

<table border cellspacing=0 cellpadding=5>
  <tr>
     <th>Is space allocated?</th>
     <th>What is the fill value?</th>
     <th>When to write fill value?</th>
     <th>Library read behavior</th>
  </tr>
  <tr>
     <td rowspan=3>No</td>
     <td rowspan=2>undefined</td>
     <td>Allocation</td>
     <td>Error. Dataset can't exist, no data has been written, fill value
	 isn't defined.</td>
  </tr>
  <tr>
     <td>Never</td>
     <td>Error. Data doesn't exist, fill value isn't defined and therefore
        cannot be used to fill user's buffer.</td>
  </tr>
  <tr>
     <td>default or user-defined</td>
     <td>-----</td>
     <td>Fill user's buffer with fill value.</td>
  </tr>
  <tr>
     <td rowspan=3>Yes</td>
     <td>undefined</td>
     <td>-----</td>
     <td>Return data from storage(dataset), trash is possible if user has not
        written data to portion of dataset being read.</td>
  </tr>
  <tr>
     <td>default or user-defined</td>
     <td>Never</td>
     <td>Return data from storage(dataset), trash is possible if user has not
        written data to portion of dataset being read.</td>
  </tr>
  <tr>
     <td>default or user-defined</td>
     <td>Allocation</td>
     <td>Return data from storage(dataset).</td>  
  </tr>
</table>
----- stands for any value.<br><br>

<LI><H3><U>Implementation Plans:</U></H3>

<P>The work outlined in the document is already finished and checked into the
    library.  This document is describing the rationale for the changes and the
    exact changes implemented.
</P>

<li><h3><u>Changes Remaining:</u></h3>

<P>None currently.
</P>

<li><h3><u>Advanced Features:</u></h3>

<P>It may be possible in the future to specify valid VL information in the
    fill-value and have the library write that VL information to the file's
    global heap only once.  Then all the references to that VL information
    in the dataset would share the same VL information, without excessive
    duplication of the VL information.
    Care must be taken if this is implemented, to correctly handle the
    reference counts necessary when re-writing dataset elements currently using
    the shared value.
</P>

<P>It is possible to optimize the operation which writes the fill-value to a
    dataset, by only writing the fill-value to the elements which are not going
    to be overwritten by the applications first write to the dataset (when the
    fill time property is set to "allocation" and the space allocation property
    is set to "late").  This will improve performance in cases where the 
    application is writing a significant portion of the dataset.
    Care must be taken if this is implemented, to correctly handle the cases
    when an application is only writing part of a compound datatype, however.
    Additionally, this has extra complexities in a parallel I/O environment,
    which would have to be carefully handled.
</P>

<P>It is possible to optimize the operation which writes the fill-value to a
    dataset a bit more, by delaying writing the fill-values to the dataset
    until the dataset is closed.  This could be done by using a selection to
    build up the regions of the dataset which have been written to and then
    only write the fill-values to the "inverse" of that region when the dataset
    is closed.
    Care must be taken if this is implemented, to correctly handle the cases
    when an application is only writing part of a compound datatype, however.
    Additionally, this has extra complexities in a parallel I/O environment,
    which would have to be carefully handled.
</P>

<P>It is possible to optimize the fill-value I/O situation even further by
    <EM>never</EM> writing full fill-values to the dataset.  Instead, the
    regions of the dataset which have been written to by the user are tracked
    with a selection and the selection is stored with the dataset in the file.
    Then, when an application attempted to read elements outside that region,
    the fill-values would be placed directly into the applications buffer,
    having never been actually stored in the file at all.
    Care must be taken if this is implemented, to correctly handle the cases
    when an application is only writing part of a compound datatype, however.
    Additionally, this has extra complexities in a parallel I/O environment,
    which would have to be carefully handled.
</P>

<li><h3><u>Alternate Approachs:</u></h3>

<P><EM>None proposed</EM>
</P>

<li><h3><u>File Format Changes:</u></h3>

<P>The changes in this document require two object header message changes.
For the data storage layout message, the "address" value has been changed to
express unallocated space.  A "new" fill-value message has been added with
new fields to store the information contained in the new properties.
</P>

<P>The revised data storage layout message follows, with the only changes being
    in the description of the "Version" and "Address" fields:
<UL>
    <STRONG>Name:</STRONG> Data Storage - Layout <BR>
    <STRONG>Type:</STRONG> 0x0008 <BR>
    <STRONG>Length:</STRONG> varies <BR>
    <STRONG>Status:</STRONG> Required for datasets, may not be repeated <BR>
    <STRONG>Purpose:</STRONG> Data layout describes how the elements of a
        multi-dimensional array are arranged in the linear address space of
        the file.  Two types of data layout are supported: <BR> <BR>
        <OL class="arabic">
            <LI>The array can be stored in one contiguous area of the file. The
                layout requires that the size of the array be constant and does
                not permit chunking, compression, checksums, encryption, etc.
                The message stores the total size of the array and the offset
                of an element from the beginning of the storage area is
                computed as in C.
            </LI> <BR>

            <LI>The array domain can be regularly decomposed into chunks and
                each chunk is allocated separately.  This layout supports
                arbitrary element traversals, compression, encryption, and
                checksums, and the chunks can be distributed across external
                raw data files (these features are described in other messages).
                The message stores the size of a chunk instead of the size of
                the entire array; the size of the entire array can be
                calculated by traversing the B-tree that stores the chunk
                addresses.
            </LI> <BR>
        </OL>
    <STRONG>Format:</STRONG>
    <TABLE ALIGN=center BORDER=1 WIDTH="60%">
        <TR ALIGN="center">
            <TD><STRONG>byte</STRONG></TD>
            <TD><STRONG>byte</STRONG></TD>
            <TD><STRONG>byte</STRONG></TD>
            <TD><STRONG>byte</STRONG></TD>
        </TR>
        <TR ALIGN="center">
            <TD>Version</TD>
            <TD>Dimensionality</TD>
            <TD>Layout Class</TD>
            <TD>Reserved</TD>
        </TR>
        <TR ALIGN="center">
            <TD COLSPAN=4>Reserved</TD>
        </TR>
        <TR ALIGN="center">
            <TD COLSPAN=4><BR>Address<BR><BR></TD>
        </TR>
        <TR ALIGN="center">
            <TD COLSPAN=4>Dimension 0</TD>
        </TR>
        <TR ALIGN="center">
            <TD COLSPAN=4>Dimension 1</TD>
        </TR>
        <TR ALIGN="center">
            <TD COLSPAN=4>...</TD>
        </TR>
    </TABLE> <BR>
    <STRONG>Description:</STRONG>
    <TABLE ALIGN=center BORDER=0 WIDTH="90%" CELLPADDING=8>
        <TR ALIGN="center">
            <TD WIDTH="30%"><STRONG>Field Name</STRONG></TD>
            <TD><STRONG>Description</STRONG></TD>
        </TR>
        <TR ALIGN="left">
            <TD VALIGN=top WIDTH="30%">Version</TD>
            <TD>A version number for the layout message.  This document
                describes version two (2).
            </TD>
        </TR>
        <TR ALIGN="left">
            <TD VALIGN=top WIDTH="30%">Dimensionality</TD>
            <TD>An array has a fixed dimensionality.  This field specifies the
                number of dimension size fields later in the message.
            </TD>
        </TR>
        <TR ALIGN="left">
            <TD VALIGN=top WIDTH="30%">Layout Class</TD>
            <TD>The layout class specifies how the other fields of the layout
                message are to be interpreted. A value of one (1) indicates
                contiguous storage while a value of two (2) indicates chunked
                storage.  Other values will be defined in the future.
            </TD>
        </TR>
        <TR ALIGN="left">
            <TD VALIGN=top WIDTH="30%">Address</TD>
            <TD>For contiguous storage, this is the offset of the first byte
                of raw data information for the dataset. This offset may
                contain the value "HADDR_UNDEF" (-1) to indicate the storage
                space has not been allocated.  For chunked storage this is the
                offset of the B-tree that is used to look up the offsets of
                the chunks.
            </TD>
        </TR>
        <TR ALIGN="left">
            <TD VALIGN=top WIDTH="30%">Dimension 0...n</TD>
            <TD>For contiguous storage the dimensions define the entire size of
                the array while for chunked storage they define the size of a
                single chunk.
            </TD>
        </TR>
    </TABLE>
</UL>
</P>

<P>The new fill-value message follows.  This is a new object header message,
    designed to supercede the current fill-value message.  The old fill-value
    message lacked a "Version" field and thus could not be changed to
    accomodate the new information to be stored.  The old fill-value message
    will still be written out when appropriate, to facilitate forward
    compatibility with new files being read by old versions of the library.
<UL>
    <STRONG>Name:</STRONG> Data Storage - New Fill-Value <BR>
    <STRONG>Type:</STRONG> 0x0005 <BR>
    <STRONG>Length:</STRONG> varies <BR>
    <STRONG>Status:</STRONG> Optional, may not be repeated <BR>
    <STRONG>Purpose:</STRONG> This fill value message stores a single data
        element value and its related properties - space allocation time,
        fill-value write time, and whether fill-value is defined.
        The fill value is is stored and interpreted as having the same datatype
        as that defined for the elements of the dataset. <BR>
    <STRONG>Format:</STRONG>
    <TABLE ALIGN=center BORDER=1 WIDTH="60%">
        <TR ALIGN="center">
            <TD><STRONG>byte</STRONG></TD>
            <TD><STRONG>byte</STRONG></TD>
            <TD><STRONG>byte</STRONG></TD>
            <TD><STRONG>byte</STRONG></TD>
        </TR>
        <TR ALIGN="center">
            <TD>Version</TD>
            <TD>Space allocation time</TD>
            <TD>Fill-value write time</TD>
            <TD>Fill-value defined?</TD>
        </TR>
        <TR ALIGN="center">
            <TD COLSPAN=4>Size</TD>
        </TR>
        <TR ALIGN="center">
            <TD COLSPAN=4><BR>Fill-Value<BR><BR></TD>
        </TR>
    </TABLE> <BR>
    <STRONG>Description:</STRONG>
    <TABLE ALIGN=center BORDER=0 WIDTH="90%" CELLPADDING=8>
        <TR ALIGN="center">
            <TD WIDTH="30%"><STRONG>Field Name</STRONG></TD>
            <TD><STRONG>Description</STRONG></TD>
        </TR>
        <TR ALIGN="left">
            <TD VALIGN=top WIDTH="30%">Version</TD>
            <TD>A version number for the layout message.  This document
                describes version one (1).
            </TD>
        </TR>
        <TR ALIGN="left">
            <TD VALIGN=top WIDTH="30%">Space allocation time</TD>
            <TD>When to allocate storage space.  Specifies whether to allocate
                space when the dataset is created (a value of one (1)), or when
                application data is written to the dataset (a value of two (2)).
            </TD>
        </TR>
        <TR ALIGN="left">
            <TD VALIGN=top WIDTH="30%">Fill-value write time</TD>
            <TD>When to write fill-value to dataset.  A value of zero (0)
                indicates never to write fill-values; a value of one (1) 
                indicates to write fill value when storage space is allocated
                for the dataset.
            </TD>
        </TR>
        <TR ALIGN="left">
            <TD VALIGN=top WIDTH="30%">Fill-value defined?</TD>
            <TD>A value of zero (0) means the fill-value is undefined for this
                dataset; a value of one (1) indicates the fill-value is defined
                (either default or user-defined).  If undefined, the "Size"
                field will have the value of zero and the "Fill-value" field
                will not exist.
            </TD>
        </TR>
        <TR ALIGN="left">
            <TD VALIGN=top WIDTH="30%">Size</TD>
            <TD>This the size of the "Fill-value" field in bytes.
            </TD>
        </TR>
        <TR ALIGN="left">
            <TD VALIGN=top WIDTH="30%">Fill-Value</TD>
            <TD>The actual fill-value.  The fill-value is interpreted using the
                same datatype as for the dataset.
            </TD>
        </TR>
    </TABLE>
</UL>
</P>

<li><h3><u>Changes to current API Calls:</u></h3>

<P>Minor changes have been made to existing library API functions:
<UL> <DL>
    <DT>H5Dcreate</DT>
        <DD>This function now returns an error if a user attempts to create a
            dataset using a datatype which containg a VL dataset (either
            directly, or as part of a [nested] compound or array datatype) and
            the fill-value in the dataset creation properties is set to
            "undefined".
        </DD> <BR>
    <DT>H5Dwrite</DT>
        <DD>This function now allocates space for the dataset and optionally
            fills it with the fill-value, if space has not been allocated for
            the dataset yet.
        </DD> <BR>
    <DT>H5Dread</DT>
        <DD>This function now fills in the users buffer with the fill-value
            if space has not been allocated for the dataset and a fill-value
            is defined for the dataset.
        </DD> <BR>
</DL> </UL>
</P>

<P>The following API calls have changed significantly:
<HR>
<UL> <DL>
    <DT><STRONG>Name:</STRONG></DT>
        <DD>H5Pset_fill_value
        </DD>
    <DT><STRONG>Purpose:</STRONG></DT>
        <DD>Sets the fill-value for a dataset.
        </DD>
    <DT><STRONG>Signature:</STRONG></DT>
        <DD>herr_t H5Pset_fill_value(hid_t <EM>dcpl_id</EM>,
            hid_t <EM>type_id</EM>,
            const void *<EM>value</EM>)
        </DD>
    <DT><STRONG>Parameters:</STRONG></DT>
        <DD>
        <DL>
            <DT>hid_t <EM>dcpl_id</EM></DT>
                <DD>IN: ID of dataset creation property list to operate on.
                </DD>
            <DT>hid_t <EM>type_id</EM></DT>
                <DD>IN: ID of datatype describing the <EM>value</EM> parameter.
                </DD>
            <DT>void *<EM>value</EM></DT>
                <DD>IN: Pointer to buffer containing the value to use as
                    fill-value.
                </DD>
        </DL>
        </DD>
    <DT><STRONG>Return Value:</STRONG></DT>
        <DD>Returns non-negative on success, negative on failure.
        </DD>
    <DT><STRONG>Description:</STRONG></DT>
        <DD>This function sets the fill-value for a dataset creation property
            list.  The datatype of a fill-value used in a dataset creation
            property list may be different from the datatype of the dataset
            created, but the two datatypes must be convertible by the library.
            The library currently uses a default fill-value of all zeros for
            datasets, interpreted according to whatever the datatype of the
            dataset is.  Passing a value of NULL for the <EM>value</EM>
            parameter indicates that the fill-value is to be undefined.
        <P>This function is designed to coordinate with the storage allocation
            time and fill-value write time properties (set with
            H5Pset_alloc_time and H5Pset_fill_time).
        </P>
        </DD>
</DL> </UL>
<HR>

<UL> <DL>
    <DT><STRONG>Name:</STRONG></DT>
        <DD>H5Pget_fill_value
        </DD>
    <DT><STRONG>Purpose:</STRONG></DT>
        <DD>Retrievs the fill-value for a dataset.
        </DD>
    <DT><STRONG>Signature:</STRONG></DT>
        <DD>herr_t H5Pget_fill_value(hid_t <EM>dcpl_id</EM>,
            hid_t <EM>type_id</EM>,
            void *<EM>value</EM>)
        </DD>
    <DT><STRONG>Parameters:</STRONG></DT>
        <DD>
        <DL>
            <DT>hid_t <EM>dcpl_id</EM></DT>
                <DD>IN: ID of dataset creation property list to query.
                </DD>
            <DT>hid_t <EM>type_id</EM></DT>
                <DD>IN: ID of datatype describing the fill-value to be placed
                    in the <EM>value</EM> parameter.
                </DD>
            <DT>void *<EM>value</EM></DT>
                <DD>OUT: Pointer to buffer where fill-value will be placed.
                </DD>
        </DL>
        </DD>
    <DT><STRONG>Return Value:</STRONG></DT>
        <DD>Returns non-negative on success, negative on failure.
        </DD>
    <DT><STRONG>Description:</STRONG></DT>
        <DD>This function retrieves the fill-value from a dataset creation
            property list.  The datatype of a fill-value used in a dataset
            creation property list may be different from the datatype requested
            in the <EM>type_id</EM> parameter, but the two datatypes must be
            convertible by the library.  It is an error to query the fill-value
            when the fill-value is undefined.  H5Pfill_value_defined should
            be used to check for this condition before this function is called.
        <P>This function is designed to coordinate with the storage allocation
            time and fill-value write time properties (retrieved with
            H5Pget_alloc_time and H5Pget_fill_time).
        </P>
        </DD>
</DL> </UL>
<HR>


</P>

<li><h3><u>New API Calls:</u></h3>

<P>The following API calls have been implemented:
<HR>
<UL> <DL>
    <DT><STRONG>Name:</STRONG></DT>
        <DD>H5Pset_alloc_time
        </DD>
    <DT><STRONG>Purpose:</STRONG></DT>
        <DD>Set the time of data storage allocation for creating a dataset.
        </DD>
    <DT><STRONG>Signature:</STRONG></DT>
        <DD>herr_t H5Pset_alloc_time(hid_t <EM>dcpl_id</EM>,
            H5D_alloc_time_t <EM>alloc_time</EM>)
        </DD>
    <DT><STRONG>Parameters:</STRONG></DT>
        <DD>
        <DL>
            <DT>hid_t <EM>dcpl_id</EM></DT>
                <DD>IN: ID of dataset creation property list to operate on.
                </DD>
            <DT>H5D_alloc_time_t <EM>alloc_time</EM></DT>
                <DD>IN: Time to allocate space for dataset.
                </DD>
        </DL>
        </DD>
    <DT><STRONG>Return Value:</STRONG></DT>
        <DD>Returns non-negative on success, negative on failure.
        </DD>
    <DT><STRONG>Description:</STRONG></DT>
        <DD>This function indicates when to
            allocate storage space for a dataset.  Valid values for
            <EM>alloc_time</EM> are:
            <UL> <DL>
                <DT>H5D_ALLOC_TIME_DEFAULT</DT>
                    <DD>Use the default time for each storage method to choose
                        when to allocate space for the dataset.
                    </DD>
                <DT>H5D_ALLOC_TIME_EARLY</DT>
                    <DD>Allocate all space when the dataset is created.  (Default
                        for compact stored datasets)
                    </DD>
                <DT>H5D_ALLOC_TIME_INCR</DT>
                    <DD>Allocate space incrementally as the dataset is written
                        to.  Defers allocating space for storing each chunk
                        until a chunk is written to.  Choosing incremental
                        allocation for contiguous dataset storage is treated as
                        late allocation.  Choosing incremental allocation for
                        compact dataset storage is an error.
                        (Default for chunked storage datasets)
                    </DD>
                <DT>H5D_ALLOC_TIME_LATE</DT>
                    <DD>Allocate all space when the dataset is first written to.
                        (Default for contiguous storage datasets)
                    </DD>
            </DL> </UL>
        <P>This function is designed to coordinate with the fill-value write
            time and fill-value properties (set with H5Pset_fill_time and
            H5Pset_fill_value).
        </P>
        </DD>
</DL> </UL>
<HR>

<UL> <DL>
    <DT><STRONG>Name:</STRONG></DT>
        <DD>H5Pget_alloc_time
        </DD>
    <DT><STRONG>Purpose:</STRONG></DT>
        <DD>Retrieve the time of data storage allocation for creating a dataset.
        </DD>
    <DT><STRONG>Signature:</STRONG></DT>
        <DD>herr_t H5Pget_alloc_time(hid_t <EM>dcpl_id</EM>,
            H5D_alloc_time_t *<EM>alloc_time</EM>)
        </DD>
    <DT><STRONG>Parameters:</STRONG></DT>
        <DD>
        <DL>
            <DT>hid_t <EM>dcpl_id</EM></DT>
                <DD>IN: Identifier of dataset creation property list to query.
                </DD>
            <DT>H5D_alloc_time_t *<EM>alloc_time</EM></DT>
                <DD>OUT: Time to allocate space for dataset.
                </DD>
        </DL>
        </DD>
    <DT><STRONG>Return Value:</STRONG></DT>
        <DD>Returns non-negative on success, negative on failure.
        </DD>
    <DT><STRONG>Description:</STRONG></DT>
        <DD>This function indicates when storage
            space will be allocated for a dataset.  Valid values placed in
            <EM>alloc_time</EM> are:
            <UL> <DL>
                <DT>H5D_ALLOC_TIME_DEFAULT</DT>
                    <DD>Use default allocation time, based on dataset storage
                        method.
                    </DD>
                <DT>H5D_ALLOC_TIME_EARLY</DT>
                    <DD>Allocate all space when the dataset is created.
                    </DD>
                <DT>H5D_ALLOC_TIME_INCR</DT>
                    <DD>Allocate space incremenentally as the dataset is
                    written to.
                    </DD>
                <DT>H5D_ALLOC_TIME_LATE</DT>
                    <DD>Allocate all space when the dataset is first written to.
                    </DD>
            </DL> </UL>
        <P>This function is designed to coordinate with the fill-value write
            time and fill-value properties (retrieved with H5Pget_fill_time and
            H5Pget_fill_value).
        </P>
        </DD>
</DL> </UL>
<HR>

<UL> <DL>
    <DT><STRONG>Name:</STRONG></DT>
        <DD>H5Pset_fill_time
        </DD>
    <DT><STRONG>Purpose:</STRONG></DT>
        <DD>Set the time when fill-values are written to a dataset.
        </DD>
    <DT><STRONG>Signature:</STRONG></DT>
        <DD>herr_t H5Pset_fill_time(hid_t <EM>dcpl_id</EM>,
            H5D_fill_time_t <EM>fill_time</EM>)
        </DD>
    <DT><STRONG>Parameters:</STRONG></DT>
        <DD>
        <DL>
            <DT>hid_t <EM>dcpl_id</EM></DT>
                <DD>IN: ID of dataset creation property list to operate on.
                </DD>
            <DT>H5D_fill_time_t <EM>fill_time</EM></DT>
                <DD>IN: When to write fill-values to a dataset.
                </DD>
        </DL>
        </DD>
    <DT><STRONG>Return Value:</STRONG></DT>
        <DD>Returns non-negative on success, negative on failure.
        </DD>
    <DT><STRONG>Description:</STRONG></DT>
        <DD>This function indicates when to
            write fill-values to a dataset.  Valid values for
            <EM>fill_time</EM> are:
            <UL> <DL>
                <DT>H5D_FILL_TIME_ALLOC</DT>
                    <DD>Write fill-values when the space for dataset is
                        allocated.  (Default)
                    </DD>
                <DT>H5D_FILL_TIME_NEVER</DT>
                    <DD>Never write fill-values to dataset.
                    </DD>
            </DL> </UL>
        <P>This function is designed to coordinate with the space allocation
            time and fill-value properties (set with H5Pset_alloc_time and
            H5Pset_fill_value).
        </P>
        </DD>
</DL> </UL>
<HR>

<UL> <DL>
    <DT><STRONG>Name:</STRONG></DT>
        <DD>H5Pget_fill_time
        </DD>
    <DT><STRONG>Purpose:</STRONG></DT>
        <DD>Retrieve the time when fill-values are written to a dataset.
        </DD>
    <DT><STRONG>Signature:</STRONG></DT>
        <DD>herr_t H5Pget_fill_time(hid_t <EM>dcpl_id</EM>,
            H5D_fill_time_t *<EM>fill_time</EM>)
        </DD>
    <DT><STRONG>Parameters:</STRONG></DT>
        <DD>
        <DL>
            <DT>hid_t <EM>dcpl_id</EM></DT>
                <DD>IN: ID of dataset creation property list to query.
                </DD>
            <DT>H5D_fill_time_t *<EM>fill_time</EM></DT>
                <DD>OUT: When fill-values will be written to a dataset.
                </DD>
        </DL>
        </DD>
    <DT><STRONG>Return Value:</STRONG></DT>
        <DD>Returns non-negative on success, negative on failure.
        </DD>
    <DT><STRONG>Description:</STRONG></DT>
        <DD>This function indicates fill-values
            will be written to a dataset.  Valid values placed in
            <EM>fill_time</EM> are:
            <UL> <DL>
                <DT>H5D_FILL_TIME_ALLOC</DT>
                    <DD>Write fill-values when the space for dataset is
                        allocated.
                    </DD>
                <DT>H5D_FILL_TIME_NEVER</DT>
                    <DD>Never write fill-values to dataset.
                    </DD>
            </DL> </UL>
        <P>This function is designed to coordinate with the space allocation
            time and fill-value properties (retrieved with H5Pget_alloc_time and
            H5Pget_fill_value).  
        </P>
        </DD>
</DL> </UL>
<HR>

<UL> <DL>
    <DT><STRONG>Name:</STRONG></DT>
        <DD>H5Pfill_value_defined
        </DD>
    <DT><STRONG>Purpose:</STRONG></DT>
        <DD>Check if fill-value is defined.
        </DD>
    <DT><STRONG>Signature:</STRONG></DT>
        <DD>herr_t H5Pfill_value_defined(hid_t <EM>dcpl_id</EM>,
            H5D_fill_value_t *<EM>status</EM>)
        </DD>
    <DT><STRONG>Parameters:</STRONG></DT>
        <DD>
        <DL>
            <DT>hid_t <EM>dcpl_id</EM></DT>
                <DD>IN: ID of dataset creation property list to query.
                </DD>
            <DT>H5D_fill_value_t *<EM>status</EM></DT>
                <DD>OUT: Status of fill-value property in property list.
                </DD>
        </DL>
        </DD>
    <DT><STRONG>Return Value:</STRONG></DT>
        <DD>Returns non-negative on success, negative on failure.
        </DD>
    <DT><STRONG>Description:</STRONG></DT>
        <DD>This function checks if the fill-value property in the dataset
            creation property list has been defined.  Valid values returned in
            <EM>status</EM> are:
            <UL> <DL>
                <DT>H5D_FILL_VALUE_UNDEFINED</DT>
                    <DD>Fill-value is undefined.
                    </DD>
                <DT>H5D_FILL_VALUE_DEFAULT</DT>
                    <DD>Fill-value is the library default.
                    </DD>
                <DT>H5D_FILL_VALUE_USER_DEFINED</DT>
                    <DD>Fill-value is defined by user application.
                    </DD>
            </DL> </UL>
        <P>This function is designed to coordinate with the space allocation
            time, fill-value time and fill-value properties (retrieved with
            H5Pget_alloc_time, H5Pget_fill_time and H5Pget_fill_value).  
        </P>
        </DD>
</DL> </UL>
<HR>

<UL> <DL>
    <DT><STRONG>Name:</STRONG></DT>
        <DD>H5Dget_space_status
        </DD>
    <DT><STRONG>Purpose:</STRONG></DT>
        <DD>Check if space is allocated for a dataset
        </DD>
    <DT><STRONG>Signature:</STRONG></DT>
        <DD>herr_t H5Dget_space_status(hid_t <EM>dset_id</EM>,
            H5D_space_status_t *<EM>status</EM>)
        </DD>
    <DT><STRONG>Parameters:</STRONG></DT>
        <DD>
        <DL>
            <DT>hid_t <EM>dset_id</EM></DT>
                <DD>IN: ID of dataset to query.
                </DD>
            <DT>H5D_space_status_t *<EM>status</EM></DT>
                <DD>OUT: Status of space allocation for dataset.
                </DD>
        </DL>
        </DD>
    <DT><STRONG>Return Value:</STRONG></DT>
        <DD>Returns non-negative on success, negative on failure.
        </DD>
    <DT><STRONG>Description:</STRONG></DT>
        <DD>This function checks if space has been allocated for the dataset.
            Valid values returned in <EM>status</EM> are:
            <UL> <DL>
                <DT>H5D_SPACE_STATUS_NOT_ALLOCATED</DT>
                    <DD>Space has not been allocated for datasets.
                    </DD>
                <DT>H5D_SPACE_STATUS_ALLOCATED</DT>
                    <DD>Space has been allocated for datasets.
                    </DD>
                <DT>H5D_SPACE_STATUS_PART_ALLOCATED</DT>
                    <DD>Space has been partially allocated for datasets.  (Only
                        returned for datasets using chunked storage).
                    </DD>
            </DL> </UL>
        </DD>
</DL> </UL>
<HR>

</P>

</ol>

<hr>
<i>QAK:10/9/02</i>
</body>
</html>
